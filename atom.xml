<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WHZ0325&#39;s Space</title>
  
  <subtitle>只有翻过这座山才能让他们听到你的故事</subtitle>
  <link href="https://whz0325.github.io/atom.xml" rel="self"/>
  
  <link href="https://whz0325.github.io/"/>
  <updated>2023-11-18T14:52:36.801Z</updated>
  <id>https://whz0325.github.io/</id>
  
  <author>
    <name>WHZ0325</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL 练习记录</title>
    <link href="https://whz0325.github.io/mysql-practice/"/>
    <id>https://whz0325.github.io/mysql-practice/</id>
    <published>2023-11-18T12:00:00.000Z</published>
    <updated>2023-11-18T14:52:36.801Z</updated>
    
    <content type="html"><![CDATA[<h3 id="175-组合两个表"><a href="#175-组合两个表" class="headerlink" title="#175. 组合两个表"></a>#175. 组合两个表</h3><p>select 得到的列，from 后用 left join 拼接，on 后是拼接规则。</p><p>末尾分号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select firstName, lastName, city, state</span><br><span class="line">from Person left join Address</span><br><span class="line">on Person.PersonId = Address.PersonId;</span><br></pre></td></tr></table></figure><h3 id="181-收入超过经理的用户"><a href="#181-收入超过经理的用户" class="headerlink" title="#181. 收入超过经理的用户"></a>#181. 收入超过经理的用户</h3><p>select 的 from 后跟两个会得到笛卡尔乘积，应当用 and 连接筛选条件，由于 select 只要头为 Employee 的 name 要用 as。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select a.name as Employee</span><br><span class="line">from Employee as a, Employee as b</span><br><span class="line">where a.managerId = b.id and a.salary &gt; b.salary;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;175-组合两个表&quot;&gt;&lt;a href=&quot;#175-组合两个表&quot; class=&quot;headerlink&quot; title=&quot;#175. 组合两个表&quot;&gt;&lt;/a&gt;#175. 组合两个表&lt;/h3&gt;&lt;p&gt;select 得到的列，from 后用 left join 拼接，on 后是</summary>
      
    
    
    
    
    <category term="DB" scheme="https://whz0325.github.io/tags/DB/"/>
    
    <category term="MySQL" scheme="https://whz0325.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>关于欧拉回路的逆序输出问题</title>
    <link href="https://whz0325.github.io/about-euler-circuit/"/>
    <id>https://whz0325.github.io/about-euler-circuit/</id>
    <published>2023-09-18T03:16:00.000Z</published>
    <updated>2024-10-10T05:24:49.195Z</updated>
    
    <content type="html"><![CDATA[<p>关于欧拉回路输出方案时，这么写是错误的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(g[x][i]) &#123;</span><br><span class="line">            --d[x]; --d[i]; --g[x][i]; --g[i][x];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, x, i); <span class="built_in">dfs</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这样写则是正确的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(g[x][i]) &#123;</span><br><span class="line">            --d[x]; --d[i]; --g[x][i]; --g[i][x];</span><br><span class="line">            <span class="built_in">dfs</span>(i); <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, i, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给出一组反例：</p><p><img src="/../images/euler.png" alt="欧拉回路"></p><p>如图，假若我们存的图在访问结点 3 时优先访问红边，其次访问黄边。</p><p>错误的方案会得到 $(1,2),(2,3),(3,1),(3,3)$，而正确的方案会得到 $(1,3),(3,3),(3,2),(2,1)$。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于欧拉回路输出方案时，这么写是错误的：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;lin</summary>
      
    
    
    
    <category term="算法竞赛" scheme="https://whz0325.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>一类换根问题</title>
    <link href="https://whz0325.github.io/2023-09-06/"/>
    <id>https://whz0325.github.io/2023-09-06/</id>
    <published>2023-09-06T03:46:00.000Z</published>
    <updated>2023-09-06T04:56:52.050Z</updated>
    
    <content type="html"><![CDATA[<p>昨天训练的时候遇到一道树形 DP 题，做法似乎很经典，来记录一下。</p><p>参考 <a href="https://zhuanlan.zhihu.com/p/580249398">严格鸽的知乎</a>。</p><h3 id="【CF-633F】The-Chocolate-Spree"><a href="#【CF-633F】The-Chocolate-Spree" class="headerlink" title="【CF 633F】The Chocolate Spree"></a>【CF 633F】The Chocolate Spree</h3><p>求两条不相交链的最大权值和。</p><p>使用换根 DP，枚举将两条链分开的边，两条链分别在这条边所分成的两棵子树中。</p><p>可以转化为考虑维护一棵子树中的最长链以及在换根时的转移，记 $f[i]$ 为到结点 $i$ 的链的最大权值和，则以 $i$ 为根的子树中的答案 $ans[i]$ 为经过 $i$ 的最长链（由最长和次长两个子节点中的链拼成）和 $i$ 子树中的最长链 $ans[i]$。</p><p>换根的过程中需要转移信息，就用一个多重集合来保存用于计算最大权值和的若干个候选数，在更换根节点的过程中维护。</p><p>在所枚举边两侧的子树都独立时统计答案，时间复杂度为 $O(nlog_2n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">1</span> &lt;&lt; <span class="number">16</span>], *fs = buf, *ft = buf;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fs == ft) &#123;</span><br><span class="line">        ft = (fs = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, <span class="number">1</span> &lt;&lt; <span class="number">16</span>, stdin);</span><br><span class="line">        <span class="keyword">if</span>(fs == ft) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *fs++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>, f = <span class="number">0</span>; <span class="type">char</span> c = <span class="built_in">gc</span>();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || <span class="string">&#x27;9&#x27;</span> &lt; c) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">1</span>;</span><br><span class="line">        c = <span class="built_in">gc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c = <span class="built_in">gc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f ? -num : num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N]; std::vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">data</span> &#123;</span><br><span class="line">    std::multiset&lt;ll&gt; ms;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(ll x)</span> </span>&#123; ms.<span class="built_in">insert</span>(x); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span><span class="params">(ll x)</span> </span>&#123; ms.<span class="built_in">erase</span>(ms.<span class="built_in">find</span>(x)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ms.<span class="built_in">size</span>() &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = ms.<span class="built_in">end</span>(); --it; <span class="keyword">return</span> *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">nax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ms.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = ms.<span class="built_in">end</span>(); --it; --it; <span class="keyword">return</span> *it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; f[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    f[x].<span class="built_in">add</span>(a[x]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, ed = g[x].<span class="built_in">size</span>(); i &lt; ed; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> v = g[x][i]; <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v, x);</span><br><span class="line">        f[x].<span class="built_in">add</span>(f[v].<span class="built_in">max</span>() + a[x]);</span><br><span class="line">        ans[x].<span class="built_in">add</span>(ans[v].<span class="built_in">max</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    ans[x].<span class="built_in">add</span>(f[x].<span class="built_in">nax</span>() ? f[x].<span class="built_in">max</span>() + f[x].<span class="built_in">nax</span>() - a[x] : f[x].<span class="built_in">max</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, ed = g[x].<span class="built_in">size</span>(); i &lt; ed; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> v = g[x][i]; <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Remove v from x */</span></span><br><span class="line">        ans[x].<span class="built_in">del</span>(f[x].<span class="built_in">nax</span>() ? f[x].<span class="built_in">max</span>() + f[x].<span class="built_in">nax</span>() - a[x] : f[x].<span class="built_in">max</span>());</span><br><span class="line">        f[x].<span class="built_in">del</span>(f[v].<span class="built_in">max</span>() + a[x]);</span><br><span class="line">        ans[x].<span class="built_in">del</span>(ans[v].<span class="built_in">max</span>());</span><br><span class="line">        ans[x].<span class="built_in">add</span>(f[x].<span class="built_in">nax</span>() ? f[x].<span class="built_in">max</span>() + f[x].<span class="built_in">nax</span>() - a[x] : f[x].<span class="built_in">max</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Calculate answer between x and v */</span></span><br><span class="line">        res = std::<span class="built_in">max</span>(res, ans[x].<span class="built_in">max</span>() + ans[v].<span class="built_in">max</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Add x to v */</span></span><br><span class="line">        ans[v].<span class="built_in">del</span>(f[v].<span class="built_in">nax</span>() ? f[v].<span class="built_in">max</span>() + f[v].<span class="built_in">nax</span>() - a[v] : f[v].<span class="built_in">max</span>());</span><br><span class="line">        f[v].<span class="built_in">add</span>(f[x].<span class="built_in">max</span>() + a[v]);</span><br><span class="line">        ans[v].<span class="built_in">add</span>(ans[x].<span class="built_in">max</span>());</span><br><span class="line">        ans[v].<span class="built_in">add</span>(f[v].<span class="built_in">nax</span>() ? f[v].<span class="built_in">max</span>() + f[v].<span class="built_in">nax</span>() - a[v] : f[v].<span class="built_in">max</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dp</span>(v, x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Remove x from v */</span></span><br><span class="line">        ans[v].<span class="built_in">del</span>(f[v].<span class="built_in">nax</span>() ? f[v].<span class="built_in">max</span>() + f[v].<span class="built_in">nax</span>() - a[v] : f[v].<span class="built_in">max</span>());</span><br><span class="line">        ans[v].<span class="built_in">del</span>(ans[x].<span class="built_in">max</span>());</span><br><span class="line">        f[v].<span class="built_in">del</span>(f[x].<span class="built_in">max</span>() + a[v]);</span><br><span class="line">        ans[v].<span class="built_in">add</span>(f[v].<span class="built_in">nax</span>() ? f[v].<span class="built_in">max</span>() + f[v].<span class="built_in">nax</span>() - a[v] : f[v].<span class="built_in">max</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Add v to x */</span></span><br><span class="line">        ans[x].<span class="built_in">del</span>(f[x].<span class="built_in">nax</span>() ? f[x].<span class="built_in">max</span>() + f[x].<span class="built_in">nax</span>() - a[x] : f[x].<span class="built_in">max</span>());</span><br><span class="line">        ans[x].<span class="built_in">add</span>(ans[v].<span class="built_in">max</span>());</span><br><span class="line">        f[x].<span class="built_in">add</span>(f[v].<span class="built_in">max</span>() + a[x]);</span><br><span class="line">        ans[x].<span class="built_in">add</span>(f[x].<span class="built_in">nax</span>() ? f[x].<span class="built_in">max</span>() + f[x].<span class="built_in">nax</span>() - a[x] : f[x].<span class="built_in">max</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>();</span><br><span class="line">        g[u].<span class="built_in">emplace_back</span>(v); g[v].<span class="built_in">emplace_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="built_in">dp</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【CCPC-2022-桂林】Group-Homework"><a href="#【CCPC-2022-桂林】Group-Homework" class="headerlink" title="【CCPC 2022 桂林】Group Homework"></a>【CCPC 2022 桂林】Group Homework</h3><p>求两条链的最大权值和，相交部分不被计算。</p><p>不难发现对于两条链，若重合部分不止一个点，那么可以去掉重合部分，加上两个端点，得到结果更大的两条链。因此答案转变为重合部分有一个点（它不被计算）时由它延伸出四条链的最大权值和及任意两条不相交链的最大权值和，在上述代码基础上稍作修改即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200005</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">1</span> &lt;&lt; <span class="number">16</span>], *fs = buf, *ft = buf;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fs == ft) &#123;</span><br><span class="line">        ft = (fs = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, <span class="number">1</span> &lt;&lt; <span class="number">16</span>, stdin);</span><br><span class="line">        <span class="keyword">if</span>(fs == ft) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *fs++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>, f = <span class="number">0</span>; <span class="type">char</span> c = <span class="built_in">gc</span>();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || <span class="string">&#x27;9&#x27;</span> &lt; c) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">1</span>;</span><br><span class="line">        c = <span class="built_in">gc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c = <span class="built_in">gc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f ? -num : num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">data</span> &#123;</span><br><span class="line">    std::multiset&lt;<span class="type">int</span>&gt; ms;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; ms.<span class="built_in">insert</span>(x); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; ms.<span class="built_in">erase</span>(ms.<span class="built_in">find</span>(x)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ms.<span class="built_in">size</span>() &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = ms.<span class="built_in">end</span>(); --it; <span class="keyword">return</span> *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">nax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ms.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = ms.<span class="built_in">end</span>(); --it; --it; <span class="keyword">return</span> *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">four</span><span class="params">(<span class="type">int</span> ax)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ms.<span class="built_in">size</span>() &lt; <span class="number">4</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>; <span class="keyword">auto</span> it = ms.<span class="built_in">end</span>();</span><br><span class="line">        <span class="type">int</span> cx = <span class="number">4</span>; <span class="keyword">while</span>(cx--) &#123; --it; res += (*it) - ax; &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; f[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N]; std::vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    f[x].<span class="built_in">add</span>(a[x]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, ed = g[x].<span class="built_in">size</span>(); i &lt; ed; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> v = g[x][i]; <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v, x);</span><br><span class="line">        f[x].<span class="built_in">add</span>(f[v].<span class="built_in">max</span>() + a[x]);</span><br><span class="line">        ans[x].<span class="built_in">add</span>(ans[v].<span class="built_in">max</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    ans[x].<span class="built_in">add</span>(f[x].<span class="built_in">nax</span>() ? f[x].<span class="built_in">max</span>() + f[x].<span class="built_in">nax</span>() - a[x] : f[x].<span class="built_in">max</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    res = std::<span class="built_in">max</span>(res, f[x].<span class="built_in">four</span>(a[x]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, ed = g[x].<span class="built_in">size</span>(); i &lt; ed; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> v = g[x][i]; <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Remove v from x */</span></span><br><span class="line">        ans[x].<span class="built_in">del</span>(f[x].<span class="built_in">nax</span>() ? f[x].<span class="built_in">max</span>() + f[x].<span class="built_in">nax</span>() - a[x] : f[x].<span class="built_in">max</span>());</span><br><span class="line">        f[x].<span class="built_in">del</span>(f[v].<span class="built_in">max</span>() + a[x]);</span><br><span class="line">        ans[x].<span class="built_in">del</span>(ans[v].<span class="built_in">max</span>());</span><br><span class="line">        ans[x].<span class="built_in">add</span>(f[x].<span class="built_in">nax</span>() ? f[x].<span class="built_in">max</span>() + f[x].<span class="built_in">nax</span>() - a[x] : f[x].<span class="built_in">max</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Calculate answer between x and v */</span></span><br><span class="line">        res = std::<span class="built_in">max</span>(res, ans[x].<span class="built_in">max</span>() + ans[v].<span class="built_in">max</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Add x to v */</span></span><br><span class="line">        ans[v].<span class="built_in">del</span>(f[v].<span class="built_in">nax</span>() ? f[v].<span class="built_in">max</span>() + f[v].<span class="built_in">nax</span>() - a[v] : f[v].<span class="built_in">max</span>());</span><br><span class="line">        f[v].<span class="built_in">add</span>(f[x].<span class="built_in">max</span>() + a[v]);</span><br><span class="line">        ans[v].<span class="built_in">add</span>(ans[x].<span class="built_in">max</span>());</span><br><span class="line">        ans[v].<span class="built_in">add</span>(f[v].<span class="built_in">nax</span>() ? f[v].<span class="built_in">max</span>() + f[v].<span class="built_in">nax</span>() - a[v] : f[v].<span class="built_in">max</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dp</span>(v, x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Remove x from v */</span></span><br><span class="line">        ans[v].<span class="built_in">del</span>(f[v].<span class="built_in">nax</span>() ? f[v].<span class="built_in">max</span>() + f[v].<span class="built_in">nax</span>() - a[v] : f[v].<span class="built_in">max</span>());</span><br><span class="line">        ans[v].<span class="built_in">del</span>(ans[x].<span class="built_in">max</span>());</span><br><span class="line">        f[v].<span class="built_in">del</span>(f[x].<span class="built_in">max</span>() + a[v]);</span><br><span class="line">        ans[v].<span class="built_in">add</span>(f[v].<span class="built_in">nax</span>() ? f[v].<span class="built_in">max</span>() + f[v].<span class="built_in">nax</span>() - a[v] : f[v].<span class="built_in">max</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Add v to x */</span></span><br><span class="line">        ans[x].<span class="built_in">del</span>(f[x].<span class="built_in">nax</span>() ? f[x].<span class="built_in">max</span>() + f[x].<span class="built_in">nax</span>() - a[x] : f[x].<span class="built_in">max</span>());</span><br><span class="line">        ans[x].<span class="built_in">add</span>(ans[v].<span class="built_in">max</span>());</span><br><span class="line">        f[x].<span class="built_in">add</span>(f[v].<span class="built_in">max</span>() + a[x]);</span><br><span class="line">        ans[x].<span class="built_in">add</span>(f[x].<span class="built_in">nax</span>() ? f[x].<span class="built_in">max</span>() + f[x].<span class="built_in">nax</span>() - a[x] : f[x].<span class="built_in">max</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>();</span><br><span class="line">        g[u].<span class="built_in">emplace_back</span>(v); g[v].<span class="built_in">emplace_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="built_in">dp</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><code>multiset.erase(x)</code> 会删去所有值为 $x$ 的元素，而 $multiset.erase(multiset.find(x))$ 才能够仅删除一个值为 $x$ 的元素。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天训练的时候遇到一道树形 DP 题，做法似乎很经典，来记录一下。&lt;/p&gt;
&lt;p&gt;参考 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/580249398&quot;&gt;严格鸽的知乎&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;【CF-633F】The-Chocola</summary>
      
    
    
    
    <category term="竞赛题解" scheme="https://whz0325.github.io/categories/%E7%AB%9E%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>【Codeforces 1681E】Non-Intersecting Subpermutations</title>
    <link href="https://whz0325.github.io/cf-1681e/"/>
    <id>https://whz0325.github.io/cf-1681e/</id>
    <published>2023-09-05T02:05:00.000Z</published>
    <updated>2023-09-05T02:21:21.298Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定 $n, k$，求由 $[1,k]$ 组成所有长度为 $n$ 的序列的贡献之和，一个序列的贡献为能够在其中找到的最多互不交叉的段数使得每一段长度为 $k$ 且恰好包含 $[1,k]$ 中每个数，输出答案对 $998244353$ 取模的值。</p><p>$2\le n,k\le 4000$。</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>设 $f[i][j]$ 表示前 $i$ 个数中末尾连续互不相同的数有 $j$ 个时的方案数，考虑转移：</p><ol><li>由前 $i - 1$ 个数补充一个不在其已有互不相同的数集中的数得到，这样的数由 $k - (j - 1)$ 个，即 $(k-(j - 1))\times f[i - 1][j - 1]$，对于 $j &#x3D; 0$ 的情况则从 $f[i - 1][k - 1]$ 转移。</li><li>由前 $i - 1$ 个数补充一个在其已有互不相同的数集中的数得到，枚举新数在原数集中的位置，则应由所有 $t\ge j$ 的 $f[i-1][t]$ 转移而来。例如，对于 $f[i-1][j-1]$ 而言，添加一个在 $j - 1$ 个数中出现过的数可以转移到 $f[i][1\dots j-1]$（去掉一段数再加上一个数）。</li></ol><p>累计答案时考虑每一个刚刚完成的段对答案的贡献，即 $\sum k^{n-i}f[i][0]$。</p><p>时间复杂度为 $O(nk)$。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 4005</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">inc</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> y)</span> </span>&#123; x += y; <span class="keyword">if</span>(x &gt;= mod) x -= mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> (ll)x * y % mod; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) ans = <span class="built_in">mul</span>(ans, n);</span><br><span class="line">        n = <span class="built_in">mul</span>(n, n); k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>; f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"></span><br><span class="line">        f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; k; ++j) &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">mul</span>(f[i - <span class="number">1</span>][j - <span class="number">1</span>], k - (j - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = k - <span class="number">1</span>; j &gt;= <span class="number">1</span>; --j) &#123;</span><br><span class="line">            <span class="built_in">inc</span>(cur, f[i - <span class="number">1</span>][j]);</span><br><span class="line">            <span class="built_in">inc</span>(f[i][j], cur);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">inc</span>(ans, <span class="built_in">mul</span>(f[i][<span class="number">0</span>], <span class="built_in">qpow</span>(k, n - i)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定 $n, k$，求由 $[1,k]$ 组成所有长度为 $n$ 的序列的贡献之和，一个序列的贡献为能够在其中找到的最多互不</summary>
      
    
    
    
    <category term="竞赛题解" scheme="https://whz0325.github.io/categories/%E7%AB%9E%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="动态规划" scheme="https://whz0325.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="计数" scheme="https://whz0325.github.io/tags/%E8%AE%A1%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>ICPC 2022 南京</title>
    <link href="https://whz0325.github.io/icpc-2022-nanjing/"/>
    <id>https://whz0325.github.io/icpc-2022-nanjing/</id>
    <published>2023-08-28T05:47:00.000Z</published>
    <updated>2023-09-05T01:20:57.818Z</updated>
    
    <content type="html"><![CDATA[<center>目前已完成 <font size=16><font color="red">2</font><font color="green">/8</font></font> 题</center><h3 id="A-Stop-Yesterday-Please-No-More"><a href="#A-Stop-Yesterday-Please-No-More" class="headerlink" title="A. Stop, Yesterday Please No More"></a>A. Stop, Yesterday Please No More</h3><h3 id="B-Ropeway"><a href="#B-Ropeway" class="headerlink" title="B. Ropeway"></a>B. Ropeway</h3><p>一个重要的性质是任意长度为 $k$ 的区间中一定有一个点被选。</p><p>考虑枚举修改位置前后 $k$ 个位置，如果可以计算一定选择该位置时的最小费用，这 $2k$ 个位置取最小值就是答案。</p><p>一定选择某一位置 $i$ 的最小费用可以由从前到后选择到该位置的最小费用 $f_i$ 与从后到前选择到该位置的最小费用 $g_i$ 之和减去选择该位置的费用得到，对于一次询问操作产生的单点修改，我们只需要枚举对修改位置前后 $k$ 个点处答案的影响。</p><p>使用单调队列优化动态规划实现，时间复杂度为 $O(n+kq)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, a[N]; <span class="type">char</span> s[N]; ll f[N], g[N], tf[N], tg[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    a[<span class="number">0</span>] = a[n + <span class="number">1</span>] = <span class="number">0</span>; std::deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(f)); f[<span class="number">0</span>] = <span class="number">0</span>; dq.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(dq.<span class="built_in">size</span>() &amp;&amp; dq.<span class="built_in">front</span>() &lt; std::<span class="built_in">max</span>(<span class="number">0</span>, i - k)) dq.<span class="built_in">pop_front</span>();</span><br><span class="line">        f[i] = f[dq.<span class="built_in">front</span>()] + a[i];</span><br><span class="line">        <span class="keyword">while</span>(dq.<span class="built_in">size</span>() &amp;&amp; f[dq.<span class="built_in">back</span>()] &gt;= f[i]) dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;1&#x27;</span>) <span class="keyword">while</span>(dq.<span class="built_in">size</span>()) dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        dq.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; ++i) tf[i] = f[i];</span><br><span class="line"></span><br><span class="line">    dq.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(g)); g[n + <span class="number">1</span>] = <span class="number">0</span>; dq.<span class="built_in">push_back</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(dq.<span class="built_in">size</span>() &amp;&amp; dq.<span class="built_in">front</span>() &gt; std::<span class="built_in">min</span>(n + <span class="number">1</span>, i + k)) dq.<span class="built_in">pop_front</span>();</span><br><span class="line">        g[i] = g[dq.<span class="built_in">front</span>()] + a[i];</span><br><span class="line">        <span class="keyword">while</span>(dq.<span class="built_in">size</span>() &amp;&amp; g[dq.<span class="built_in">back</span>()] &gt;= g[i]) dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;1&#x27;</span>) <span class="keyword">while</span>(dq.<span class="built_in">size</span>()) dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        dq.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; ++i) tg[i] = g[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line"></span><br><span class="line">    tf[p] += v - a[p];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = std::<span class="built_in">max</span>(<span class="number">0</span>, p - k); i &lt;= p; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(dq.<span class="built_in">size</span>() &amp;&amp; tf[dq.<span class="built_in">back</span>()] &gt;= tf[i]) dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;1&#x27;</span>) <span class="keyword">while</span>(dq.<span class="built_in">size</span>()) dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        dq.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = std::<span class="built_in">min</span>(n + <span class="number">1</span>, p + <span class="number">1</span>); i &lt;= std::<span class="built_in">min</span>(n + <span class="number">1</span>, p + k); ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(dq.<span class="built_in">size</span>() &amp;&amp; dq.<span class="built_in">front</span>() &lt; std::<span class="built_in">max</span>(<span class="number">0</span>, i - k)) dq.<span class="built_in">pop_front</span>();</span><br><span class="line">        tf[i] = tf[dq.<span class="built_in">front</span>()] + a[i];</span><br><span class="line">        <span class="keyword">while</span>(dq.<span class="built_in">size</span>() &amp;&amp; tf[dq.<span class="built_in">back</span>()] &gt;= tf[i]) dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;1&#x27;</span>) <span class="keyword">while</span>(dq.<span class="built_in">size</span>()) dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        dq.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dq.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    tg[p] += v - a[p];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = std::<span class="built_in">min</span>(n + <span class="number">1</span>, p + k); i &gt;= p; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(dq.<span class="built_in">size</span>() &amp;&amp; tg[dq.<span class="built_in">back</span>()] &gt;= tg[i]) dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;1&#x27;</span>) <span class="keyword">while</span>(dq.<span class="built_in">size</span>()) dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        dq.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = std::<span class="built_in">max</span>(<span class="number">0</span>, p - <span class="number">1</span>); i &gt;= std::<span class="built_in">max</span>(<span class="number">0</span>, p - k); --i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(dq.<span class="built_in">size</span>() &amp;&amp; dq.<span class="built_in">front</span>() &gt; std::<span class="built_in">min</span>(n + <span class="number">1</span>, i + k)) dq.<span class="built_in">pop_front</span>();</span><br><span class="line">        tg[i] = tg[dq.<span class="built_in">front</span>()] + a[i];</span><br><span class="line">        <span class="keyword">while</span>(dq.<span class="built_in">size</span>() &amp;&amp; tg[dq.<span class="built_in">back</span>()] &gt;= tg[i]) dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;1&#x27;</span>) <span class="keyword">while</span>(dq.<span class="built_in">size</span>()) dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        dq.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll ans = LLONG_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = std::<span class="built_in">max</span>(<span class="number">0</span>, p - k); i &lt;= std::<span class="built_in">min</span>(n + <span class="number">1</span>, p + k); ++i) &#123;</span><br><span class="line">        ans = std::<span class="built_in">min</span>(ans, tf[i] + tg[i] - ((i ^ p) ? a[i] : v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = p; i &lt;= std::<span class="built_in">min</span>(n + <span class="number">1</span>, p + k); ++i) tf[i] = f[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = p; i &gt;= std::<span class="built_in">max</span>(<span class="number">0</span>, p - k); --i) tg[i] = g[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>); <span class="built_in">solve</span>();</span><br><span class="line">        <span class="type">int</span> q; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">        <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">            <span class="type">int</span> p, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;p, &amp;v);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query</span>(p, v));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-Fabulous-Fungus-Frenzy"><a href="#C-Fabulous-Fungus-Frenzy" class="headerlink" title="*C. Fabulous Fungus Frenzy"></a>*C. Fabulous Fungus Frenzy</h3><p>TBD……</p><h3 id="D-Chat-Program"><a href="#D-Chat-Program" class="headerlink" title="D. Chat Program"></a>D. Chat Program</h3><h3 id="E-Color-the-Tree"><a href="#E-Color-the-Tree" class="headerlink" title="E. Color the Tree"></a>E. Color the Tree</h3><h3 id="F-Triangles"><a href="#F-Triangles" class="headerlink" title="*F. Triangles"></a>*F. Triangles</h3><p>构造。</p><h3 id="G-Inscryption"><a href="#G-Inscryption" class="headerlink" title="G. Inscryption"></a>G. Inscryption</h3><h3 id="H-Factories-Once-More"><a href="#H-Factories-Once-More" class="headerlink" title="*H. Factories Once More"></a>*H. Factories Once More</h3><p>平衡树。</p><h3 id="I-Perfect-Palindrome"><a href="#I-Perfect-Palindrome" class="headerlink" title="I. Perfect Palindrome"></a>I. Perfect Palindrome</h3><h3 id="J-Perfect-Matching"><a href="#J-Perfect-Matching" class="headerlink" title="J. Perfect Matching"></a>J. Perfect Matching</h3><h3 id="K-NaN-in-a-Heap"><a href="#K-NaN-in-a-Heap" class="headerlink" title="*K. NaN in a Heap"></a>*K. NaN in a Heap</h3><p>TBD……</p><h3 id="L-Proposition-Composition"><a href="#L-Proposition-Composition" class="headerlink" title="*L. Proposition Composition"></a>*L. Proposition Composition</h3><p>TBD……</p><h3 id="M-Drain-the-Water-Tank"><a href="#M-Drain-the-Water-Tank" class="headerlink" title="M. Drain the Water Tank"></a>M. Drain the Water Tank</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;目前已完成 &lt;font size=16&gt;&lt;font color=&quot;red&quot;&gt;2&lt;/font&gt;&lt;font color=&quot;green&quot;&gt;/8&lt;/font&gt;&lt;/font&gt; 题&lt;/center&gt;

&lt;h3 id=&quot;A-Stop-Yesterday-Please-No-Mo</summary>
      
    
    
    
    <category term="竞赛题解" scheme="https://whz0325.github.io/categories/%E7%AB%9E%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>后缀自动机相关</title>
    <link href="https://whz0325.github.io/sam/"/>
    <id>https://whz0325.github.io/sam/</id>
    <published>2023-07-16T06:50:00.000Z</published>
    <updated>2023-08-14T06:51:51.775Z</updated>
    
    <content type="html"><![CDATA[<h3 id="P3804-后缀自动机"><a href="#P3804-后缀自动机" class="headerlink" title="P3804 后缀自动机"></a>P3804 后缀自动机</h3><p>基数排序得到 endpos 大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000005</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> ll;</span><br><span class="line"><span class="type">char</span> s[N]; <span class="type">int</span> len[N &lt;&lt; <span class="number">1</span>], fa[N &lt;&lt; <span class="number">1</span>], ch[N &lt;&lt; <span class="number">1</span>][<span class="number">26</span>], tot, lst;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = lst, np = ++tot; len[np] = len[p] + <span class="number">1</span>; lst = np;</span><br><span class="line">    <span class="keyword">while</span>(~p &amp;&amp; !ch[p][c]) ch[p][c] = np, p = fa[p];</span><br><span class="line">    <span class="keyword">if</span>(~p) &#123;</span><br><span class="line">        <span class="type">int</span> q = ch[p][c];</span><br><span class="line">        <span class="keyword">if</span>(len[p] + <span class="number">1</span> == len[q]) fa[np] = q;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> nq = ++tot; <span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="built_in">sizeof</span>(ch[q]));</span><br><span class="line">            len[nq] = len[p] + <span class="number">1</span>; fa[nq] = fa[q]; fa[q] = fa[np] = nq;</span><br><span class="line">            <span class="keyword">while</span>(~p &amp;&amp; ch[p][c] == q) ch[p][c] = nq, p = fa[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cx[N &lt;&lt; <span class="number">1</span>], c[N], res[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s); <span class="type">int</span> n = <span class="built_in">strlen</span>(s); fa[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; <span class="built_in">extend</span>(s[i] - <span class="string">&#x27;a&#x27;</span>); ++cx[lst]; &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= tot; ++i) ++c[len[i]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= tot; ++i) res[--c[len[i]]] = i;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = tot; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        cx[fa[res[i]]] += cx[res[i]];</span><br><span class="line">        <span class="keyword">if</span>(cx[res[i]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            ans = std::<span class="built_in">max</span>(ans, (ll)cx[res[i]] * len[res[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DISUBSTR"><a href="#DISUBSTR" class="headerlink" title="DISUBSTR"></a>DISUBSTR</h3><p>本质不同子串数，len[i] - len[fa[i]] 求和即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1005</span></span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> fa[N &lt;&lt; <span class="number">1</span>], len[N &lt;&lt; <span class="number">1</span>], tot, lst; std::map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; ch[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = lst, np = ++tot; len[np] = len[p] + <span class="number">1</span>; lst = np;</span><br><span class="line">    <span class="keyword">while</span>(~p &amp;&amp; ch[p].<span class="built_in">find</span>(c) == ch[p].<span class="built_in">end</span>()) ch[p][c] = np, p = fa[p];</span><br><span class="line">    <span class="keyword">if</span>(~p) &#123;</span><br><span class="line">        <span class="type">int</span> q = ch[p][c];</span><br><span class="line">        <span class="keyword">if</span>(len[p] + <span class="number">1</span> == len[q]) fa[np] = q;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> nq = ++tot; ch[nq] = ch[q];</span><br><span class="line">            len[nq] = len[p] + <span class="number">1</span>; fa[nq] = fa[q]; fa[q] = fa[np] = nq;</span><br><span class="line">            <span class="keyword">while</span>(~p &amp;&amp; ch[p][c] == q) ch[p][c] = nq, p = fa[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s); <span class="type">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">        tot = lst = <span class="number">0</span>; fa[<span class="number">0</span>] = <span class="number">-1</span>; len[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">extend</span>(s[i]);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) &#123;</span><br><span class="line">            ans += len[i] - len[fa[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= tot; ++i) &#123;</span><br><span class="line">            fa[i] = <span class="number">0</span>; len[i] = <span class="number">0</span>; ch[i].<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LCS"><a href="#LCS" class="headerlink" title="LCS"></a>LCS</h3><p>两个字符串的最长公共子串，对一个串建后缀自动机，另一个串在上面跑，有边就走，同时累加匹配的长度，没有边就沿 link 往上跳，这时匹配的长度更新为 <code>res = min(len[cur], res)</code>，由于匹配串每个字符只会沿边走一次将匹配长度加一，沿 link 上跳一次至少将匹配长度减一，和双指针差不多的证法得到时间复杂度是线性的。</p><p>注意跳到 -1 时要将匹配长度手动置 0，且将指针指向后缀自动机的根节点处。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 250005</span></span><br><span class="line"><span class="type">int</span> fa[N &lt;&lt; <span class="number">1</span>], ch[N &lt;&lt; <span class="number">1</span>][<span class="number">26</span>], len[N &lt;&lt; <span class="number">1</span>], tot, lst;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = lst, np = ++tot; len[np] = len[p] + <span class="number">1</span>; lst = np;</span><br><span class="line">    <span class="keyword">while</span>(~p &amp;&amp; !ch[p][c]) ch[p][c] = np, p = fa[p];</span><br><span class="line">    <span class="keyword">if</span>(~p) &#123;</span><br><span class="line">        <span class="type">int</span> q = ch[p][c];</span><br><span class="line">        <span class="keyword">if</span>(len[p] + <span class="number">1</span> == len[q]) fa[np] = q;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> nq = ++tot; <span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="built_in">sizeof</span>(ch[q]));</span><br><span class="line">            len[nq] = len[p] + <span class="number">1</span>; fa[nq] = fa[q]; fa[q] = fa[np] = nq;</span><br><span class="line">            <span class="keyword">while</span>(~p &amp;&amp; ch[p][c] == q) ch[p][c] = nq, p = fa[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s); <span class="type">int</span> n = <span class="built_in">strlen</span>(s); fa[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">extend</span>(s[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s); n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, res = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(~cur &amp;&amp; !ch[cur][s[i] - <span class="string">&#x27;a&#x27;</span>]) cur = fa[cur];</span><br><span class="line">        <span class="keyword">if</span>(~cur) &#123;</span><br><span class="line">            res = std::<span class="built_in">min</span>(len[cur], res);</span><br><span class="line">            ++res; cur = ch[cur][s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            ans = std::<span class="built_in">max</span>(ans, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> res = cur = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LCS2"><a href="#LCS2" class="headerlink" title="LCS2"></a>LCS2</h3><p>多个字符串的最长公共子串，先对第一个字符串建后缀自动机，再将其它串放在上面跑。对于后缀自动机上的每一个节点，记录每次经过时匹配的长度的最大值，对各个字符串的最大值取最小值即得公共部分，结果取所有节点的最大值。对于一个节点，其后缀链接树上子树中所有节点的匹配它自然也能够匹配（它是它们的后缀），所以需要一次基数排序来将子树的结果累计进来。需要注意的是，累计的过程中应避免超过它的 len 值导致出错，即 <code>res[fa[i]] = std::max(std::min(len[fa[i]], res[fa[i]]), res[i])</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="type">int</span> fa[N &lt;&lt; <span class="number">1</span>], ch[N &lt;&lt; <span class="number">1</span>][<span class="number">26</span>], len[N &lt;&lt; <span class="number">1</span>], tot, lst;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = lst, np = ++tot; len[np] = len[p] + <span class="number">1</span>; lst = np;</span><br><span class="line">    <span class="keyword">while</span>(~p &amp;&amp; !ch[p][c]) ch[p][c] = np, p = fa[p];</span><br><span class="line">    <span class="keyword">if</span>(~p) &#123;</span><br><span class="line">        <span class="type">int</span> q = ch[p][c];</span><br><span class="line">        <span class="keyword">if</span>(len[p] + <span class="number">1</span> == len[q]) fa[np] = q;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> nq = ++tot; <span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="built_in">sizeof</span>(ch[q]));</span><br><span class="line">            len[nq] = len[p] + <span class="number">1</span>; fa[nq] = fa[q]; fa[q] = fa[np] = nq;</span><br><span class="line">            <span class="keyword">while</span>(~p &amp;&amp; ch[p][c] == q) ch[p][c] = nq, p = fa[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[N]; <span class="type">int</span> ans[N &lt;&lt; <span class="number">1</span>], res[N &lt;&lt; <span class="number">1</span>], c[N], order[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s); <span class="type">int</span> ln = <span class="built_in">strlen</span>(s); fa[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ln; ++i) <span class="built_in">extend</span>(s[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= tot; ++i) ++c[len[i]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ln; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= tot; ++i) order[--c[len[i]]] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= tot; ++i) ans[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">strlen</span>(s); <span class="type">int</span> cur = <span class="number">0</span>, p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= tot; ++i) res[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span>(~p &amp;&amp; !ch[p][s[i] - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                p = fa[p];</span><br><span class="line">                <span class="keyword">if</span>(~p) &#123;</span><br><span class="line">                    cur = std::<span class="built_in">min</span>(cur, len[p]);</span><br><span class="line">                    res[p] = std::<span class="built_in">max</span>(res[p], cur);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(~p) &#123;</span><br><span class="line">                p = ch[p][s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                res[p] = std::<span class="built_in">max</span>(res[p], ++cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> cur = p = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = tot; i &gt;= <span class="number">1</span>; --i) res[fa[i]] = std::<span class="built_in">max</span>(std::<span class="built_in">min</span>(len[fa[i]], res[fa[i]]), res[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) ans[i] = (~ans[i]) ? std::<span class="built_in">min</span>(ans[i], res[i]) : res[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> out = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) out = std::<span class="built_in">max</span>(out, ans[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, out);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NSUBSTR"><a href="#NSUBSTR" class="headerlink" title="NSUBSTR"></a>NSUBSTR</h3><p>求一个字符串长度分别为 $1\dots n$ 的各个子串的最大出现次数。注意到较短长度子串最大出现次数一定不会小于较长长度子串最大出现次数，因为较长子串的一部分就是一个较短子串。还是用基数排序的方法算出每个节点的 endpos 大小统计即可，不用写线段树，时间复杂度是线性的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 250005</span></span><br><span class="line"><span class="type">int</span> fa[N &lt;&lt; <span class="number">1</span>], ch[N &lt;&lt; <span class="number">1</span>][<span class="number">26</span>], len[N &lt;&lt; <span class="number">1</span>], tot, lst;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = lst, np = ++tot; len[np] = len[p] + <span class="number">1</span>; lst = np;</span><br><span class="line">    <span class="keyword">while</span>(~p &amp;&amp; !ch[p][c]) ch[p][c] = np, p = fa[p];</span><br><span class="line">    <span class="keyword">if</span>(~p) &#123;</span><br><span class="line">        <span class="type">int</span> q = ch[p][c];</span><br><span class="line">        <span class="keyword">if</span>(len[p] + <span class="number">1</span> == len[q]) fa[np] = q;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> nq = ++tot; <span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="built_in">sizeof</span>(ch[q]));</span><br><span class="line">            len[nq] = len[p] + <span class="number">1</span>; fa[nq] = fa[q]; fa[q] = fa[np] = nq;</span><br><span class="line">            <span class="keyword">while</span>(~p &amp;&amp; ch[p][c] == q) ch[p][c] = nq, p = fa[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[N]; <span class="type">int</span> ans[N], cx[N &lt;&lt; <span class="number">1</span>], c[N], order[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s); <span class="type">int</span> n = <span class="built_in">strlen</span>(s); fa[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; <span class="built_in">extend</span>(s[i] - <span class="string">&#x27;a&#x27;</span>); ++cx[lst]; &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= tot; ++i) ++c[len[i]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= tot; ++i) order[--c[len[i]]] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = tot; i &gt;= <span class="number">1</span>; --i) cx[fa[order[i]]] += cx[order[i]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= tot; ++i) ans[len[i]] = std::<span class="built_in">max</span>(ans[len[i]], cx[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) ans[i] = std::<span class="built_in">max</span>(ans[i], ans[i + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;P3804-后缀自动机&quot;&gt;&lt;a href=&quot;#P3804-后缀自动机&quot; class=&quot;headerlink&quot; title=&quot;P3804 后缀自动机&quot;&gt;&lt;/a&gt;P3804 后缀自动机&lt;/h3&gt;&lt;p&gt;基数排序得到 endpos 大小。&lt;/p&gt;
&lt;figure clas</summary>
      
    
    
    
    <category term="算法竞赛" scheme="https://whz0325.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="后缀自动机" scheme="https://whz0325.github.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>数位DP</title>
    <link href="https://whz0325.github.io/digital-dp/"/>
    <id>https://whz0325.github.io/digital-dp/</id>
    <published>2023-04-09T01:25:00.000Z</published>
    <updated>2023-04-09T13:52:34.384Z</updated>
    
    <content type="html"><![CDATA[<p>数位 DP 唯一需要考虑的就是如何求不限定范围，只限定位数的情况下的方案数。</p><h5 id="【Ural-1057】Amount-of-Degrees"><a href="#【Ural-1057】Amount-of-Degrees" class="headerlink" title="【Ural 1057】Amount of Degrees"></a>【Ural 1057】Amount of Degrees</h5><p>求 $[x,y]$ 范围内恰好可以拆分为 $k$ 个 $b$ 的整数次幂（不重复）的数的个数。</p><p>$1\le x,y\le 2^{31}-1$，$1\le k\le 20$，$2\le b\le 10$。</p><p>拆分成前缀和的形式，$f(x)$ 表示 $[0,x]$ 范围内的解，则答案为 $f(y)-f(x-1)$。</p><p>问题等价于将数字转化为 $b$ 进制后 $1$ 的位数为 $k$ 的方案数。</p><p>数位 DP 的思想是从高位到低位沿着 $x$ 的上界进行枚举，每次累加这一位取不到上界时的方案数，本题中，这个方案数就是组合数。</p><p>时间复杂度为 $O(log^2n)$，瓶颈在于预处理组合数。</p><p>细节有：如果 $x$ 满足条件需要在最后累加进去，且一旦有一位上的数大于 $1$ 则代表后面若干位可以任意填 $1$，这时需要跳出循环，选择了 $k$ 个 $1$ 后也应跳出循环，此时后面的若干位应全部填 $0$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> ll;</span><br><span class="line"><span class="type">int</span> k, b; ll c[<span class="number">35</span>][<span class="number">35</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">prelude</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    c[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">32</span>; ++i) &#123;</span><br><span class="line">        c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">            c[i][j] = c[i - <span class="number">1</span>][j - <span class="number">1</span>] + c[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> bits[<span class="number">35</span>], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        bits[cnt++] = num % b;</span><br><span class="line">        num /= b;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>; <span class="type">int</span> curk = k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = cnt; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(bits[i - <span class="number">1</span>] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            ans += c[i][curk];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(bits[i - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            ans += c[i - <span class="number">1</span>][curk];</span><br><span class="line">            --curk; <span class="keyword">if</span>(curk &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(bits[i] &gt; <span class="number">1</span>) &#123; cnt1 = <span class="number">-1</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> cnt1 += bits[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt1 == k ? ans + <span class="number">1</span> : ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">prelude</span>();</span><br><span class="line">    <span class="type">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;x, &amp;y, &amp;k, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">solve</span>(y) - <span class="built_in">solve</span>(x - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="【USACO-Nov06】Round-Numbers"><a href="#【USACO-Nov06】Round-Numbers" class="headerlink" title="【USACO Nov06】Round Numbers"></a>【USACO Nov06】Round Numbers</h5><h5 id="【ZJOI-2010】数字计数"><a href="#【ZJOI-2010】数字计数" class="headerlink" title="【ZJOI 2010】数字计数"></a>【ZJOI 2010】数字计数</h5><p>求对于 $[a,b]$ 的所有整数，$[0,9]$ 各出现多少次。</p><p>$1\le a\le b\le 10^{12}$。</p><p>问题转化为求 $[0,x]$ 的所有整数中 $[0,9]$ 的出现次数。</p><p>从高位开始枚举每一位，用数位 DP 解决的前提是可以在较短的时间内给出当前位不取上界时剩下位任取的结果，这里就是计算 $[0\dots 0,9\dots 9]$ 中 $[0,9]$ 的出现次数，它们是相同的，且可以方便地求出来。</p><p>注意下沿和上界。</p><p>当首位取 $0$ 时，可以先正常计算贡献，再枚举起始 $0$ 结束的位置除去多计算的 $0$ 的个数。</p><p>当继续沿着上界走时，对当前填入数字的贡献是后续填入不超过 $x$ 的所有低位的方案数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> ll;</span><br><span class="line">ll f[<span class="number">20</span>], p[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">prelude</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>; p[<span class="number">1</span>] = <span class="number">10</span>; f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">15</span>; ++i) &#123;</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * <span class="number">10</span>;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] * <span class="number">10</span> + p[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> bits[<span class="number">20</span>], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(ll num, ll ans[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i) ans[i] = <span class="number">0</span>;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        bits[cnt++] = num % <span class="number">10</span>;</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = cnt; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="type">int</span> &amp;cur = bits[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="number">0</span>) &#123;</span><br><span class="line">            ll contribute = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i - <span class="number">2</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                contribute = contribute * <span class="number">10</span> + bits[j];</span><br><span class="line">            &#125;</span><br><span class="line">            ans[<span class="number">0</span>] += contribute;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == cnt) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; ++j) ans[j] += f[i - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = i - <span class="number">2</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                    ans[<span class="number">0</span>] -= p[j];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cur - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                    ans[j] += p[i - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">9</span>; ++k) &#123;</span><br><span class="line">                        ans[k] += f[i - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ll contribute = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = i - <span class="number">2</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                    contribute = contribute * <span class="number">10</span> + bits[j];</span><br><span class="line">                &#125;</span><br><span class="line">                ans[cur] += contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= cur - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                    ans[j] += p[i - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">9</span>; ++k) &#123;</span><br><span class="line">                        ans[k] += f[i - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ll contribute = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = i - <span class="number">2</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                    contribute = contribute * <span class="number">10</span> + bits[j];</span><br><span class="line">                &#125;</span><br><span class="line">                ans[cur] += contribute;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">        ++ans[bits[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">prelude</span>();</span><br><span class="line">    ll a, b; <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    ll ansb[<span class="number">10</span>], ansaso[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">solve</span>(b, ansb); <span class="built_in">solve</span>(a - <span class="number">1</span>, ansaso);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld%c&quot;</span>, ansb[i] - ansaso[i], (i ^ <span class="number">9</span>) ? <span class="string">&#x27; &#x27;</span> : <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="【SCOI-2009】windy-数"><a href="#【SCOI-2009】windy-数" class="headerlink" title="【SCOI 2009】windy 数"></a>【SCOI 2009】windy 数</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数位 DP 唯一需要考虑的就是如何求不限定范围，只限定位数的情况下的方案数。&lt;/p&gt;
&lt;h5 id=&quot;【Ural-1057】Amount-of-Degrees&quot;&gt;&lt;a href=&quot;#【Ural-1057】Amount-of-Degrees&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://whz0325.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数位DP" scheme="https://whz0325.github.io/tags/%E6%95%B0%E4%BD%8DDP/"/>
    
  </entry>
  
  <entry>
    <title>C++ 面向对象笔记</title>
    <link href="https://whz0325.github.io/cpp-notes/"/>
    <id>https://whz0325.github.io/cpp-notes/</id>
    <published>2023-04-08T14:34:00.000Z</published>
    <updated>2023-06-29T09:21:31.544Z</updated>
    
    <content type="html"><![CDATA[<p>照学校课件打的，大概率没什么意思，有空再修改。</p><h3 id="C-程序结构"><a href="#C-程序结构" class="headerlink" title="C++ 程序结构"></a>C++ 程序结构</h3><h5 id="多文件编译"><a href="#多文件编译" class="headerlink" title="多文件编译"></a>多文件编译</h5><p>将源代码文件放一块儿就行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ a.cpp b.cpp c.cpp -o program</span><br></pre></td></tr></table></figure><h5 id="包含警戒"><a href="#包含警戒" class="headerlink" title="包含警戒"></a>包含警戒</h5><p>保证头文件不被重复定义。</p><p>解决方案一：<code>#pragma once</code></p><p>解决方案二：包含警戒。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// b.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// a.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;b.h&quot;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// b.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;b.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.h&quot;</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h5><ul><li>声明其它文件中的变量或函数。</li><li><code>extern &quot;C&quot;</code>：要求编译器按照 C 语言的方式编译函数（C++ 为实现函数重载会调整函数名，链接时可能出现问题）。</li></ul><h3 id="类型和变量"><a href="#类型和变量" class="headerlink" title="类型和变量"></a>类型和变量</h3><h5 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h5><p><code>wchar_t</code>：wide char type</p><h5 id="推导类型"><a href="#推导类型" class="headerlink" title="推导类型"></a>推导类型</h5><ul><li><code>auto</code>：定义时自动推导类型。</li><li><code>decltype(expression)</code>：给出表达式的返回类型。</li></ul><h5 id="typedef-函数"><a href="#typedef-函数" class="headerlink" title="typedef 函数"></a>typedef 函数</h5><p>用法：<code>typedef return_type (*new_name)(type...)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*func)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    func f1 = add;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">f1</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    f1 = sub;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">f1</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="enum-枚举类型"><a href="#enum-枚举类型" class="headerlink" title="enum 枚举类型"></a>enum 枚举类型</h5><p>默认从零开始，名称作用域为全局，不能前置声明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Week</span> &#123; Mon = <span class="number">1</span>, Tue, Wed, Thur, Fri, Sat, Sun &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Week first = Mon;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, first);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="enum-class-类型"><a href="#enum-class-类型" class="headerlink" title="enum class 类型"></a>enum class 类型</h5><ul><li><p>作用域不再是全局，需要 <code>::</code> 才能访问。</p></li><li><p>不能进行隐式类型转换。</p></li><li><p>可以前置声明，如果类型不是默认的 <code>int</code> 需要手动修改 <code>enum class Name: std::uint32_t;</code></p><p>  .</p></li></ul><p><code>enum class</code> 不能与 <code>int</code> 相互转化。注意命名空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Number</span>: <span class="type">char</span> &#123;</span><br><span class="line">    one = <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    two = <span class="string">&#x27;2&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Number num = Number::one;</span><br><span class="line">    <span class="built_in">putchar</span>((<span class="type">char</span>)num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="union-共用体"><a href="#union-共用体" class="headerlink" title="union 共用体"></a>union 共用体</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">u0</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> all: <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> low: <span class="number">4</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> high: <span class="number">4</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    u0 a; a.all = <span class="number">0xffff</span>;<span class="comment">// 16位，其实越界了</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, a.low, a.high, a.all);<span class="comment">// 15 15 255</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（这样取一些位会很方便，然而 <code>sizeof</code> 是不变的……）</p><h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><p>左值引用：貌似不能修改引用对象的指向。</p><p>右值引用：不算清晰，大概就是可以对临时对象进行操作？</p><h5 id="初始化（C-11）"><a href="#初始化（C-11）" class="headerlink" title="初始化（C++11）"></a>初始化（C++11）</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Type</span> &#123; <span class="type">int</span> a, b; &#125;;</span><br><span class="line"><span class="type">int</span> a&#123;<span class="number">10</span>&#125;; Type x&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><h5 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h5><ul><li>函数内表示静态变量。</li><li>函数外表示仅本文件有效。（不同文件重名会被认为是不同变量，由编译器处理）</li></ul><h3 id="指针、数组、引用、常量"><a href="#指针、数组、引用、常量" class="headerlink" title="指针、数组、引用、常量"></a>指针、数组、引用、常量</h3><h5 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h5><ul><li><code>NULL</code>：C++ 中就是整数 0（C 中是 <code>(void *)0</code>）。</li><li><code>nullptr</code>：C++11 中用来避免函数调用时产生二义性。</li></ul><p>见：<a href="https://blog.csdn.net/u010983763/article/details/53667468%E3%80%82">https://blog.csdn.net/u010983763/article/details/53667468。</a></p><p>deference（解引用&#x2F;逆向引用）：起这么厉害的名字，其实就是访问指针中的元素 <code>*p</code>。</p><ul><li>指针数组：<code>int *arr[5];</code>，一个数组，存放指针。</li><li>数组指针：<code>int (*p)[5] = &amp;array;</code>，一个指针，指向一个数组，通过 <code>(*p)[i]</code> 取值。</li></ul><h5 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h5><ul><li><code>#x</code> 将 <code>x</code> 表示为字符串。</li><li><code>##x</code> 将 <code>x</code> 与前面拼接。</li><li><code>#@x</code> 将 <code>x</code> 表示为字符。</li><li><code>__LINE__</code> 表示当前行号。</li><li><code>__FILE__</code> 表示当前文件的绝对路径。</li><li><code>__FUNCTION__</code> 表示当前所在的函数名。（调试时应该会很有用）</li></ul><h5 id="常量折叠"><a href="#常量折叠" class="headerlink" title="常量折叠"></a>常量折叠</h5><p><code>const</code> 定义的常量不会被重复定义（编译时被展开）。</p><h5 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h5><ul><li><code>const int *p = &amp;arr;</code>：指向的内容不能修改。</li><li><code>int* const p = &amp;arr;</code>：存放的指针不能修改。</li><li><code>const int* const p = &amp;arr;</code>：俩都不能改。</li></ul><p>未解之谜：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;arr;</span><br><span class="line"><span class="type">int</span> *pt = p;<span class="comment">// 可能是这样赋值后可以通过 *pt 修改内容所以就禁止了</span></span><br></pre></td></tr></table></figure><h5 id="const-引用"><a href="#const-引用" class="headerlink" title="const 引用"></a>const 引用</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;a = <span class="number">1</span>;<span class="comment">//正确</span></span><br></pre></td></tr></table></figure><p>函数参数类型是 <code>const int &amp;x</code> 表明可以传入变量或常量（常数也可），在函数体内不能修改而已。</p><h5 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h5><p>这两者是不同的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *s = <span class="string">&quot;string&quot;</span>;<span class="comment">// 是指针，因此可以修改指向</span></span><br><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;string&quot;</span>;<span class="comment">// 字符数组，可以修改内容，不能修改指向</span></span><br></pre></td></tr></table></figure><hr><p>md，C++ 好难……</p><hr><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h5 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h5><ul><li><code>__cdecl</code>：C 模式，参数从右到左压栈，主调用的函数控制，参数可变，可不指定参数名。</li><li><code>__stdcall</code>：参数从右到左压栈，被调用的函数控制，参数不可变。</li></ul><p>关于不指定参数名：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __cdecl <span class="title">print</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有函数体中用不到该形式参数时可以省略，这种情况下 C 和 C++ 有一些不同：</p><ul><li>C 语言在声明中可以省略，定义中不可以省略。</li><li>C++ 在声明中可以省略，定义中也可以省略。</li></ul><h5 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h5><p>缺省函数（调用时使用默认参数）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a = <span class="number">100</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">func</span>();<span class="comment">// 100</span></span><br></pre></td></tr></table></figure><ul><li>缺省函数不能用来区分同名函数。（缺省函数还可能存在其它歧义行为，均被禁止）</li><li>返回值类型不能用来区分同名函数。</li><li>引用&#x2F;指针类型（值类型不行）的 <code>const</code> 可用于区分同名函数：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> *p)</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;void func(int *p);&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *p)</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;void func(const int *p);&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="type">int</span> *p = &amp;cnt; <span class="built_in">func</span>(p); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：void func(int *p);</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> *p)</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;void func(int *p);&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *p)</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;void func(const int *p);&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> cnt = <span class="number">0</span>; <span class="built_in">func</span>(&amp;cnt); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：void func(const int *p);</span></span><br></pre></td></tr></table></figure><p>关于缺省函数：第一个带缺省值的参数后的每一个参数都要带缺省值（不然会有歧义）。</p><p>【上面第三条】关于 <code>const</code> 形参（参数必须是引用&#x2F;指针类型）：</p><ul><li>实际参数无 <code>const</code>，形式参数有无 <code>const</code> 都可调用，优先调用无 <code>const</code> 的函数。</li><li>实际参数有 <code>const</code>，只能调用形式参数有 <code>const</code> 的函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;a)</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;B&quot;</span>); &#125;<span class="comment">// 优先调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;A&quot;</span>); &#125;<span class="comment">// 注释掉上一行才会调用它</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>; <span class="built_in">func</span>(a); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="汇编逻辑"><a href="#汇编逻辑" class="headerlink" title="汇编逻辑"></a>汇编逻辑</h5><p>函数调用时数据存放在栈中，自顶向下从高位到低位，EBP 寄存器用于指向该函数的栈底，ESP 指针则指向栈顶，上一层函数 EBP 寄存器的值往往存放在当前函数的栈底。</p><h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><ul><li>值类型：都是 <code>const</code>，等价于 <code>const int f();</code></li><li>指针类型：指针 <code>const</code>，指针内容可变，等价于 <code>int* const f();</code>（不是 <code>const int* f();</code>）。</li><li>引用返回：<code>int &amp;f();</code>，如果要返回的是一个很大的类那就十分有用了。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">func</span><span class="params">()</span> </span>&#123; <span class="type">static</span> <span class="type">int</span> a = <span class="number">1024</span>; <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a); <span class="keyword">return</span> a; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> &amp;p = <span class="built_in">func</span>(); ++p; <span class="built_in">func</span>(); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：1024\n1025\n</span></span><br></pre></td></tr></table></figure><p>写成这样也是可以的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">func</span><span class="params">()</span> </span>&#123; <span class="type">static</span> <span class="type">int</span> a = <span class="number">1024</span>; <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a); <span class="keyword">return</span> a; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ++<span class="built_in">func</span>(); <span class="built_in">func</span>(); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：1024\n1025\n</span></span><br></pre></td></tr></table></figure><p>而改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> &amp;<span class="title">func</span><span class="params">()</span> </span>&#123; <span class="type">static</span> <span class="type">int</span> a = <span class="number">1024</span>; <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a); <span class="keyword">return</span> a; &#125;</span><br></pre></td></tr></table></figure><p>就会报错。</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h5 id="前置声明"><a href="#前置声明" class="headerlink" title="前置声明"></a>前置声明</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Type</span>;</span><br></pre></td></tr></table></figure><p>避免循环定义。</p><h5 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h5><p>类的静态变量只能在类外初始化，类中只能初始化 <code>static const int</code> 类型，去掉 <code>const</code> 或者不使用 <code>int</code> 类型均会报错。</p><ul><li><code>static const int</code>：允许类内初始化。</li><li><code>static constexpr</code>：必须类内初始化，不能只声明。</li><li><code>static</code> 关键字的其它类型：不允许类内初始化，仅可以在类内声明。</li></ul><p>据说是为了避免每个对象中都包含该静态成员变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Type</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">float</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> Type::a = <span class="number">1.0</span>;<span class="comment">// 怪诶，这种写法</span></span><br></pre></td></tr></table></figure><p>注：<code>constexpr</code> 将尽量在编译阶段运算。</p><h5 id="虚函数（virtual）"><a href="#虚函数（virtual）" class="headerlink" title="虚函数（virtual）"></a>虚函数（virtual）</h5><p>调用成员函数时，虚函数由<strong>指针指向的实际类型</strong>决定，普通函数由<strong>指针类型</strong>决定。</p><p>简单来说就是普通成员函数都放在代码区，取的时候按照指针类型去取；而虚函数在对象中保存虚函数表指针 vptr，通过 vptr 找到虚函数表 vtbl，再通过 vtbl 找到对应的虚函数，因此由对象的实际类型决定。（包含虚函数的类占用的空间会更大）</p><p>构造函数不能是虚函数，而析构函数最好设置为虚函数（析构所有的新成员）。</p><h5 id="（纯虚函数-virtual-void-func-0-用于抽象类，即抽象函数）"><a href="#（纯虚函数-virtual-void-func-0-用于抽象类，即抽象函数）" class="headerlink" title="（纯虚函数 virtual void func()=0; 用于抽象类，即抽象函数）"></a>（纯虚函数 <code>virtual void func()=0;</code> 用于抽象类，即抽象函数）</h5><h5 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h5><p><code>inline</code> 关键字，类内实现的函数都默认内联，类外实现的函数须加关键字实现内联且不能放在代码文件中（需要放在头文件中）。</p><p>【内联函数的一些问题】待填坑。</p><h5 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h5><p>没有指定访问权限的成员变量默认私有。</p><ul><li><code>public</code>：公开</li><li><code>protected</code>：子类可访问</li><li><code>private</code>：仅自己或友元可访问</li></ul><h5 id="常成员函数"><a href="#常成员函数" class="headerlink" title="常成员函数"></a>常成员函数</h5><p>写法：<code>void func() const &#123;&#125;</code></p><ul><li>普通函数的 <code>this</code> 相当于 <code>T* const this</code>：指针不可变，指向内容可变。</li><li>常成员函数的 <code>this</code> 相当于 <code>const T* const this</code>：指针不可变，指向内容不可变。</li></ul><p>如果对象是 <code>const</code> 类型的话，不修改对象的成员函数若不指定为 <code>const</code> 函数则无法调用。</p><h5 id="类函数-类变量"><a href="#类函数-类变量" class="headerlink" title="类函数&#x2F;类变量"></a>类函数&#x2F;类变量</h5><p>与 Java 中类似，加 <code>static</code> 关键字，最好使用 <code>ClassName::FuncName()</code> 而不是 <code>ObjectName.FuncName()</code> 调用。</p><ul><li>没有 <code>this</code> 指针。</li><li>没有 <code>const</code> 修饰。（没有对象谈何对对象不做改动）</li></ul><h3 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h3><h5 id="explicit-关键字"><a href="#explicit-关键字" class="headerlink" title="explicit 关键字"></a>explicit 关键字</h5><p>不允许奇怪的隐式类型转换，像 <code>Point p = 1</code> 这种。</p><h5 id="一些无聊的尝试"><a href="#一些无聊的尝试" class="headerlink" title="一些无聊的尝试"></a>一些无聊的尝试</h5><p>定义 <code>static</code> 类函数，使用引用 <code>&amp;</code> 或指针返回创建的对象（一种是 <code>new</code> 到堆里，一种是 <code>static</code> 到静态数据区【这种方法只能创建一次】）。</p><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>当类有带参数的构造函数时，不能不初始化（<code>ClassName object;</code>）。</p><p>构造函数其实是在对象创建之后才调用的。</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>类变量只有整型常量可以初始化，这个是前面提到过的 <code>static const int</code>。</p><p>在参数列表里初始化引用对象和常量，这样是没问题的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Type</span> &#123;</span><br><span class="line">    <span class="type">int</span> &amp;a; <span class="type">const</span> <span class="type">int</span> b;</span><br><span class="line">    <span class="built_in">Type</span>(): <span class="built_in">a</span>(val), <span class="built_in">b</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>初始化列表将严格按照定义的顺序初始化。</p><p>初始化列表先于构造函数的代码块执行。</p><h5 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h5><p>没有参数：<code>~ClassName() &#123;&#125;</code></p><p>析构函数则是在对象销毁之前调用的。</p><h3 id="拷贝和赋值"><a href="#拷贝和赋值" class="headerlink" title="拷贝和赋值"></a>拷贝和赋值</h3><p>返回值存放在栈中，使用时再拷贝出来。（返回的不是单个整数时编译为何种汇编语言？实验没有成功进行因为被编译器所优化）</p><h5 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h5><p>默认存在。</p><p>调用：</p><ul><li><code>Type b(a);</code></li><li><code>Type b = a;</code>（好像不太推荐）</li></ul><p>自定义（需要引用符号，引用传递）：</p><ul><li>不修改被拷贝的对象：<code>Type(const Type &amp;rhs) &#123;&#125;</code></li><li>要转移被拷贝的对象：<code>Type(Type &amp;rhs) &#123;&#125;</code></li></ul><p>参数列表调用：</p><ul><li>这样调用的是拷贝构造函数（无论加不加引用符号）：<code>Type(Type &amp;a):a(a) &#123;&#125;</code>。</li><li>这样调用的是普通构造函数：<code>Type(int a):a(a) &#123;&#125;</code>。</li></ul><p>【为什么拷贝构造函数不能值传递？】值传递时会在函数执行时创建局部变量，该局部变量初始化时需要使用拷贝构造函数将实际参数的值赋给它，这样再次调用拷贝构造函数就会产生死循环。</p><h5 id="浅拷贝-深拷贝"><a href="#浅拷贝-深拷贝" class="headerlink" title="浅拷贝&#x2F;深拷贝"></a>浅拷贝&#x2F;深拷贝</h5><p>浅拷贝：成员变量是一个对象时调用其对应的拷贝构造函数，其余（基本数据类型，指针类型，引用类型）直接按二进制拷贝。</p><p>深拷贝：自己实现，拷贝的不再是指针，而是指针内的值。</p><table><thead><tr><th></th><th>有构造函数</th><th>无构造函数</th></tr></thead><tbody><tr><td>有拷贝构造函数</td><td>无默认构造函数和拷贝构造函数</td><td>无默认构造函数和拷贝构造函数</td></tr><tr><td>无拷贝构造函数</td><td>有拷贝构造函数</td><td>有默认构造函数和拷贝构造函数</td></tr></tbody></table><p>即没有什么提供什么，但<strong>自定义的拷贝构造函数就可以代替构造函数</strong>。</p><h5 id="禁止拷贝"><a href="#禁止拷贝" class="headerlink" title="禁止拷贝"></a>禁止拷贝</h5><ul><li>自定义一个没有实现 <code>&#123;&#125;</code> 的 <code>private</code> 的拷贝构造函数。</li><li>C++1z：<code>T(const T&amp; t)=delete</code>。</li></ul><h5 id="拷贝与赋值"><a href="#拷贝与赋值" class="headerlink" title="拷贝与赋值"></a>拷贝与赋值</h5><ul><li>拷贝：<code>Type a = b;</code></li><li>赋值：<code>Type a; a = b;</code></li></ul><p>【有<strong>引用类型</strong>的成员不能赋值，可以拷贝】拷贝是初始化的过程，而赋值时引用类型的成员已经有引用的变量，因其不能更改所以不能赋值。（成员变量为引用类型：须自定义构造函数和拷贝构造函数，不能赋值。）</p><p>自定义赋值函数：重载 <code>=</code> 运算符 <code>Type &amp;operator = (const Type &amp;rhs) &#123; return *this; &#125;</code>（参考内置类型的使用习惯）。</p><p>课件中一个有趣的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Type</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="built_in">Type</span>() &#123; p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>); &#125;</span><br><span class="line">    Type &amp;<span class="keyword">operator</span> = (<span class="type">const</span> Type &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="built_in">int</span>(*rhs.p);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Type a; a = a;</span><br><span class="line">    Type &amp;b = a; a = b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时编译正常，但逻辑错误，应当<strong>判断 <code>(&amp;rhs != this)</code> 后</strong>再进行删除和赋值。</p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>只能重载一元运算符和二元运算符：<code>,</code>、<code>&amp;</code>（与运算）、<code>-&gt;</code>、<code>new</code>、<code>new[]</code> 等。</p><p>两种形式：自由函数 AND 成员函数。</p><p>访问权限等参考内置函数，如：</p><ul><li><code>T &amp;operator *= (const &amp;T rhs) &#123;&#125;</code></li><li><code>T operator * (const &amp;T rhs) &#123;&#125;</code></li><li><code>bool operator ! () &#123;&#125;</code></li><li><code>T &amp;operator ++ () &#123;&#125;</code>：对应 <code>++t</code>，返回的是自加后的值，因此要加 <code>&amp;</code> 符号。</li><li><code>T operator ++ (int) &#123;&#125;</code>：对应 <code>t++</code>，返回的是自加前的值，因此无需 <code>&amp;</code> 符号。</li><li><code>int opeartor [] (int index) const &#123; return arr[index]; &#125;</code></li><li><code>int &amp;operator [] (int index) &#123; return arr[index]; &#125;</code></li><li><code>int operator () () const &#123; return 1024; &#125;</code>：仿函数，可用 lambda 表达式代替。</li><li>重载 <code>-&gt;</code> 运算符须保证：返回指针类型或返回的自定义类型重载了 <code>-&gt;</code>。</li><li><code>ostream &amp;operator &lt;&lt; (ostream &amp;out, const T &amp;t) &#123; out &lt;&lt; t.a; return out; &#125;</code></li><li><code>istream &amp;operator &gt;&gt; (istream &amp;in, const T &amp;t) &#123; in &gt;&gt; t.a; return in; &#125;</code></li></ul><p>注：<code>lhs</code>、<code>rhs</code> 分别是 Left Hand Side 和 Right Hand Side 的缩写。</p><p>左操作数是自定义类型的尽量使用成员函数的形式重载，不要重载运算符 <code>&amp;&amp;</code>、<code>||</code>、<code>,</code>。</p><h3 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h3><p>动态内存管理：存放在全局堆区（<code>new</code> 申请的内存）</p><h5 id="new-delete"><a href="#new-delete" class="headerlink" title="new&#x2F;delete"></a>new&#x2F;delete</h5><p>分配数组类型：<code>int *p = new int(5)</code></p><p>分配指针类型：<code>const T **p = new P*();</code></p><p>释放数组类型：<code>delete[] arr;</code></p><p><code>new</code> 失败后会跳转 <code>new_error_handle()</code> 函数（可通过 <code>set_new_handler()</code> 修改），成功会执行构造函数并返回对应类型的指针（重载 <code>new</code> 运算符返回的 <code>void *</code> 类型指针会强制转化为 <code>T *</code> 类型指针）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;erorooor&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*func)</span><span class="params">()</span></span>;</span><br><span class="line">    func before = std::<span class="built_in">set_new_handler</span>(func1);</span><br><span class="line">    std::<span class="built_in">set_new_handler</span>(before);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="重载-new-delete"><a href="#重载-new-delete" class="headerlink" title="重载 new&#x2F;delete"></a>重载 new&#x2F;delete</h5><p><code>void* operator new(std::size_t);</code> 对应 <code>new T(1024);</code></p><p><code>void* operator new(std::size_t, const string &amp;s);</code> 对应 <code>new(&quot;string&quot;) T(1024);</code></p><p><code>void operator delete(void *, std::set_t);</code> 对应 <code>delete p;</code></p><h5 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[n];<span class="comment">// n 可以为变量</span></span><br><span class="line"><span class="keyword">delete</span>[] arr;</span><br></pre></td></tr></table></figure><p>普通类型对象数组 <code>Type arr[1024];</code> 要求必须有无参构造函数。</p><p>指针类型对象数组 <code>Type* arr[1024];</code> 不要求必须有无参构造函数。</p><h5 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h5><p>将指针封装在类中，以便析构时自动释放。</p><h5 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h5><p>共享指针，记录指针被引用的次数。</p><ul><li><code>&lt;memory&gt;</code></li><li><code>std::shared_ptr&lt;Type&gt;</code></li><li><code>std::make_shared&lt;Type&gt;()</code></li><li><code>p.get()</code></li><li><code>*p</code> 等价于 <code>*p.get()</code></li><li><code>p.use_count()</code></li><li><code>p.reset()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; p = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    *p = <span class="number">1024</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[p]\tptr: %p val: %d use_count: %ld\n&quot;</span>, p.<span class="built_in">get</span>(), *p, p.<span class="built_in">use_count</span>());</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p0</span><span class="params">(p)</span></span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[p]\tptr: %p val: %d use_count: %ld\n&quot;</span>, p.<span class="built_in">get</span>(), *p, p.<span class="built_in">use_count</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[p0]\tptr: %p val: %d use_count: %ld\n&quot;</span>, p<span class="number">0.</span><span class="built_in">get</span>(), *p0, p<span class="number">0.</span><span class="built_in">use_count</span>());</span><br><span class="line">    p.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[p0]\tptr: %p val: %d use_count: %ld\n&quot;</span>, p<span class="number">0.</span><span class="built_in">get</span>(), *p0, p<span class="number">0.</span><span class="built_in">use_count</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[p]        ptr: 0x6000025c4058 val: 1024 use_count: 1</span></span><br><span class="line"><span class="comment">[p]        ptr: 0x6000025c4058 val: 1024 use_count: 2</span></span><br><span class="line"><span class="comment">[p0]    ptr: 0x6000025c4058 val: 1024 use_count: 2</span></span><br><span class="line"><span class="comment">[p0]    ptr: 0x6000025c4058 val: 1024 use_count: 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>（<code>printf</code> 中输出地址用 <code>%p</code>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y): <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Point&gt; p = std::<span class="built_in">make_shared</span>&lt;Point&gt;(<span class="number">12</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[p]\tptr: %p val: (%d, %d) use_count: %ld\n&quot;</span>, p.<span class="built_in">get</span>(), p-&gt;x, p-&gt;y, p.<span class="built_in">use_count</span>());</span><br><span class="line">    std::shared_ptr&lt;Point&gt; p0 = p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[p]\tptr: %p val: (%d, %d) use_count: %ld\n&quot;</span>, p.<span class="built_in">get</span>(), p-&gt;x, p-&gt;y, p.<span class="built_in">use_count</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[p0]\tptr: %p val: (%d, %d) use_count: %ld\n&quot;</span>, p<span class="number">0.</span><span class="built_in">get</span>(), p0-&gt;x, p0-&gt;y, p<span class="number">0.</span><span class="built_in">use_count</span>());</span><br><span class="line">    p-&gt;x = <span class="number">3</span>; p-&gt;y = <span class="number">9</span>; p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[p0]\tptr: %p val: (%d, %d) use_count: %ld\n&quot;</span>, p<span class="number">0.</span><span class="built_in">get</span>(), p0-&gt;x, p0-&gt;y, p<span class="number">0.</span><span class="built_in">use_count</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[p]        ptr: 0x600003bad1d8 val: (12, 4) use_count: 1</span></span><br><span class="line"><span class="comment">[p]        ptr: 0x600003bad1d8 val: (12, 4) use_count: 2</span></span><br><span class="line"><span class="comment">[p0]    ptr: 0x600003bad1d8 val: (12, 4) use_count: 2</span></span><br><span class="line"><span class="comment">[p0]    ptr: 0x600003bad1d8 val: (3, 9) use_count: 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以像普通指针一样用赋值号，也会被累计其中哦！</p><p>函数体结束就释放了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y): <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Point *addr;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Point&gt; p = std::<span class="built_in">make_shared</span>&lt;Point&gt;(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p %d %d\n&quot;</span>, p.<span class="built_in">get</span>(), p-&gt;x, p-&gt;y);</span><br><span class="line">    addr = p.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">create</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, addr-&gt;x, addr-&gt;y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0x600001365118 3 5</span></span><br><span class="line"><span class="comment">0 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>除非作为返回值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y): <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Point *addr;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Point&gt; <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Point&gt; p = std::<span class="built_in">make_shared</span>&lt;Point&gt;(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p %d %d\n&quot;</span>, p.<span class="built_in">get</span>(), p-&gt;x, p-&gt;y); addr = p.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Point&gt; &amp;&amp; pp = <span class="built_in">create</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p used_count: %ld\n&quot;</span>, pp.<span class="built_in">get</span>(), pp.<span class="built_in">use_count</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, addr-&gt;x, addr-&gt;y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0x6000025f51d8 3 5</span></span><br><span class="line"><span class="comment">0x6000025f51d8 used_count: 1</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这个东西可以利用前面学到的拷贝构造函数和重载赋值自己实现。</p><h5 id="乱七八糟概念"><a href="#乱七八糟概念" class="headerlink" title="乱七八糟概念"></a>乱七八糟概念</h5><p>悬浮指针：释放后访问指针。</p><p>内存泄漏：申请了没释放。</p><p>写时复制：指向多个同一资源，需要修改的时候才复制一份分开，用来节省空间（有点像可持久化）。</p><p>定位分配：分配到已有空间，就是下面这个东西（需要 <code>&lt;new&gt;</code>，在后面指定分配到的地址）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">char</span>* s = <span class="built_in">new</span>(buf) <span class="built_in">char</span>(<span class="number">32</span>);</span><br><span class="line">    <span class="type">char</span>* ss = <span class="built_in">new</span>(buf + <span class="number">32</span>) <span class="built_in">char</span>(<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p %p %p\n&quot;</span>, buf, s, ss);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0x16d762cf8 0x16d762cf8 0x16d762d18</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="转换函数、命名空间、友元、嵌套类、流"><a href="#转换函数、命名空间、友元、嵌套类、流" class="headerlink" title="转换函数、命名空间、友元、嵌套类、流"></a>转换函数、命名空间、友元、嵌套类、流</h3><h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><p>基本数据类型2自定义类型：构造函数（可通过 <code>explicit</code> 禁止）</p><p>自定义类型2基本数据类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y): <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">p</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>, <span class="built_in">double</span>(p));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5.000000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">去掉 explicit 可以有这样的写法：</span></span><br><span class="line"><span class="comment">double q = p;</span></span><br><span class="line"><span class="comment">而非：</span></span><br><span class="line"><span class="comment">double q = (double)p;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>（C 风格强制类型转换 <code>(Type)Value</code> 和 C++ 风格强制类型转换 <code>Type(Value)</code> 应该没什么大的区别）</p><h5 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h5><p>耳熟能详的东西：<code>namespace NAME &#123;&#125;</code>。</p><p>没见过的东西：<code>::</code> 单独出现表示全局命名空间，否则表示当前命名空间。</p><p>可以嵌套：<code>namespace A &#123; namespace B &#123;&#125; &#125;</code>。</p><p>可以起别名：<code>namespace A = B;</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">    <span class="keyword">namespace</span> B &#123;</span><br><span class="line">        <span class="type">int</span> value = <span class="number">32</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> C = A;</span><br><span class="line"><span class="type">int</span> value = <span class="number">1024</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">64</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, value, ::value, C::B::value);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">64 1024 32</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>static</code> 访问域：仅能在当前文件中被访问。</p><p>奇怪的东西：匿名空间 <code>namespace &#123;&#125;</code>，看看它怎么回事。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> &#123; <span class="type">int</span> value = <span class="number">32</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">64</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, value, ::value);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">64 32</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如果有了全局变量，优先用全局变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="type">int</span> value = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">namespace</span> &#123; <span class="type">int</span> value = <span class="number">32</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">64</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, value, ::value);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">64 1024</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>对于匿名空间，编译器会给它一个名字并且自动 <code>using namespace XXX;</code>，它和 <code>static</code> 具有相同的 <strong>internal</strong> 链接属性，只对本文件可见，C++ 更提倡使用匿名空间而不是 <code>static</code>。</p><p><code>using</code> 关键字用于<strong>汇入</strong>当前命名空间。</p><h5 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h5><p>嵌套类亦有所谓的访问权限（<code>public</code> 或 <code>private</code>）。</p><p>注：没有指定访问权限的成员变量默认私有。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, a.a, a.pub_a, a.pri_a);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> pub_b;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> pri_b;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// error: &#x27;b&#x27; is a private member of &#x27;A::B&#x27;</span></span><br><span class="line">        <span class="comment">// printf(&quot;%d %d %d\n&quot;, b.b, b.pub_b, b.pri_b);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b.pub_b);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> pub_a;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> pri_a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">内部类可以访问外部类的私有成员变量。</span></span><br><span class="line"><span class="comment">外不能不能访问内部类的私有成员变量。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="友元-friend"><a href="#友元-friend" class="headerlink" title="友元 friend"></a>友元 friend</h5><p>友元函数&#x2F;友元类：允许访问类的私有成员，写在类的开始，不指明访问权限。</p><p>一种很不优雅的妥协，friend关键字只能用在类中，表明允许其后的函数&#x2F;类访问该类的私有元素，这个函数&#x2F;类不在当前类中，只需照常使用，额外增加了访问权限而已。</p><h5 id="流"><a href="#流" class="headerlink" title="流"></a>流</h5><p>字节流&#x2F;字符流&#x2F;文件流，<code>istream</code> 和 <code>ostream</code>。</p><h3 id="类间关系"><a href="#类间关系" class="headerlink" title="类间关系"></a>类间关系</h3><p>强关联&#x2F;硬关联&#x2F;弱关联&#x2F;软关联：？？？</p><p>联系强弱：（另一类作为）成员变量 &gt; 函数参数和返回值 &gt; 函数实现（局部变量）</p><h5 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h5><p>一般关联&#x2F;自关联&#x2F;关联类（设定一个类）&#x2F;聚集关联</p><p>关联关系：聚合关系（不负责创建和销毁）&#x2F;组合关系（负责创建和销毁）</p><p>依赖关系</p><h5 id="补充：UML图"><a href="#补充：UML图" class="headerlink" title="补充：UML图"></a>补充：UML图</h5><ul><li>+（public）、-（private）、#（protected）</li><li>抽象类和抽象方法用斜体</li><li>接口 &lt;&lt;interface&gt;&gt; 下面是接口名。</li><li>类实现接口：箭头（空心三角和虚线）</li><li>类继承父类：（子类向父类）箭头（空心三角和实线）</li><li>关联关系（成员变量是一个类）：（指向成员变量的类）箭头（角和实线）</li><li>依赖关系（成员函数的参数&#x2F;返回值是一个类）：（指向用到的类）箭头（角和虚线）</li><li>聚合关系 <code>has-a</code>：关联关系的特例，箭头（空心菱形和实线角）</li><li>组合关系 <code>contain-a</code>：关联关系的特例，箭头（实心菱形和实线角）</li></ul><h3 id="类的设计"><a href="#类的设计" class="headerlink" title="类的设计"></a>类的设计</h3><p>继承&#x2F;封装&#x2F;多态</p><p>依赖（参数或返回类型）&#x2F;关联（成员变量）</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>可以多继承，不继承父类的构造函数、析构函数、拷贝构造函数、赋值函数、类型转换函数，但在构造函数执行前会先执行父类的构造函数。</p><h5 id="继承方式：public、protected、private（默认），继承后的访问权限根据继承方式进行相应的削弱（如-protected-继承方式将父类中-public-成员削弱为-protected）。"><a href="#继承方式：public、protected、private（默认），继承后的访问权限根据继承方式进行相应的削弱（如-protected-继承方式将父类中-public-成员削弱为-protected）。" class="headerlink" title="继承方式：public、protected、private（默认），继承后的访问权限根据继承方式进行相应的削弱（如 protected 继承方式将父类中 public 成员削弱为 protected）。"></a>继承方式：public、protected、private（默认），继承后的访问权限根据继承方式进行相应的削弱（如 protected 继承方式将父类中 public 成员削弱为 protected）。</h5><p>【private 继承为什么还要存在？】待填坑。</p><p>如何调用父类的构造函数？在初始化列表中调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">P</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">P</span>(<span class="type">int</span> x = <span class="number">3</span>, <span class="type">int</span> y = <span class="number">4</span>): <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">V</span>: <span class="keyword">public</span> P &#123;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">V</span>(<span class="type">int</span> z): <span class="built_in">P</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="built_in">z</span>(z) &#123;&#125;<span class="comment">// Here</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>, x, y, z); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">v0</span><span class="params">(<span class="number">3</span>)</span></span>; v<span class="number">0.</span><span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么 C++ 中没有 super？因为 C++ 支持多继承啊，super 指的是哪个呢？</p><p>再给个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">P</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">P</span>(<span class="type">int</span> x = <span class="number">3</span>, <span class="type">int</span> y = <span class="number">4</span>): <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123; <span class="built_in">puts</span>(<span class="string">&quot;P(int x = 3, int y = 4): x(x), y(y)&quot;</span>); &#125;</span><br><span class="line">    <span class="built_in">P</span>(<span class="type">const</span> P &amp;rhs) &#123; <span class="built_in">puts</span>(<span class="string">&quot;P(const P &amp;rhs)&quot;</span>); x = rhs.x + <span class="number">1</span>; y = rhs.y + <span class="number">1</span>; &#125;</span><br><span class="line">    P &amp;<span class="keyword">operator</span> = (<span class="type">const</span> P &amp;rhs) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;P &amp;operator = (const P &amp;rhs)&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(&amp;rhs != <span class="keyword">this</span>) &#123;</span><br><span class="line">            x = <span class="number">0</span>; y = <span class="number">0</span>;</span><br><span class="line">            x = rhs.x - <span class="number">1</span>; y = rhs.y - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>(x * x + y * y);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">V</span>: <span class="keyword">public</span> P &#123;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">V</span>(<span class="type">int</span> z): <span class="built_in">P</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="built_in">z</span>(z) &#123; <span class="built_in">puts</span>(<span class="string">&quot;V(int z): P(1, 2), z(z)&quot;</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, x, y, z); &#125;</span><br><span class="line">    <span class="built_in">V</span>(<span class="type">const</span> V &amp;rhs): <span class="built_in">P</span>(rhs) &#123; <span class="built_in">puts</span>(<span class="string">&quot;V(const V &amp;rhs)&quot;</span>); z = rhs.z + <span class="number">1</span>; &#125;</span><br><span class="line">    V &amp;<span class="keyword">operator</span> = (<span class="type">const</span> V &amp;rhs) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;V &amp;operator = (const V &amp;rhs)&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(&amp;rhs != <span class="keyword">this</span>) &#123;</span><br><span class="line">            P::<span class="keyword">operator</span>=(rhs);</span><br><span class="line">            z = <span class="number">0</span>; z = rhs.z - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">v0</span><span class="params">(<span class="number">3</span>)</span></span>; v<span class="number">0.</span><span class="built_in">get</span>();</span><br><span class="line">    V v1 = v0; v<span class="number">1.</span><span class="built_in">get</span>();</span><br><span class="line">    v1 = v0; v<span class="number">1.</span><span class="built_in">get</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>, <span class="built_in">double</span>(v1));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">P(int x = 3, int y = 4): x(x), y(y)</span></span><br><span class="line"><span class="comment">V(int z): P(1, 2), z(z)</span></span><br><span class="line"><span class="comment">1 2 3</span></span><br><span class="line"><span class="comment">P(const P &amp;rhs)</span></span><br><span class="line"><span class="comment">V(const V &amp;rhs)</span></span><br><span class="line"><span class="comment">2 3 4</span></span><br><span class="line"><span class="comment">V &amp;operator = (const V &amp;rhs)</span></span><br><span class="line"><span class="comment">P &amp;operator = (const P &amp;rhs)</span></span><br><span class="line"><span class="comment">0 1 2</span></span><br><span class="line"><span class="comment">1.000000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>注意代码中 <code>V</code> 类型的 <code>rhs</code> 可以调用 <code>P(rhs)</code> 以及 <code>P::operator=(rhs)</code>。</p><p>注意这里类型转换函数直接调用了父类的。</p><h5 id="子类的一系列操作"><a href="#子类的一系列操作" class="headerlink" title="子类的一系列操作"></a>子类的一系列操作</h5><ul><li>newdefine：子类中定义，父类中没有。</li><li>redefine：子类中定义，父类中也有。</li><li>overload：子类中定义多个，重载。</li><li>overwrite：子类中定义，<strong>父类中有同名的，被隐藏</strong>。</li><li>override（和我之前以为的 override 不太一样）：子类中定义，父类中为同名虚函数。</li></ul><h3 id="继承和类型转换"><a href="#继承和类型转换" class="headerlink" title="继承和类型转换"></a>继承和类型转换</h3><p>protected&#x2F;private 向上（子类转父类）转换：先取地址再转对应类型的指针，不推荐。</p><p>public 向上转换：安全的，会创建一个新的对象，所以尽可能使用指针或引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">P</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">P</span>(<span class="type">int</span> x = <span class="number">3</span>, <span class="type">int</span> y = <span class="number">4</span>): <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">V</span>: <span class="keyword">public</span> P &#123;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">V</span>(<span class="type">int</span> z): <span class="built_in">P</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="built_in">z</span>(z) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    V* v0 = <span class="keyword">new</span> <span class="built_in">V</span>(<span class="number">3</span>);</span><br><span class="line">    P* p0 = v0;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p %p\n&quot;</span>, v0, p0);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0x600001de4040 0x600001de4040</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>public 向下转换：可能出错。</p><h5 id="乱七八糟的类型转换操作符"><a href="#乱七八糟的类型转换操作符" class="headerlink" title="乱七八糟的类型转换操作符"></a>乱七八糟的类型转换操作符</h5><p><code>static_cast&lt;T&gt;(exp)</code></p><p><code>const_cast&lt;T&gt;(exp)</code>：修改 <code>const</code> 或 <code>volatile</code> 约束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">P</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">P</span>(<span class="type">int</span> x = <span class="number">3</span>, <span class="type">int</span> y = <span class="number">4</span>): <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, x, y);</span><br><span class="line">        P* p = <span class="built_in">const_cast</span>&lt;P*&gt;(<span class="keyword">this</span>);</span><br><span class="line">        p-&gt;x = <span class="number">1</span>; p-&gt;y = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    P p0; p<span class="number">0.</span><span class="built_in">query</span>(); <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, p<span class="number">0.</span>x, p<span class="number">0.</span>y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>然后尽管这个函数是 <code>const</code>，这个对象的值还是被改了。</p><p><code>reinterpret_cast&lt;T&gt;(exp)</code>：重新解释，用于函数。</p><p><code>dynamic_cast&lt;T&gt;(exp)</code>：用于多继承时父类转子类。</p><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="%%%多重继承"></a>%%%多重继承</h3><p>顺序：构造顺序相同，析构顺序相反。</p><p>菱形结构多重继承产生重复：<strong>虚继承</strong>（继承类加 <code>virtual</code> 关键字修饰），被继承的类称为虚基类。</p><h5 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h5><p>放置静态函数和静态变量。</p><h5 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h5><p>C++ 没有 interface，通过纯虚函数（抽象函数）实现，指定 <code>virtual</code> 之外还要制定函数 <code>=0</code>。</p><h3 id="虚机制"><a href="#虚机制" class="headerlink" title="虚机制"></a>虚机制</h3><h5 id="静态编联与动态编联"><a href="#静态编联与动态编联" class="headerlink" title="静态编联与动态编联"></a>静态编联与动态编联</h5><p>静态编联：编译期间决定调用关系。</p><p>动态编联：执行期间决定调用关系，虚机制是实现方式之一。</p><h5 id="虚指针"><a href="#虚指针" class="headerlink" title="虚指针"></a>虚指针</h5><p>我以为是个新东西，其实就是 vptr。</p><h5 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h5><p>声明时需要加 <code>virtual</code>，定义时可加可不加。</p><ul><li>静态函数显然不能是虚函数。</li><li>如果有虚函数，析构函数应当是虚函数。</li><li>构造函数和拷贝构造函数不能是虚函数，赋值函数通常不定义为虚函数。</li></ul><p>【为什么构造函数不能是虚函数？】调用构造函数需要 vptr，此时对象还没有实例化，找不到 vptr。</p><p>【为什么赋值函数不要定义为虚函数？】因为子类不继承父类的赋值函数（参数类型不同）。</p><h5 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h5><ul><li>public 继承，且会继承父类的虚函数。</li><li>重写函数（函数名相同，多数要求参数相同，返回类型相同或<strong>相容</strong>）默认 <code>virtual</code> 可省略（包括析构函数）。</li></ul><h5 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h5><ul><li>一个类只有一个（实例化首个对象时创建），所有对象共享。</li><li>父子类的虚拟表中相同函数的位置相同。</li></ul><h5 id="静态类型与动态类型"><a href="#静态类型与动态类型" class="headerlink" title="静态类型与动态类型"></a>静态类型与动态类型</h5><p>静态类型：编译期间确定的类型（对应指针的类型）。</p><p>动态类型：执行期间确定的类型（对应指针指向的实际类型）。</p><h5 id="【重要】如何执行？"><a href="#【重要】如何执行？" class="headerlink" title="【重要】如何执行？"></a>【重要】如何执行？</h5><ul><li>在静态类型（定义的指针类型）中寻找对应函数，找不到编译错误。</li><li>若找到的函数不是 <code>virtual</code> 函数则 <code>p-&gt;P::func()</code>，若为 <code>virtual</code> 函数则根据 vptr 执行 <code>(*p-&gt;vptr)[index]((void *)p, ...)</code>。</li></ul><p>在构造函数中调用虚函数当然调用的对应类自己的那个函数，由于 B 类继承自 A 类，构造 B 类时也会构造 A 类（注意这个 A 类仅用于创建的 B 类对象，每再创建一个 B 类会就会再执行一次 A 类的构造函数。</p><p>B 类对象构造的过程：</p><ul><li>构造 A 类</li><li>构造 B 类</li></ul><p>B 类对象析构的过程：</p><ul><li>析构 B 类</li><li>析构 A 类</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A 的析构函数不加 virtual 会在运行时出错哦，因为 object 调用的是 A 的析构函数，导致释放了两次。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> variable;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> variable): <span class="built_in">variable</span>(variable) &#123; <span class="built_in">get</span>(); &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>() &#123; <span class="built_in">get</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[A] get();\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> variable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(): <span class="built_in">A</span>(<span class="number">1024</span>) &#123; <span class="built_in">get</span>(); &#125;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123; <span class="built_in">get</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[B] get();\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> variable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* object = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    A* object2 = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    <span class="keyword">delete</span> object;</span><br><span class="line">    <span class="keyword">delete</span> object2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[A] get();</span></span><br><span class="line"><span class="comment">[B] get();</span></span><br><span class="line"><span class="comment">[A] get();</span></span><br><span class="line"><span class="comment">[B] get();</span></span><br><span class="line"><span class="comment">[B] get();</span></span><br><span class="line"><span class="comment">[A] get();</span></span><br><span class="line"><span class="comment">[B] get();</span></span><br><span class="line"><span class="comment">[A] get();</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="私有的虚函数访问"><a href="#私有的虚函数访问" class="headerlink" title="私有的虚函数访问"></a>私有的虚函数访问</h5><p>指针是父类类型时，在父类中调用一个子类中重写过的虚函数（父类中当然定义了），实际上调用的是子类中的那个版本，即便它是 <code>private</code> 的，依然能够执行。（跨类访问私有函数）</p><h5 id="具体类和抽象类"><a href="#具体类和抽象类" class="headerlink" title="具体类和抽象类"></a>具体类和抽象类</h5><p>抽象类：有纯虚函数（<code>virtual</code> 函数 <code>=0</code>），也叫抽象函数。</p><p>具体类和抽象类的子类既可以是具体类也可以是抽象类。</p><p>纯抽象类：除了静态、构造、析构函数均为纯虚函数。</p><p>接口类：<strong>纯抽象类</strong>，成员均为 <code>public static</code>。</p><p>【!】纯虚函数可以在类外给出定义（当然可以不定义），例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> variable;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> variable): <span class="built_in">variable</span>(variable) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">abstractFunction</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::abstractFunction</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，抽象类不能被实例化，所以个人感觉没什么意义。</p><p>继承自抽象类后没有实现对应的抽象函数子类就还是抽象类。</p><h5 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h5><p><code>typeid(exp_or_type)</code>：类型比较。</p><p><code>dynamic_cast&lt;T&gt;(exp)</code>：父类转子类，T 为指针类型失败返回 nullptr，T 为引用类型失败产生异常。</p><h5 id="关于虚函数一些例子"><a href="#关于虚函数一些例子" class="headerlink" title="关于虚函数一些例子"></a>关于虚函数一些例子</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 父类定义为虚函数后，子类重写时 virtual 关键字可省略 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> variable;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> variable): <span class="built_in">variable</span>(variable) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[A] get();\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> variable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(): <span class="built_in">A</span>(<span class="number">1024</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[B] get();\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> variable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* object = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    object-&gt;<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[B] get();</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 仅仅定义子类重写的函数是虚函数无效 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> variable;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> variable): <span class="built_in">variable</span>(variable) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[A] get();\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> variable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(): <span class="built_in">A</span>(<span class="number">1024</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[B] get();\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> variable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* object = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    object-&gt;<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[A] get();</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 父类类型的指针不能用于访问子类中特有的函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> variable;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> variable): <span class="built_in">variable</span>(variable) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[A] get();\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> variable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(): <span class="built_in">A</span>(<span class="number">1024</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[B] get();\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> variable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* object = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    object-&gt;<span class="built_in">getB</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">error: no member named &#x27;getB&#x27; in &#x27;A&#x27;; did you mean &#x27;get&#x27;?</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h5><p>越想越觉得虚函数和抽象函数并不是完全没有联系，<code>virtual</code> 关键字就好像告诉我们尽可能地不使用当前类的代码而去使用子类的实现，不同之处在于抽象函数不允许子类没实现而虚函数给了一个子类没实现时的保底。</p><h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><p>定义：相同的消息请求，执行不同的代码体，产生不同的结果。</p><p>静态多态：根据<strong>静态类型</strong>确定执行的代码，如<strong>模版</strong>和<strong>函数重载</strong>。</p><p>动态多态：根据目标对象<strong>动态类型</strong>和参数表<strong>静态类型</strong>确定执行的代码，如<strong>虚机制</strong>。</p><h5 id="使用虚机制"><a href="#使用虚机制" class="headerlink" title="使用虚机制"></a>使用虚机制</h5><p>面向对象编程，使用父类指针执行子类代码。</p><h5 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h5><p>拷贝构造函数不能是虚函数，静态类型和动态类型不同，如何复制呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定义虚函数 clone()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a = <span class="number">32</span>): <span class="built_in">a</span>(a) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> A* <span class="title">clone</span><span class="params">()</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;clone A&quot;</span>); <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">A</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> b = <span class="number">64</span>): <span class="built_in">b</span>(b) &#123;&#125;</span><br><span class="line">    <span class="function">B* <span class="title">clone</span><span class="params">()</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;clone B&quot;</span>); <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">B</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* t = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    A* t0 = t-&gt;<span class="built_in">clone</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">clone B</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>如果有多个函数，每个函数有若干种实现，则子类个数为它们相乘。</p><p>【解决方案】在类中定义三个变量指向三个新类，每个新类定义一个虚函数，通过继承该类实现这个函数，调用函数时调用对应成员变量的成员函数即可，这样子类个数为各个函数实现方案数的和。</p><h5 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h5><p>懒得看，鸵鸟法可知这一章没什么东西（doge</p><h3 id="一些好玩的"><a href="#一些好玩的" class="headerlink" title="一些好玩的"></a>一些好玩的</h3><p>【开玩笑的】隐藏运算符：趋向于（雾）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> t; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--&gt;<span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> = <span class="number">2</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> b = *((<span class="type">char</span>*)(&amp;a) - <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">func</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数省略形式参数名：<a href="https://blog.csdn.net/C0631xjn_/article/details/127280342">https://blog.csdn.net/C0631xjn_/article/details/127280342</a></p><p>类中静态变量初始化：<a href="https://blog.csdn.net/qq_50868258/article/details/123139071">https://blog.csdn.net/qq_50868258/article/details/123139071</a></p><p>类中静态变量初始化：<a href="https://blog.csdn.net/sevenjoin/article/details/81772792">https://blog.csdn.net/sevenjoin/article/details/81772792</a></p><p>虚函数：<a href="https://zhuanlan.zhihu.com/p/28530472">https://zhuanlan.zhihu.com/p/28530472</a></p><p>explicit 关键字与离谱的 C++：<a href="https://zhuanlan.zhihu.com/p/52152355">https://zhuanlan.zhihu.com/p/52152355</a></p><p>shared_ptr：<a href="https://zhuanlan.zhihu.com/p/547647844">https://zhuanlan.zhihu.com/p/547647844</a></p><p>UML：<a href="https://zhuanlan.zhihu.com/p/109655171">https://zhuanlan.zhihu.com/p/109655171</a></p><p>虚继承内存空间安排：<a href="https://blog.csdn.net/SuLiJuan66/article/details/48897867">https://blog.csdn.net/SuLiJuan66/article/details/48897867</a></p><p>虚继承：<a href="https://zhuanlan.zhihu.com/p/104344453">https://zhuanlan.zhihu.com/p/104344453</a></p><h3 id="待补充"><a href="#待补充" class="headerlink" title="待补充"></a>待补充</h3><p>private构造函数</p><p>重载区分</p><p>拷贝构造函数的循环</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;照学校课件打的，大概率没什么意思，有空再修改。&lt;/p&gt;
&lt;h3 id=&quot;C-程序结构&quot;&gt;&lt;a href=&quot;#C-程序结构&quot; class=&quot;headerlink&quot; title=&quot;C++ 程序结构&quot;&gt;&lt;/a&gt;C++ 程序结构&lt;/h3&gt;&lt;h5 id=&quot;多文件编译&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://whz0325.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://whz0325.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【蓝桥杯 2022】最优清零方案</title>
    <link href="https://whz0325.github.io/lanqiao-2022-i/"/>
    <id>https://whz0325.github.io/lanqiao-2022-i/</id>
    <published>2023-04-02T06:27:00.000Z</published>
    <updated>2023-04-02T06:37:06.201Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个长度为 $n$ 的序列 ${a_i}$ 和一个整数 $k$，一次操作可以将连续 $k$ 个整数减一或者将一个整数减一，求将所有整数变为 $0$ 的最少操作次数。</p><p>$1\le k\le n\le 10^6$，$0\le a_i\le 10^6$。</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>啊，这题，我咋不会啊……</p><p>贪心策略是从左到右尽可能减连续 $k$ 个整数，操作次数和剩下零散的数加起来。</p><p>为啥是对的？如果我们要减连续 $k$ 个整数当然是越靠前越好，这样后面说不定可以再减一次，因为无论在哪里减对总和的影响都是相同的，如果在前面减区间的 $min$ 值更小，也不会妨碍后面有重叠的区间将少减的这几次补上。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">    <span class="keyword">static</span> <span class="type">BufferedWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] a, tg, min; <span class="keyword">static</span> <span class="type">long</span>[] sum;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> o, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l == r) &#123; tg[o] = <span class="number">0</span>; sum[o] = min[o] = a[mid]; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            build(o &lt;&lt; <span class="number">1</span>, l, mid); build(o &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">            min[o] = Math.min(min[o &lt;&lt; <span class="number">1</span>], min[o &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">            sum[o] = sum[o &lt;&lt; <span class="number">1</span>] + sum[o &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> ql, qr;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">(<span class="type">int</span> o, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> min[o];</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(tg[o] != <span class="number">0</span>) &#123;</span><br><span class="line">            tg[o &lt;&lt; <span class="number">1</span>] += tg[o];</span><br><span class="line">            tg[o &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += tg[o];</span><br><span class="line">            min[o &lt;&lt; <span class="number">1</span>] += tg[o];</span><br><span class="line">            min[o &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += tg[o];</span><br><span class="line">            sum[o &lt;&lt; <span class="number">1</span>] += (<span class="type">long</span>)tg[o] * (mid - l + <span class="number">1</span>);</span><br><span class="line">            sum[o &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += (<span class="type">long</span>)tg[o] * (r - mid);</span><br><span class="line">            tg[o] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= mid) ans = Math.min(ans, getMin(o &lt;&lt; <span class="number">1</span>, l, mid));</span><br><span class="line">        <span class="keyword">if</span>(mid + <span class="number">1</span> &lt;= qr) ans = Math.min(ans, getMin(o &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">modify</span><span class="params">(<span class="type">int</span> o, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr) &#123;</span><br><span class="line">            tg[o] += x;</span><br><span class="line">            min[o] += x;</span><br><span class="line">            sum[o] += (<span class="type">long</span>)x * (r - l + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(tg[o] != <span class="number">0</span>) &#123;</span><br><span class="line">                tg[o &lt;&lt; <span class="number">1</span>] += tg[o];</span><br><span class="line">                tg[o &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += tg[o];</span><br><span class="line">                min[o &lt;&lt; <span class="number">1</span>] += tg[o];</span><br><span class="line">                min[o &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += tg[o];</span><br><span class="line">                sum[o &lt;&lt; <span class="number">1</span>] += (<span class="type">long</span>)tg[o] * (mid - l + <span class="number">1</span>);</span><br><span class="line">                sum[o &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += (<span class="type">long</span>)tg[o] * (r - mid);</span><br><span class="line">                tg[o] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ql &lt;= mid) modify(o &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">            <span class="keyword">if</span>(mid + <span class="number">1</span> &lt;= qr) modify(o &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">            min[o] = Math.min(min[o &lt;&lt; <span class="number">1</span>], min[o &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">            sum[o] = sum[o &lt;&lt; <span class="number">1</span>] + sum[o &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> in.readLine(); String[] ss = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(ss[<span class="number">0</span>]), k = Integer.parseInt(ss[<span class="number">1</span>]);</span><br><span class="line">        s = in.readLine(); ss = s.split(<span class="string">&quot; &quot;</span>); a = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++i) a[i] = Integer.parseInt(ss[i - <span class="number">1</span>]);</span><br><span class="line">        tg = <span class="keyword">new</span> <span class="title class_">int</span>[n &lt;&lt; <span class="number">2</span>]; min = <span class="keyword">new</span> <span class="title class_">int</span>[n &lt;&lt; <span class="number">2</span>]; sum = <span class="keyword">new</span> <span class="title class_">long</span>[n &lt;&lt; <span class="number">2</span>];</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>; build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i + k - <span class="number">1</span> &lt;= n; ++i) &#123;</span><br><span class="line">            ql = i; qr = i + k - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> getMin(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">            <span class="keyword">if</span>(res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans += res; x = -res;</span><br><span class="line">                modify(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += sum[<span class="number">1</span>];</span><br><span class="line">        out.write(String.format(<span class="string">&quot;%d\n&quot;</span>, ans));</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一个长度为 $n$ 的序列 ${a_i}$ 和一个整数 $k$，一次操作可以将连续 $k$ 个整数减一或者将一个整数减一</summary>
      
    
    
    
    <category term="竞赛题解" scheme="https://whz0325.github.io/categories/%E7%AB%9E%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="线段树" scheme="https://whz0325.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="贪心法" scheme="https://whz0325.github.io/tags/%E8%B4%AA%E5%BF%83%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【蓝桥杯 2022】推导部分和</title>
    <link href="https://whz0325.github.io/lanqiao-2022-j/"/>
    <id>https://whz0325.github.io/lanqiao-2022-j/</id>
    <published>2023-04-02T06:17:00.000Z</published>
    <updated>2023-04-02T06:25:55.319Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个长度为 $n$ 的未知序列 ${a_i}$，已知 $m$ 个条件 $l_i, r_i,S_i$，表示 $a_{l_i}+a_{l_i + 1}+\dots +a_{r_i}$ 的和为 $S_i$，要实现 $q$ 次询问，每次询问 $a_l+a_{l+1}+\dots +a_r$ 的值，若无解则输出 UNKNOWN。</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>将区间和拆成前缀和，每一个条件相当于告诉我们，一旦知道 $l_i-1$ 和 $r_i$ 中任何一个下标的前缀和，另一个下标的前缀和也能够得到，这个二元关系可以使用带权并查集来维护，每个点记录它到父节点的区间和，若 $l-1$ 与 $r$ 不连通则说明无解。</p><p>某辣鸡网站有锅，交两次相同代码一次 TLE 一次 AC。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">    <span class="keyword">static</span> <span class="type">BufferedWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] fa; <span class="keyword">static</span> <span class="type">long</span>[] val;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rt</span> <span class="operator">=</span> x; ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(fa[rt] != rt) &#123; arr.add(rt); rt = fa[rt]; &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            x = arr.get(i);</span><br><span class="line">            val[x] += val[fa[x]];</span><br><span class="line">            fa[x] = rt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> in.readLine(); String[] ss = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(ss[<span class="number">0</span>]), m = Integer.parseInt(ss[<span class="number">1</span>]), q = Integer.parseInt(ss[<span class="number">2</span>]);</span><br><span class="line">        fa = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>]; val = <span class="keyword">new</span> <span class="title class_">long</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; ++i) &#123; fa[i] = i; val[i] = <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="keyword">while</span>((m--) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = in.readLine(); ss = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> Integer.parseInt(ss[<span class="number">0</span>]), r = Integer.parseInt(ss[<span class="number">1</span>]); <span class="type">long</span> <span class="variable">S</span> <span class="operator">=</span> Long.parseLong(ss[<span class="number">2</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> find(l - <span class="number">1</span>), y = find(r);</span><br><span class="line">            <span class="keyword">if</span>(x != y) &#123;</span><br><span class="line">                val[y] = val[l - <span class="number">1</span>] + S - val[r];</span><br><span class="line">                fa[y] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>((q--) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = in.readLine(); ss = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> Integer.parseInt(ss[<span class="number">0</span>]), r = Integer.parseInt(ss[<span class="number">1</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> find(l - <span class="number">1</span>), y = find(r);</span><br><span class="line">            <span class="keyword">if</span>(x != y) out.write(<span class="string">&quot;UNKNOWN\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> out.write(String.format(<span class="string">&quot;%d\n&quot;</span>, val[r] - val[l - <span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一个长度为 $n$ 的未知序列 ${a_i}$，已知 $m$ 个条件 $l_i, r_i,S_i$，表示 $a_{l_i</summary>
      
    
    
    
    <category term="竞赛题解" scheme="https://whz0325.github.io/categories/%E7%AB%9E%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="并查集" scheme="https://whz0325.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="图论" scheme="https://whz0325.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【CF 1798F】Gifts from Grandfather Ahmed</title>
    <link href="https://whz0325.github.io/cf-1798f/"/>
    <id>https://whz0325.github.io/cf-1798f/</id>
    <published>2023-03-29T02:31:00.000Z</published>
    <updated>2023-03-29T03:02:08.541Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>有 $n+1$ 个数 ${a_i}$，分成 $k$ 组，其中第 $i$ 组分得的数之和必须为 $s_i$ 的倍数，保证 $\sum s_i&#x3D;n+1$，第 $n+1$ 个数丢失，要给出任一满足条件的 $a_{n+1}$ 的值和分组方案。</p><p>$1\le n,k\le 200$，$1\le a_i\le 10^6$。</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>有一个称为 Erdős–Ginzburg–Ziv theorem 的结论，它说任意 $2n-1$ 个数一定能选出 $n$ 个数是 $n$ 的倍数。</p><p>我们将 $s_i$ 排序，那么有 $s_1\le s_2\le\dots\le s_k$，假设选到第 $i$ 个数，一定有 $\sum_{k&#x3D;i}^ns_k\gt2s_i-1$，这表明前 $k-1$ 组的方案一定存在，对于第 $k$ 组我们保留了 $a_{n+1}$ 用于弥补余数使它整除 $s_k$，因此不存在无解的情况。</p><p>考虑用 DP 的方法先将前 $k-1$ 组的方案分别求出，就可以构造出第 $k$ 组的方案了。</p><p>问题转化为当前有 $a_0$ 个整数 $a_1,a_2,\dots,a_{a_0}$，从中选出 $s_i$ 个数，使这些数的和整除 $s_i$ 的任一方案。</p><p>设 $f[x][y][z]$ 表示前 $x$ 个整数中能否选出 $y$ 个数使得这些数模 $s_i$ 的余数为 $z$，转移考虑第 $i$ 个数填或者不填两种情况。</p><p>如何得到方案数呢？首先，正序依次贪心取很可能最后得不到解。逆序的话，$f[x][y][z]$ 存在解并不代表 $x$ 应当被选，因为它可能是从 $f[x-1][y][z]$ 转移而来的（即前面的数被选，对应状态中表示的前 $x$ 个整数，但倘若不这样设计状态转移的复杂度就不能够做到 $O(1)$）。这里我们判断如果 $f[x-1][y][z]$ 为 <code>false</code>，$f[x][y][z]$ 为 <code>true</code> 时才选择 $x$。</p><p>也可以判断它不能够从 $x$ 被选的上一个状态转移而来，即将代码实现中第 $35$ 行的 <code>f[x - 1][y][z]</code> 改为 <code>!f[x - 1][y - 1][(z + si - (a[x] % si)) % si]</code>，分别对应可任取的两种方案。</p><p>时间复杂度大约是 $O(n^4)$。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 205</span></span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; P;</span><br><span class="line"><span class="type">int</span> a[N], tmp[N]; P s[N]; <span class="type">bool</span> f[N][N][N];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    a[<span class="number">0</span>] = n; <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i].first);</span><br><span class="line">        s[i].second = i;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(s + <span class="number">1</span>, s + <span class="number">1</span> + k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> si = s[i].first, idx = s[i].second;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f)); f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">1</span>; x &lt;= a[<span class="number">0</span>]; ++x) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">0</span>; y &lt;= si; ++y) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> z = <span class="number">0</span>; z &lt; si; ++z) &#123;</span><br><span class="line">                    f[x][y][z] = f[x - <span class="number">1</span>][y][z];</span><br><span class="line">                    <span class="keyword">if</span>(y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        f[x][y][z] |= f[x - <span class="number">1</span>][y - <span class="number">1</span>][(z + si - (a[x] % si)) % si];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tmp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = a[<span class="number">0</span>], y = si, z = <span class="number">0</span>; x &gt;= <span class="number">1</span>; --x) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!y || !f[x][y][z] || f[x - <span class="number">1</span>][y][z]) &#123;</span><br><span class="line">                tmp[++tmp[<span class="number">0</span>]] = a[x];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --y; z = (z + si - a[x] % si) % si;</span><br><span class="line">            ans[idx].<span class="built_in">push_back</span>(a[x]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, end = tmp[<span class="number">0</span>]; i &lt;= end; ++i) a[i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> si = s[k].first, idx = s[k].second, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">1</span>; x &lt;= a[<span class="number">0</span>]; ++x) &#123;</span><br><span class="line">        sum = (sum + a[x]) % si;</span><br><span class="line">        ans[idx].<span class="built_in">push_back</span>(a[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    ans[idx].<span class="built_in">push_back</span>(si - sum);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, si - sum);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>, end = ans[i].<span class="built_in">size</span>(); j &lt; end; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, ans[i][j], (j ^ (end - <span class="number">1</span>)) ? <span class="string">&#x27; &#x27;</span> : <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;有 $n+1$ 个数 ${a_i}$，分成 $k$ 组，其中第 $i$ 组分得的数之和必须为 $s_i$ 的倍数，保证 $&#92;</summary>
      
    
    
    
    <category term="竞赛题解" scheme="https://whz0325.github.io/categories/%E7%AB%9E%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="动态规划" scheme="https://whz0325.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>【CF 1798E】Multitest Generator</title>
    <link href="https://whz0325.github.io/cf-1798e/"/>
    <id>https://whz0325.github.io/cf-1798e/</id>
    <published>2023-03-28T14:16:00.000Z</published>
    <updated>2023-03-28T14:52:15.139Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>定义一个序列为 test 仅当序列的第一个元素为这个序列剩下元素的长度。</p><p>定义一个序列为 multitest 仅当该序列的第一个数为能够将剩下元素组成的序列拆成的 test 的个数。</p><p>定义一次修改操作可以将序列中任意元素修改为任意一个非负整数。</p><p>定义函数 $f(A)$ 为将序列修改为 multitest 的最少操作次数。</p><p>给定一个长度为 $n$ 的序列 ${a_n}$，输出 $f([a_i, a_{i+1},\dots ,a_n])$ 当 $i\in [1,n-1]$ 的值。</p><p>$2\le n\le 300000$，$1\le a_i\le 300000$。</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>一开始想错了，还以为是特别水那种 DP。</p><p>构造一种方案：将第一个元素修改为 $1$，第二个元素修改为 $n-2$，因此对于任意序列，最少操作次数不会超过 $2$。</p><p>分类讨论：</p><p>什么情况下 $f(A)$ 的值为 $0$：定义 $f[i][0]$ 为以下标 $i$ 起始的后缀不进行任何修改操作将序列分成的块数，若不能拆分为若干个 test 则值为 $0$，转移很好设计。$f[i+1][0]&#x3D;a_i$ 时 $f([a_i,a_{i+1},\dots , a_n])$ 的值为 $0$。什么情况下 $f(A)$ 的值为 $1$：唯一一次修改会发生在两种位置。</p><p>第一种是在 multitest 的开始，即 $f[i+1][0]\neq a_i$ 时 $f([a_i,a_{i+1},\dots , a_n])$ 的值为 $1$。</p><p>第二种是在 multitest 中某个 test 的开头，这时定义 $f[i][1]$ 为以下标 $i$ 起始的后缀进行一次修改操作将序列分成的「最大」块数。为什么取最大呢？考虑转移时，要么修改过从 $f[i+a_i+1][1]$ 转移，要么没有修改过从 $f[j][0]$ 转移，这里的 $j$ 可以是 $[i+1,n]$ 中的任何值（对应将该数修改为 $[0,n-i-1]$，其实也可以修改为 $n-i$，这种情况用分成的 $1$ 块来更新 $f[i][1]$）。如果可以将序列分成 $b$ 块，则它一定能够分成 $a(a\le b)$ 块，因为我们可以考虑改变这一次修改的位置和值，从而将序列尾部的多个块合并。所以，在 $f[i+1][1]\ge a_i$ 时 $f([a_i,a_{i+1},\dots , a_n])$ 的值为 $1$。</p><p>（可能会感到疑惑，按照上面这种转移会不会包含把 $a_i$ 修改为 $a_i$ 的情况。确实会这样，不过不影响结果，因为这样符合题目要求而且我们要取的是最大值。）</p><p>其它情况下 $f(A)$ 的值为 $2$。</p><p>时间复杂度为 $O(n)$。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 300005</span></span><br><span class="line"><span class="type">int</span> a[N], f[N][<span class="number">2</span>], ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        <span class="type">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">        <span class="keyword">if</span>(a[n] == <span class="number">0</span>) &#123; f[n][<span class="number">0</span>] = <span class="number">1</span>; f[n][<span class="number">1</span>] = <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; f[n][<span class="number">0</span>] = <span class="number">0</span>; f[n][<span class="number">1</span>] = <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="type">int</span> mxf0 = f[n][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i + a[i] + <span class="number">1</span> == n + <span class="number">1</span>) &#123;</span><br><span class="line">                f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i + a[i] + <span class="number">1</span> &lt;= n &amp;&amp; f[i + a[i] + <span class="number">1</span>][<span class="number">0</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                f[i][<span class="number">0</span>] = f[i + a[i] + <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> f[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            f[i][<span class="number">1</span>] = mxf0 + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i + a[i] + <span class="number">1</span> &gt; n + <span class="number">1</span>) f[i][<span class="number">1</span>] = std::<span class="built_in">max</span>(f[i][<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i + a[i] + <span class="number">1</span> &lt;= n &amp;&amp; f[i + a[i] + <span class="number">1</span>][<span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                f[i][<span class="number">1</span>] = std::<span class="built_in">max</span>(f[i][<span class="number">1</span>], f[i + a[i] + <span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(f[i + <span class="number">1</span>][<span class="number">0</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(f[i + <span class="number">1</span>][<span class="number">0</span>] == a[i]) ans[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> ans[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(f[i + <span class="number">1</span>][<span class="number">1</span>] &gt;= a[i]) ans[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> ans[i] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            mxf0 = std::<span class="built_in">max</span>(mxf0, f[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, ans[i], (i ^ (n - <span class="number">1</span>)) ? <span class="string">&#x27; &#x27;</span> : <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;定义一个序列为 test 仅当序列的第一个元素为这个序列剩下元素的长度。&lt;/p&gt;
&lt;p&gt;定义一个序列为 multitest </summary>
      
    
    
    
    <category term="竞赛题解" scheme="https://whz0325.github.io/categories/%E7%AB%9E%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="动态规划" scheme="https://whz0325.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>【蓝桥杯 2022】青蛙过河</title>
    <link href="https://whz0325.github.io/lanqiao-2022-g/"/>
    <id>https://whz0325.github.io/lanqiao-2022-g/</id>
    <published>2023-03-25T07:07:00.000Z</published>
    <updated>2023-03-25T08:33:37.059Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在 $[1,n-1]$ 之中的每个位置有一个权值 $H_i$，当经过时权值减一，权值为 $0$ 时不能经过，求最小的跳跃距离（每次移动的距离均不超过跳跃距离），使得能够在位置 $0$ 和位置 $n$ 之间往返 $2x$ 次。</p><p>$1\le n\le 10^5$，$1\le x\le 10^9$，$1\le H_i\le 10^4$。</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>一眼二分答案，重点在于如何判断对于给定的跳跃距离 $y$ 是否能够往返 $2x$ 次。</p><p>第一种思路是判断每一个长度为 $y$ 的区间中的权值和是否都不低于 $2x$，如果低于则不能够往返，感性证明：</p><p>分别证充分性和必要性。对于任意长度为 $y$ 的区间，$2x$ 次往返中的每一次必经过一次该区间内的点，反证若不经过则最小跳跃距离应当超过 $y$，所以区间内的权值和至少应当是 $2x$。对于每个位置，能够跳到的位置必然是它后面长度为 $y$ 的区间中的位置，如果区间中的权值和不低于 $2x$ 则一定能让至少 $2x$ 次跑出去（位置 $n$ 也能够接收到前面 $2x$ 次）。</p><p>并不是非常好想，第二种思路则更为自然。</p><p>类似网络流的思想，把每个点推给它后面能到达的这 $y$ 个点，推到最后统计能够到达位置 $n$ 的次数是否达到 $2x$ 次（其实就相当于所有次数一齐跳）。推的过程肯定不能一个一个递，用并查集优化，一旦有权值 $H_i$ 满了，不能够再经过了则将它跳过，时间复杂度为 $O(nlog_2n)$。</p><p>注意 Java 在并查集 <code>find</code> 函数递归层数过多时会爆栈，因此采用非递归实现。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>算法一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> n, x, h[];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> y; i &lt; n; ++i) <span class="keyword">if</span>(h[i] - h[i - y] &lt; x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        n = in.nextInt(); x = in.nextInt() &lt;&lt; <span class="number">1</span>; h = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        h[<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) h[i] = h[i - <span class="number">1</span>] + in.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(mid)) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> n, x, h[], contain[], fa[];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rt</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="keyword">while</span>(rt != fa[rt]) rt = fa[rt];</span><br><span class="line">        <span class="keyword">while</span>(x != fa[x]) &#123;</span><br><span class="line">            fa[x] = rt;</span><br><span class="line">            x = fa[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> y)</span> &#123;</span><br><span class="line">        contain = <span class="keyword">new</span> <span class="title class_">int</span>[n]; contain[<span class="number">0</span>] = x;</span><br><span class="line">        fa = <span class="keyword">new</span> <span class="title class_">int</span>[n]; fa[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) fa[i] = (h[i] &gt; <span class="number">0</span> ? i : find(i - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span>(contain[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">loc</span> <span class="operator">=</span> find(Math.min(i + y, n - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">while</span>(loc &gt; i &amp;&amp; contain[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">flow</span> <span class="operator">=</span> Math.min(contain[i], h[loc] - contain[loc]);</span><br><span class="line">                contain[loc] += flow; contain[i] -= flow;</span><br><span class="line">                <span class="keyword">if</span>(h[loc] - contain[loc] == <span class="number">0</span>) fa[loc] = find(loc - <span class="number">1</span>);</span><br><span class="line">                loc = find(loc - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - y; i &lt; n; ++i) sum += contain[i];</span><br><span class="line">        <span class="keyword">return</span> sum &gt;= x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        n = in.nextInt(); x = in.nextInt() &lt;&lt; <span class="number">1</span>; h = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) h[i] = in.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(mid)) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;在 $[1,n-1]$ 之中的每个位置有一个权值 $H_i$，当经过时权值减一，权值为 $0$ 时不能经过，求最小的跳跃距离</summary>
      
    
    
    
    <category term="竞赛题解" scheme="https://whz0325.github.io/categories/%E7%AB%9E%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="二分法" scheme="https://whz0325.github.io/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
    <category term="贪心法" scheme="https://whz0325.github.io/tags/%E8%B4%AA%E5%BF%83%E6%B3%95/"/>
    
    <category term="并查集" scheme="https://whz0325.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>【蓝桥杯 2022】GCD</title>
    <link href="https://whz0325.github.io/lanqiao-2022-d/"/>
    <id>https://whz0325.github.io/lanqiao-2022-d/</id>
    <published>2023-03-25T02:51:00.000Z</published>
    <updated>2023-03-25T02:59:39.957Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>求最小的 $k$，使得 $gcd(a+k,b+k)$ 的值最大。</p><p>$1\le a\lt b\le 10^{18}$。</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>数论忘光了，思博选手不会写数学题。。。</p><p>首先有 $gcd(a,b)&#x3D;gcd(b,a-b)$，很好理解：$a&#x3D;gc$，$b&#x3D;gd$ 的话 $a-b&#x3D;g(c-d)$ 依然是两者最大公约数的倍数，这就是辗转相除法的基础。</p><p>那么，有 $gcd(a+k,b+k)&#x3D;gcd(a-b,a+k)$ 且 $gcd(a+k,b+k)&#x3D;gcd(a-b,b+k)$，一定能构造出 $g&#x3D;a-b$ 的解，取 $a-b|a+k$ 和 $a-b|b+k$ 中最小的 $k$ 即可。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> in.nextLong(), b = in.nextLong(), d = Math.abs(a - b);</span><br><span class="line">        System.out.println(Math.min(d - a % d, d - b % d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;求最小的 $k$，使得 $gcd(a+k,b+k)$ 的值最大。&lt;/p&gt;
&lt;p&gt;$1&#92;le a&#92;lt b&#92;le 10^{18</summary>
      
    
    
    
    <category term="竞赛题解" scheme="https://whz0325.github.io/categories/%E7%AB%9E%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="数论" scheme="https://whz0325.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>3月做题记录</title>
    <link href="https://whz0325.github.io/2023-03-22/"/>
    <id>https://whz0325.github.io/2023-03-22/</id>
    <published>2023-03-22T05:45:00.000Z</published>
    <updated>2023-04-02T06:26:39.132Z</updated>
    
    <content type="html"><![CDATA[<h5 id="【HAOI-2009】逆序对数列"><a href="#【HAOI-2009】逆序对数列" class="headerlink" title="【HAOI 2009】逆序对数列"></a>【HAOI 2009】逆序对数列</h5><p>看到 DP 的标签还挺好想的，用前缀和优化一下转移就可以 $O(n^2)$ 了，老年选手一开始把 $i$ 插入后最多产生的逆序对数错算成 $i$ 了（应该是 $i-1$ 嘛），WA 了一发……TAT</p><h5 id="【HEOI-2015】兔子与樱花"><a href="#【HEOI-2015】兔子与樱花" class="headerlink" title="【HEOI 2015】兔子与樱花"></a>【HEOI 2015】兔子与樱花</h5><p>退化了，看了以前的题解，每个点被删除的代价是它的樱花值与其没有没删除的子节点个数之和，当然删除一个子节点后父节点的代价除了要加上子节点的代价外还要减去这个子节点贡献给子节点个数的代价 $1$，每个节点被删去的奖励相同，那么就选所有子节点中代价最小的节点优先删去就好了。</p><h5 id="【UVa-120】Stacks-of-Flapjacks"><a href="#【UVa-120】Stacks-of-Flapjacks" class="headerlink" title="【UVa 120】Stacks of Flapjacks"></a>【UVa 120】Stacks of Flapjacks</h5><p>《入门经典》上的题，本来想练 Java 的结果不小心写了 C++，又用 Java 交了一发。</p><p><code>sscanf</code> 中用 <code>%n</code> 获取偏移量，需要累加，<code>fgets</code> 用来读取整行。</p><h5 id="【UVa-1605】Building-for-UN"><a href="#【UVa-1605】Building-for-UN" class="headerlink" title="【UVa 1605】Building for UN"></a>【UVa 1605】Building for UN</h5><p>用来练 Java，居然是多组数据……</p><h5 id="【UVa-1152】Values-whose-Sum-is-0"><a href="#【UVa-1152】Values-whose-Sum-is-0" class="headerlink" title="【UVa 1152】Values whose Sum is 0"></a>【UVa 1152】Values whose Sum is 0</h5><p>Java 写的，练 HashMap，注意最后一组数据结尾没有空行。</p><h5 id="蓝桥杯-2022-省赛-A组"><a href="#蓝桥杯-2022-省赛-A组" class="headerlink" title="蓝桥杯 2022 省赛 A组"></a>蓝桥杯 2022 省赛 A组</h5><p>感觉自己确实老了，有点训练价值的两题写了题解，求逆元可以用 $x^{p-2}$ 快速幂求（模数为质数，欧拉定理），Java 递归层数多了会爆栈，并查集要用非递归写。</p><h5 id="【HAOI-2008】-糖果传递"><a href="#【HAOI-2008】-糖果传递" class="headerlink" title="【HAOI 2008】 糖果传递"></a>【HAOI 2008】 糖果传递</h5><p>感觉可能在哪儿做过，$x_i$ 表示 $i$ 向左传递的糖果数，列出方程组，可以把问题转化为使数轴上若干点到 $x_1$ 距离和最小，即 $\sum |x_1+C_i|$ 的形式，这时 $x_1$ 应当取中位数。</p><h5 id="【LG-P1484】种树"><a href="#【LG-P1484】种树" class="headerlink" title="【LG P1484】种树"></a>【LG P1484】种树</h5><p>可能是没见过的思路……用双向链表实现贪心的反悔操作，因为选择两边的点后距离为两边之外的相邻点不能选，与把包含两边点的整体作为一个点影响相同。</p><p>（还有长链剖分的做法，贪心的证明，需要补一份题解。）</p><h5 id="【UVa-11134】Fabled-Rocks"><a href="#【UVa-11134】Fabled-Rocks" class="headerlink" title="【UVa 11134】Fabled Rocks"></a>【UVa 11134】Fabled Rocks</h5><p>一开始想错了，按右端点排序后左端点顺序可能不定，所以应当从左往右一个一个尽可能地填，无法一一对应，话说是不是也可以用并查集优化……</p><h5 id="【UVa-11054】Wine-trading-in-Gergovia"><a href="#【UVa-11054】Wine-trading-in-Gergovia" class="headerlink" title="【UVa 11054】Wine trading in Gergovia"></a>【UVa 11054】Wine trading in Gergovia</h5><p>水题，【HAOI 2008】糖果传递 弱化版。</p><h5 id="Codeforces-Round-860-Div-2"><a href="#Codeforces-Round-860-Div-2" class="headerlink" title="Codeforces Round 860 (Div. 2)"></a>Codeforces Round 860 (Div. 2)</h5><p>最后一分钟交过了第四题，真刺激，虽然打得并不好……明天补题吧……</p><h5 id="【CF-1798E】Multitest-Generator"><a href="#【CF-1798E】Multitest-Generator" class="headerlink" title="【CF 1798E】Multitest Generator"></a>【CF 1798E】Multitest Generator</h5><p>补题，写了题解。</p><h5 id="【CF-1798F】Gifts-from-Grandfather-Ahmed"><a href="#【CF-1798F】Gifts-from-Grandfather-Ahmed" class="headerlink" title="【CF 1798F】Gifts from Grandfather Ahmed"></a>【CF 1798F】Gifts from Grandfather Ahmed</h5><p>没有见过的动态规划，写了题解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;【HAOI-2009】逆序对数列&quot;&gt;&lt;a href=&quot;#【HAOI-2009】逆序对数列&quot; class=&quot;headerlink&quot; title=&quot;【HAOI 2009】逆序对数列&quot;&gt;&lt;/a&gt;【HAOI 2009】逆序对数列&lt;/h5&gt;&lt;p&gt;看到 DP 的标签还挺好想的</summary>
      
    
    
    
    <category term="日志" scheme="https://whz0325.github.io/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>【CSP 2022】聚集方差</title>
    <link href="https://whz0325.github.io/csp-202212-4/"/>
    <id>https://whz0325.github.io/csp-202212-4/</id>
    <published>2023-03-12T11:14:00.000Z</published>
    <updated>2023-03-12T11:49:40.201Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一棵 $n$ 个节点的树，记以节点 $x$ 为根的子树组成集合为 $T(x)$，求 $\sum_{y\in T(x)}\min_{z\in T(x),z\neq y}(a_z-a_y)^2$。</p><p>$2\le n\le 3\times 10^5$，$0\le a_i\le 10^9$。</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>思维难度其实不大，对每个节点开一个集合，树上启发式合并就可以了。</p><p>怎么合并呢？不难发现插入新元素时会影响到的只有与它距离最近的两个节点的贡献，动态维护即可。</p><p>时间复杂度大概是 $O(nlog_2^2n)$。</p><p>题目的坑点在于卡常。</p><p>第一次是用 <code>multiset</code> 实现的，直接卡成 40 分的暴力，后来改成 <code>map</code> 变成 55 分（$a_i$ 值相同的点合并为一个），又优化了一下，把所有二分操作合并为一个才 A 掉。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 300005</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> ll;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">16</span>], *fs = buf, *ft = buf;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fs == ft) ft = (fs = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, <span class="number">1</span>&lt;&lt;<span class="number">16</span>, stdin);</span><br><span class="line">    <span class="keyword">return</span> *fs++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;num)</span> </span>&#123;</span><br><span class="line">    num = <span class="number">0</span>; c = <span class="built_in">gc</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c = <span class="built_in">gc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, a[N], id[N]; ll res[N], ans[N];</span><br><span class="line">std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; s[N];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; son[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getDist</span><span class="params">(<span class="type">int</span> o, std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[o].<span class="built_in">size</span>() == <span class="number">1</span> || it-&gt;second &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = INT_MAX, x = it-&gt;first;</span><br><span class="line">    <span class="keyword">if</span>(it != s[o].<span class="built_in">begin</span>()) &#123;</span><br><span class="line">        --it;</span><br><span class="line">        ans = std::<span class="built_in">min</span>(ans, <span class="built_in">abs</span>(x - it-&gt;first));</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((++it) != s[o].<span class="built_in">end</span>()) ans = std::<span class="built_in">min</span>(ans, <span class="built_in">abs</span>(x - it-&gt;first));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[y].<span class="built_in">size</span>() &gt; s[x].<span class="built_in">size</span>()) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">    std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span>(it = s[y].<span class="built_in">begin</span>(); it != s[y].<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it0 = s[x].<span class="built_in">lower_bound</span>(it-&gt;first);</span><br><span class="line">        <span class="keyword">if</span>(it0 != s[x].<span class="built_in">end</span>() &amp;&amp; it0-&gt;first == it-&gt;first) &#123;</span><br><span class="line">            <span class="type">int</span> oldDist = <span class="built_in">getDist</span>(x, it0);</span><br><span class="line">            res[x] -= (ll)oldDist * oldDist;</span><br><span class="line">            s[x][it-&gt;first] += it-&gt;second;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> nearest = it-&gt;second &gt; <span class="number">1</span> ? <span class="number">0</span> : INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(it0 != s[x].<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> newDist = <span class="built_in">abs</span>(it-&gt;first - it0-&gt;first);</span><br><span class="line">            <span class="keyword">if</span>(s[x][it0-&gt;first] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> oldDist = <span class="built_in">getDist</span>(x, it0);</span><br><span class="line">                <span class="keyword">if</span>(s[x].<span class="built_in">size</span>() == <span class="number">1</span> || oldDist &gt; newDist) &#123;</span><br><span class="line">                    res[x] -= (ll)oldDist * oldDist;</span><br><span class="line">                    res[x] += (ll)newDist * newDist;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nearest = std::<span class="built_in">min</span>(nearest, newDist);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(it0 != s[x].<span class="built_in">begin</span>()) &#123;</span><br><span class="line">            --it0;</span><br><span class="line">            <span class="type">int</span> newDist = <span class="built_in">abs</span>(it-&gt;first - it0-&gt;first);</span><br><span class="line">            <span class="keyword">if</span>(s[x][it0-&gt;first] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> oldDist = <span class="built_in">getDist</span>(x, it0);</span><br><span class="line">                <span class="keyword">if</span>(s[x].<span class="built_in">size</span>() == <span class="number">1</span> || oldDist &gt; newDist) &#123;</span><br><span class="line">                    res[x] -= (ll)oldDist * oldDist;</span><br><span class="line">                    res[x] += (ll)newDist * newDist;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nearest = std::<span class="built_in">min</span>(nearest, newDist);</span><br><span class="line">        &#125;</span><br><span class="line">        res[x] += (ll)nearest * nearest;</span><br><span class="line">        s[x][it-&gt;first] += it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    ans[x] = <span class="number">0</span>; ++s[x][a[x]]; id[x] = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, end = son[x].<span class="built_in">size</span>(); i &lt; end; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> v = son[x][i];</span><br><span class="line">        <span class="built_in">calc</span>(v);</span><br><span class="line">        id[x] = <span class="built_in">merge</span>(id[x], id[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    ans[x] = res[id[x]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> p; <span class="built_in">read</span>(p);</span><br><span class="line">        son[p].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">calc</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给你一棵 $n$ 个节点的树，记以节点 $x$ 为根的子树组成集合为 $T(x)$，求 $&#92;sum_{y&#92;in T(x)}&#92;</summary>
      
    
    
    
    <category term="竞赛题解" scheme="https://whz0325.github.io/categories/%E7%AB%9E%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="启发式合并" scheme="https://whz0325.github.io/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>【POJ 1064】Cable master</title>
    <link href="https://whz0325.github.io/poj-1064/"/>
    <id>https://whz0325.github.io/poj-1064/</id>
    <published>2023-03-08T02:20:00.000Z</published>
    <updated>2023-03-08T05:35:35.730Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定 $n$ 条长度分别为 $a_i$ 的绳子，求切出 $k$ 条完整绳子的最大长度。</p><p>$1\le n\le 10^4$，$1\le k\le 10^4$，$a_i$ 有两位小数。</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>二分答案，在长度为 $d$ 时能切出 $k$ 条完整的绳子显然在长度小于 $d$ 时也能做到，答案具有单调性。</p><p>重点是实现时考虑浮点运算精度问题，刚开始注意到 <code>printf</code> 在保留位数是会自动四舍五入，为了得到舍掉两位小数后的全部低位，在结果最后额外减去了 $0.005$，然而依然有浮点误差。</p><p>索性用整数实现，很快就解决了hhh，详细见代码。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>C++ 实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10005</span></span><br><span class="line"><span class="type">int</span> n,k,a[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i) cnt+=a[i]/d;</span><br><span class="line">    <span class="keyword">return</span> cnt&gt;=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i) &#123;<span class="type">double</span> d;<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;d);r=std::<span class="built_in">max</span>(r,a[i]=d*<span class="number">100</span>);&#125;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r) &#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r<span class="number">+1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l=mid;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d.%02d\n&quot;</span>,l/<span class="number">100</span>,l%<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> n, k;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> d)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) cnt += a[i] / d;</span><br><span class="line">        <span class="keyword">return</span> cnt &gt;= k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        n = in.nextInt();</span><br><span class="line">        k = in.nextInt();</span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> in.nextDouble();</span><br><span class="line">            a[i] = (<span class="type">int</span>)(<span class="number">100.0</span> * d);</span><br><span class="line">            r = Math.max(r, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(mid)) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%d.%02d\n&quot;</span>,l / <span class="number">100</span>, l % <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定 $n$ 条长度分别为 $a_i$ 的绳子，求切出 $k$ 条完整绳子的最大长度。&lt;/p&gt;
&lt;p&gt;$1&#92;le n&#92;le </summary>
      
    
    
    
    <category term="竞赛题解" scheme="https://whz0325.github.io/categories/%E7%AB%9E%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="二分法" scheme="https://whz0325.github.io/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>如何在 macOS 下配置 Sublime Text 的可交互 Java 环境</title>
    <link href="https://whz0325.github.io/sublime-text-runs-java-on-macos/"/>
    <id>https://whz0325.github.io/sublime-text-runs-java-on-macos/</id>
    <published>2023-01-24T16:59:00.000Z</published>
    <updated>2023-04-07T09:41:43.073Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>因为报名了某个用到 Java 语言的程序设计竞赛，就想配置一个像之前用 C++ 时那样的 Sublime Text 快速编程环境，网上没有找到详细又简单的解决方案，于是花了些时间自己尝试了一个有些简陋的实现。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p><img src="/../images/upload/sublime-text-runs-java-on-macos/1.png"></p><p>在 Sublime Text 3 中新建 Build System，命名为 <code>Java Terminal.sublime-build</code>，写入如下配置：</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;cmd&quot;</span>: [<span class="string">&quot;zsh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;javac &#x27;<span class="variable">$&#123;file_name&#125;</span>&#x27;&quot;</span>],</span><br><span class="line">    <span class="string">&quot;file_regex&quot;</span>: <span class="string">&quot;^(...*?):([0-9]*):?([0-9]*)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;selector&quot;</span>: <span class="string">&quot;source.java&quot;</span>,</span><br><span class="line">    <span class="string">&quot;variants&quot;</span>:</span><br><span class="line">    [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Run&quot;</span>,</span><br><span class="line">            <span class="string">&quot;shell&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&quot;cmd&quot;</span>: [<span class="string">&quot;echo \&quot;</span>clear &amp;&amp; cd <span class="string">&#x27;<span class="variable">$&#123;file_path&#125;</span>&#x27;</span> &amp;&amp; javac <span class="string">&#x27;<span class="variable">$&#123;file_name&#125;</span>&#x27;</span> &amp;&amp; java <span class="string">&#x27;<span class="variable">$&#123;file_base_name&#125;</span>&#x27;</span> &amp;&amp; rm run.sh\<span class="string">&quot; &gt; run.sh &amp;&amp; chmod ugo+x run.sh &amp;&amp; open -a Terminal.app ./run.sh&quot;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/upload/sublime-text-runs-java-on-macos/2.png"></p><p>保存后即可用 <code>Command+B</code> 选取 <code>Java Terminal - Run</code> 运行测试。</p><p><img src="/../images/upload/sublime-text-runs-java-on-macos/3.png"></p><p>对 macOS 下的一些参数不是很了解，所以这里的实现思路为：</p><ul><li>将要执行的命令写入 <code>run.sh</code>。</li><li>调用 Terminal 运行 <code>run.sh</code>。</li><li>在 <code>run.sh</code> 中执行 <code>javac</code> 和 <code>java</code> 命令，在程序执行完毕后删除 <code>run.sh</code>。</li></ul><p>撒花！🎉</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>又熬夜了。。。</p><p>另：修改了调用文件路径和文件名的格式防止出现存放在某些包含空格的路径就会出错的问题。</p><p>另：在 <code>run.sh</code> 中增加了一行清屏来屏蔽输入前产生的杂乱信息。</p><p>或许使用 FastOlympaidCoding 会更方便一些……【2023.4.7 17:39:00】</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;因为报名了某个用到 Java 语言的程序设计竞赛，就想配置一个像之前用 C++ 时那样的 Sublime Text 快速编程环境，网上没有找</summary>
      
    
    
    
    <category term="日志" scheme="https://whz0325.github.io/categories/%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="Java" scheme="https://whz0325.github.io/tags/Java/"/>
    
    <category term="macOS" scheme="https://whz0325.github.io/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>在 macOS 系统中移除 Nix</title>
    <link href="https://whz0325.github.io/remove-nix-from-macos/"/>
    <id>https://whz0325.github.io/remove-nix-from-macos/</id>
    <published>2023-01-20T11:54:00.000Z</published>
    <updated>2023-01-20T12:49:53.977Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这两天想安装 Nix 用于处理一个转 midi 的程序，结果由于网络问题没完全安装成，卸载的过程比较艰难所以记录一下。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>在 <a href="https://github.com/NixOS/nix/issues/458">GitHub</a> 上找到了一个相关问题，链接到了一个<a href="https://iohk.zendesk.com/hc/en-us/articles/4415830650265-Uninstall-nix-on-MacOS">一年前的教程</a>，虽然有点复杂，但是打算参照这个教程试试看。</p><p>第一步，前往 <code>/etc/</code> 这个目录，可以看到存在教程中提到的 <code>zshrc.backup-before-nix</code> 和 <code>bashrc.backup-before-nix</code> 两个文件，直接用它们覆盖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> /etc/zshrc.backup-before-nix /etc/zshrc</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> /etc/bashrc.backup-before-nix /etc/bashrc</span><br></pre></td></tr></table></figure><p>第二步，在终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vifs</span><br></pre></td></tr></table></figure><p>可以看到注释下面有一行与 Nix 相关，直接在 Vim 删去（$6$ 是行号）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:6d</span><br></pre></td></tr></table></figure><p>第三步，打开 <code>/etc/synthetic.conf</code>，里面只有一行，与 Nix 相关，按照教程直接删去：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> /etc/synthetic.conf</span><br></pre></td></tr></table></figure><p>第四步，与教程略有不同，可能是我没安装完全的缘故，前往 <code>/Library/LaunchDaemons</code> 目录（注意比教程中多了个 <code>s</code>），看到有一个 <code>org.nixos</code> 开头的列表项，删除它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> launchctl unload /Library/LaunchDaemons/org.nixos.xxx.plist</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> /Library/LaunchDaemons/org.nixos.xxx.plist</span><br></pre></td></tr></table></figure><p>第五步，复制命令，移除所有相关文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /etc/nix /var/root/.nix-profile /var/root/.nix-defexpr /var/root/.nix-channels ~/.nix-profile ~/.nix-defexpr ~/.nix-channels</span><br></pre></td></tr></table></figure><p>第六步，继续在终端中复制命令执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dscl . delete /Groups/nixbld</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">seq</span> 1 32); <span class="keyword">do</span> <span class="built_in">sudo</span> dscl . -delete /Users/_nixbld<span class="variable">$i</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>最后一步，与教程中有所不同，参考 GitHub 上的方案，先重新启动，再执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> diskutil apfs deleteVolume /Volumes/Nix\ Store</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /nix/</span><br></pre></td></tr></table></figure><p>重新启动，撒花！🎉</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>必应 yyds！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这两天想安装 Nix 用于处理一个转 midi 的程序，结果由于网络问题没完全安装成，卸载的过程比较艰难所以记录一下。&lt;/p&gt;
&lt;h3 id</summary>
      
    
    
    
    <category term="日志" scheme="https://whz0325.github.io/categories/%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="macOS" scheme="https://whz0325.github.io/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>Java 语法笔记</title>
    <link href="https://whz0325.github.io/java-notes/"/>
    <id>https://whz0325.github.io/java-notes/</id>
    <published>2023-01-11T06:32:06.000Z</published>
    <updated>2023-06-11T04:48:10.368Z</updated>
    
    <content type="html"><![CDATA[<h3 id="版本问题"><a href="#版本问题" class="headerlink" title="版本问题"></a>版本问题</h3><p>写这篇笔记时 Oracle 官网上的最新的 JDK 版本是 Java 19，兼容 Apple Silicon，然而目前最常用的 Java 8 和 Java 11 还没有适配，可以使用 Zulu JDK，关于如何配置 Sublime Text 3 快速编写简单的 Java 程序可以参考 <a href="../sublime-text-runs-java-on-macos">如何在 macOS 下配置 Sublime Text 的可交互 Java 环境</a>，集成开发环境推荐 IntelliJ IDEA。</p><h3 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h3><p>过程：代码编译成字节码（可以在 Java CPU 上运行），经 JVM 再转变为机器指令。</p><p>编译：<code>javac file_name.java</code></p><p>运行：<code>java file_name</code></p><p>打包：<code>jar cvf file_name.jar *.*</code></p><p>注意：一个文件只能有一个 <code>public class</code>，且类名与文件名一致。</p><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><h5 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;<span class="comment">//注意分号</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(in.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>in.next()</code>：读入一个字符串。</p><p><code>in.nextLine()</code>：读入一行，返回一个字符串。</p><p>可以使用 <code>hasNextInt()</code> 等方法来预判（以通过 <code>while</code> 循环读取任意数量的数据）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">if</span>(in.hasNextInt()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            System.out.printf(<span class="string">&quot;The next integer is %d.\n&quot;</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> System.out.println(<span class="string">&quot;The next integer does not exist.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">3.14</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">The next integer does not exist.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">The next integer is 3.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="快读"><a href="#快读" class="headerlink" title="快读"></a>快读</h5><p>关于字节流和字符流相关：待填坑。（StreamTokenizer）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(in.readLine());<span class="comment">// read() 方法读取字符</span></span><br><span class="line">        out.write(n.toString());<span class="comment">// 可以使用 String.format(&quot;&quot;) 方法</span></span><br><span class="line">        out.newLine();</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>导入 <code>java.io.*</code>，主函数 <code>throws IOException</code>。</li><li><code>BufferedReader</code> 和 <code>BufferedWriter</code> 使用 <code>InputStreamReader</code> 和 <code>OutputStreamWriter</code> 初始化。</li><li>输出后刷新缓冲区 <code>flush()</code>。</li></ul><p>【Kattio】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Kattio</span> <span class="keyword">extends</span> <span class="title class_">PrintWriter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader bf;</span><br><span class="line">    <span class="keyword">private</span> StringTokenizer st;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Kattio</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(System.out);</span><br><span class="line">        bf = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(st == <span class="literal">null</span> || !st.hasMoreTokens()) &#123;</span><br><span class="line">                st = <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(bf.readLine());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> st.nextToken();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span> &#123; <span class="keyword">return</span> Integer.parseInt(next()); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意程序结束时需要执行 <code>io.close()</code>。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h5 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h5><ul><li>不能以数字开头，可以包含 <code>_</code> 和 <code>$</code>。</li><li>函数、变量采用峰驼命名法，类、接口首字母大写，常量全部大写。</li></ul><h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><p>常量使用 <code>final</code> 修饰。（final 方法不允许重写，final 类不允许继承）</p><p>基本数据类型（如 <code>int</code>、<code>double</code>）及强制类型转换，语法与 C++ 类似，但布尔类型的关键字为 <code>boolean</code>。</p><ul><li>整数常量默认 int，long 类型是 10000000L。</li><li>浮点常量默认 double，float 类型是 3.14F。</li><li>使用 Unicode 码，字符类型 char 为 16 位（0~65536）。</li><li>空：<code>null</code></li><li><code>&amp;</code> 和 <code>|</code> 等在 Java 中也可以用于逻辑运算，不过不短路。</li><li><code>+</code> 可以连接字符串。</li></ul><p>分为基本数据类型和引用数据类型。</p><ul><li>数组是引用数据类型，不是基本数据类型。</li><li>对于引用类型，<code>==</code> 比较指向相同，<code>equals()</code> 比较内容相同。</li><li>基本类型放在栈中，引用类型放在堆中。</li><li>Java 只有值传递，引用类型存放的是其指向（指针），故传递的也是其指向。</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是<strong>引用类型</strong>而非基本数据类型。</p><h5 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h5><p>定义数组：<code>int[] a = new int[100];</code>，数组的元素个数可以为变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) a[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            System.out.print(a[i] + ((i == n - <span class="number">1</span>)?<span class="string">&quot;\n&quot;</span>:<span class="string">&quot; &quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入：10</span></span><br><span class="line"><span class="comment">输出：0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以使用 <code>a.length</code> 访问数组大小，数组中元素默认为 $0$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) a[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; ++i) &#123;</span><br><span class="line">            System.out.print(a[i] + ((i == n - <span class="number">1</span>)?<span class="string">&quot;\n&quot;</span>:<span class="string">&quot; &quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入：10</span></span><br><span class="line"><span class="comment">输出：0 1 2 3 4 0 0 0 0 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>初始化：</p><ul><li><p><code>int[] a = &#123;0, 1, 2, 3, 4, 5&#125;;</code>。</p></li><li><p>初始化：<code>a = new int[]&#123;0, 1, 2, 3, 4, 5&#125;;</code></p></li><li><p>维表达式：<code>a = new int[6];</code></p></li></ul><p>而这样是错误的 <code>a = new int[6]&#123;0, 1, 2, 3, 4, 5&#125;;</code>，不能同时用维表达式和初始化创建数组。</p><h5 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt(), m = in.nextInt();</span><br><span class="line"><span class="comment">/* 使用变量定义二维数组 */</span></span><br><span class="line"><span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, cnt = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">        a[i][j] = cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 使用 for-each 访问二维数组 */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span>[] b: a) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> c: b) &#123;</span><br><span class="line">        System.out.print(c + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化 */</span></span><br><span class="line"><span class="type">int</span>[][] a = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 使用 length 访问二维数组 */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a[i].length; ++j) &#123;</span><br><span class="line">        a[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>允许不规则数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><h5 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h5><p>java.util.Arrays</p><p>数组拷贝：int[] dest &#x3D; Arrays.copyOf(src, src.length)</p><p>数组排序</p><ol><li>引入：<code>import java.util.Arrays;</code></li><li>基本用法：<code>Arrays.sort(a);</code> 对数组 <code>a</code> 进行递增排序。</li><li>时间复杂度：$O(nlog_2n)$。</li><li>指定排序范围：<code>Arrays.sort(a, 0, 5);</code> 对数组 <code>a</code> 的前 6 个元素进行排序。</li><li>自定义排序规则：实现 Comparable 接口，实现 public int compareTo(Object o) 方法；创建实现 Comparator 接口的类，实现 public int compare(Object a, Object b) 方法。</li></ol><p>数组查找：<code>int loc = Arrays.binarySearch(src, element);</code></p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>用法与 C++ 类似。</p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p><code>if</code> 语句和 <code>switch</code> 语句与 C++ 类似。</p><p>就近原则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>()</span><br><span class="line">    <span class="keyword">if</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，第一部分代码中的 <code>else</code> 无视缩进，与第二个 <code>if</code> 形成一组。</p><p><code>switch</code> 语句中的 <code>default</code> 不是必要的。</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p><code>while</code> 语句和 <code>do-while</code> 语句与 C++ 类似。</p><p><code>for</code> 语句与 C++ 类似，可使用 <code>break</code> 语句和 <code>continue</code> 语句，也可以使用 <code>goto</code>。</p><p>类似 <code>for-in</code> 的 <code>for-each</code> 遍历数组元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x: a) &#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，上述代码中改变 <code>x</code> 的值并不会改变原数组中对应项的值（引用类型的数组除外），例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            a[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x: a) &#123;</span><br><span class="line">            x = <span class="number">0</span>;<span class="comment">// 原数组中的值没有被修改</span></span><br><span class="line">            System.out.print(x + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x: a) &#123;</span><br><span class="line">            System.out.print(x + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">0 0 0 0 0 0 0 0 0 0 </span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 6 7 8 9 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>break</code> 和 <code>continue</code> 语句可以给出标号，跳出制定的代码块。</p><h3 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h3><h5 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h5><p>Java 使用 Unicode 编码，用单引号表示字符，可与 <code>int</code> 相互赋值。</p><p>转义字符：<code>\t</code>、<code>\b</code>、<code>\n</code>、<code>\r</code>、<code>\\</code>、<code>\&#39;</code>、<code>\&quot;</code>……</p><h5 id="Wrap-类型"><a href="#Wrap-类型" class="headerlink" title="Wrap 类型"></a>Wrap 类型</h5><p>将基本类型转化为对象，</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首字母大写</span></span><br><span class="line"><span class="keyword">int</span> -&gt; Integer</span><br><span class="line"><span class="keyword">short</span> -&gt; <span class="keyword">Short</span></span><br><span class="line"><span class="keyword">long</span> -&gt; <span class="keyword">Long</span></span><br><span class="line"><span class="keyword">float</span> - &gt; <span class="keyword">Float</span></span><br><span class="line"><span class="keyword">double</span> -&gt; <span class="keyword">Double</span></span><br><span class="line"><span class="keyword">boolean</span> -&gt; <span class="keyword">Boolean</span></span><br><span class="line"><span class="keyword">char</span> -&gt; Charater</span><br><span class="line"><span class="keyword">byte</span> -&gt; <span class="keyword">Byte</span></span><br></pre></td></tr></table></figure><p><code>Integer.parseInt(String s, int radix)</code> 方法可以将字符串转化为整数，<code>radix</code> 参数用于指定基数，默认为 10。</p><p>类似的还有 <code>Long.parseLong(String s)</code>、<code>Double.parseDouble(String s)</code> 等等。</p><h5 id="Integer-类型"><a href="#Integer-类型" class="headerlink" title="Integer 类型"></a>Integer 类型</h5><p>可自由赋值给 int 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">I</span> <span class="operator">=</span> Integer(<span class="number">1024</span>);<span class="comment">// Java 8</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">I</span> <span class="operator">=</span> Integer.valueOf(<span class="number">1024</span>);<span class="comment">// Java 19</span></span><br><span class="line">System.out.println(I);</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> I;</span><br><span class="line">System.out.println(i);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">1024</span></span><br><span class="line"><span class="comment">1024</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">System.out.println(Integer.MIN_VALUE + <span class="string">&quot; &quot;</span> + Integer.MAX_VALUE);</span><br><span class="line"><span class="comment">// 输出：-2147483648 2147483647</span></span><br></pre></td></tr></table></figure><ul><li>成员函数 <code>toString()</code> 和 <code>Integer.toString(int i)</code> 方法可返回整数对应的字符串。</li><li>Integer.MAX_VALUE 返回最大值。</li></ul><h5 id="Character-类型"><a href="#Character-类型" class="headerlink" title="Character 类型"></a>Character 类型</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">System.out.println(Character.isDigit(c));</span><br><span class="line">System.out.println(Character.isLetter(c));</span><br><span class="line">System.out.println(Character.isLetterOrDigit(c));</span><br><span class="line">System.out.println(Character.isLowerCase(c));</span><br><span class="line">System.out.println(Character.isUpperCase(c));</span><br><span class="line">System.out.println(Character.isWhitespace(c));</span><br><span class="line">System.out.println(Character.toLowerCase(c));<span class="comment">// 返回改变后的字符，不改变 c 的值</span></span><br><span class="line">System.out.println(Character.toUpperCase(c));<span class="comment">// 返回改变后的字符，不改变 c 的值</span></span><br></pre></td></tr></table></figure><h5 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h5><p>字符串的连接是从左向右的，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">1</span> + <span class="number">2</span> + <span class="string">&quot;3&quot;</span>);<span class="comment">// 33</span></span><br><span class="line">System.out.println(<span class="string">&quot;1&quot;</span> + <span class="number">2</span> + <span class="number">3</span>);<span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>判断相等时应当使用 <code>s1.equals(s2)</code>，在 Java 中，类的名称类似于指针，使用运算符 <code>==</code> 相当于判断两者是否指向同一对象。</p><p>两种声明方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br></pre></td></tr></table></figure><p>这两种初始化的方式是有所不同的，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">// true</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>可见，使用 <code>new</code> 初始化相同内容的字符串时创建了新的对象，这里用到了 Java 中“常量池”的概念。</p><p>注意：在 Java 中采用值传递而非引用传递。</p><p>一些函数的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* compareTo() 在小于时返回 -1，等于时返回 0，大于时返回 1. */</span></span><br><span class="line"><span class="comment">/* compareToIgnoreCase() 无视大小写 */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;BCD&quot;</span>;</span><br><span class="line">System.out.println(s1.compareTo(s2));<span class="comment">// -1</span></span><br><span class="line"><span class="comment">/* charAt() */</span></span><br><span class="line">System.out.println(s1.charAt(<span class="number">0</span>));<span class="comment">// A</span></span><br><span class="line"><span class="comment">/* substring() */</span></span><br><span class="line">System.out.println(s1.substring(<span class="number">1</span>));<span class="comment">// BC</span></span><br><span class="line"><span class="comment">/* 区间左闭右开 */</span></span><br><span class="line">System.out.println(s1.substring(<span class="number">0</span>, <span class="number">2</span>));<span class="comment">// AB</span></span><br><span class="line"><span class="comment">/* indexOf() 不存在返回 -1 */</span></span><br><span class="line">System.out.println(s1.indexOf(<span class="string">&#x27;B&#x27;</span>));<span class="comment">// 1</span></span><br><span class="line">System.out.println(s1.indexOf(<span class="string">&#x27;Z&#x27;</span>));<span class="comment">// -1</span></span><br><span class="line"><span class="comment">/* 第二个参数表示查找的开始位置 */</span></span><br><span class="line">System.out.println(s1.indexOf(<span class="string">&#x27;A&#x27;</span>, <span class="number">1</span>));<span class="comment">// -1</span></span><br><span class="line"><span class="comment">/* lastIndexOf 用法相同，从字符串末尾开始搜索 */</span></span><br><span class="line"><span class="comment">/* 其它函数 */</span></span><br><span class="line">System.out.println(s1.startsWith(<span class="string">&quot;AB&quot;</span>));<span class="comment">// true</span></span><br><span class="line">System.out.println(s1.endsWith(<span class="string">&quot;BA&quot;</span>));<span class="comment">// true</span></span><br><span class="line"><span class="comment">/* trim() 删去头尾空白符 */</span></span><br><span class="line">s1 = <span class="string">&quot; ABABA &quot;</span>;</span><br><span class="line">System.out.println(s1.trim());<span class="comment">// &quot;ABABA&quot;</span></span><br><span class="line">System.out.println(s1.replace(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>));<span class="comment">// CBCBC</span></span><br><span class="line">System.out.println(s1.toLowerCase());<span class="comment">// ababa</span></span><br><span class="line"><span class="comment">/* 执行 toLowerCase() 和 toUpperCase() 不改变原字符串的内容 */</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> in.next();</span><br><span class="line"><span class="keyword">switch</span>(s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Happy&quot;</span>: System.out.println(<span class="string">&quot;You are happy.&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Sad&quot;</span>: System.out.println(<span class="string">&quot;You are sad.&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另：可使用 <code>indexOf</code> 进行字符串查找，内部实现为嵌套循环的朴素算法，时间复杂度为 $O(nm)$，但只能返回一个位置，却可以指定查找的起始位置来实现连续查找。</p><p>未初始化的 String 不能调用 <code>length()</code> 方法，而初始化为 <code>&quot;&quot;</code> 的 String 调用 <code>length()</code> 会返回数字 0。</p><p><code>split</code> 方法可以对字符串进行拆分，得到拆分后的字符串数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line">        String s[] = str.split(<span class="string">&quot; &quot;</span>);<span class="comment">// 也可以使用 &quot;,&quot; 作为分隔符</span></span><br><span class="line">        <span class="keyword">for</span>(String ss: s) &#123;</span><br><span class="line">            System.out.println(ss);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">Hello World Java Programming File</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">Hello</span></span><br><span class="line"><span class="comment">World</span></span><br><span class="line"><span class="comment">Java</span></span><br><span class="line"><span class="comment">Programming</span></span><br><span class="line"><span class="comment">File</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>format</code> 方法可以获得格式化的字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> in.nextDouble();<span class="comment">// 3.1415926</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.format(<span class="string">&quot;Double Value is %.7f\n&quot;</span>,d);<span class="comment">// Double Value is 3.1415926</span></span><br><span class="line">        System.out.print(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（Java 中 <code>float</code> 类型和 <code>double</code> 类型变量都使用 <code>%f</code> 表示，<code>byte</code> 类型、<code>short</code> 类型、<code>int</code> 类型、<code>long</code> 类型都使用 <code>%d</code> 表示）</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>只能按值传递。</p><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>public enum Name { TYPE1, TYPE2, TYPE3 };</p><p>Name name &#x3D; TYPE1 or Name.TYPE1</p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>继承性，封装性，多态性。</p><p><code>Type object = new Type();</code>：</p><ul><li><code>Type object</code>：声明</li><li><code>new</code>：实例化</li><li><code>Type()</code>：初始化</li></ul><p>没有析构函数，自动垃圾回收（GC，Garbage Collection）。【<code>finilize()</code> 被 Java 9 弃用】</p><p>耦合性（依赖关系）与可扩展性：硬编码 -&gt; 框架+数据。</p><p>注意：类的赋值语句并不是对象赋值，而是改变变量管理的对象。</p><h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><p>调用成员函数时可以直接使用成员变量名或成员函数名，可不使用 <code>this</code> 指定（若与成员函数某个参数重名则须要指定），<code>this</code> 像指针一样管理着调用成员函数的对象（就像一个快捷方式 ）。  </p><p>成员变量会被给予初始值 $0$，与本地变量（函数中的变量）不同，本地变量不被赋值就使用则编译失败。</p><p>创建对象的时候会对所有变量依次初始化，然后调用构造函数（如果存在的话），若有多个构造函数则调用与 <code>new</code> 时参数对应的构造函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;<span class="comment">// 0</span></span><br><span class="line">    test() &#123;&#125;<span class="comment">// 构造函数，使用类名，没有返回类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        System.out.println(x);<span class="comment">// 1</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.x);<span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">test</span>();t.f(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在构造函数中使用 <code>this</code> 调用其它构造函数，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    int x;</span><br><span class="line">    <span class="title function_">test</span>(<span class="params"></span>) &#123;<span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;test&quot;</span>);&#125;</span><br><span class="line">    <span class="title function_">test</span>(<span class="params">int x</span>) &#123;</span><br><span class="line">        <span class="title function_">this</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        test t = <span class="keyword">new</span> <span class="title function_">test</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是 <code>this()</code> 只能作为该构造函数的第一个语句，否则就会报错：</p><p><img src="/../images/upload/java-notes/error0.png"></p><h5 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h5><p>public 属性：<code>public</code> 关键字修饰的类必须在它自己的 <code>java</code> 文件中，即文件名与类名相同。【同一个类，同一个包，子类，不同类不同包非子类】</p><p>protected 属性：<code>protected</code> 关键字保证包内的类和子类可以访问。【同一个类，同一个包，子类】</p><p>default 属性：默认属性，仅可以在<strong>同一个包内</strong>访问。【同一个类、同一个包】</p><p>private 属性：<code>private</code> 关键字只适用于成员变量和成员函数，仅类中可使用，在<strong>类外实例化的对象不可访问</strong>（但对于同一个类的私有成员变量，只要代码写在类中，两个不同的对象之间可以相互访问）。【仅同一个类】</p><h5 id="package-包"><a href="#package-包" class="headerlink" title="package 包"></a>package 包</h5><ul><li>包与目录对应，可以嵌套子目录：<code>package parent.child</code>。</li><li>开头添加 <code>package package_name;</code> 表明文件属于这个包，使用小写，且只有一条</li><li>成员变量、成员函数和类前没有 <code>private</code> 或 <code>public</code> 关键字，则意味着它仅可以在同一个包内访问。</li><li><code>import java.lang.*;</code> 默认添加，无需指明。</li><li>导入其它包内声明的类：<code>import package_name.class_name;</code>，不选择导入则需要使用 <code>package_name.class_name</code> 作为全名调用包外的类，<code>import package_name.*;</code> 表明导入包内的所有内容。</li></ul><h5 id="static-属性"><a href="#static-属性" class="headerlink" title="static 属性"></a>static 属性</h5><p>最先初始化。</p><p>同一个类的类（静态）变量为所有对象共有，可以使用 <code>object_name.var_name</code> 也可以使用 <code>class_name.var_name</code> 访问，可以称为类变量。</p><p>静态函数（用 <code>static</code> 修饰的属性的函数）与静态变量类似，静态函数只能访问类（静态）变量，不能访问成员变量（因为静态函数属于这个类，而成员变量属于一个特定的对象）。</p><h5 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h5><p>如 <code>ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;();</code>，声明 String 类型的容器，否则默认是 Object 类型。</p><p>定义：<code>class A&lt;E&gt; &#123; E e; &#125;</code>（如 HashSet）、<code>class B&lt;X, Y&gt; &#123; X x; Y y; &#125;</code>（如 HashMap）。</p><p>接口中也可以定义泛型</p><?> `<? extends T>` `<? super T>`<font color="red">注意：Java 中泛型只能是引用类型（如 `Integer`），不能是基本类型（如 `int`）。</font>##### 类数组1. 基本数据类型的数组中存放数据，类数组中存放管理数据用的“指针”（初始为 `null`）。2. 对于类数组，修改 `for-each` 语句中 `x` 的值将会影响原数组中的值，例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">I</span> &#123;<span class="comment">// 须要写在外面</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> i;</span><br><span class="line">    I(<span class="type">int</span> i) &#123;</span><br><span class="line">        <span class="built_in">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        I[] a = <span class="keyword">new</span> <span class="title class_">I</span>[<span class="number">10</span>];<span class="comment">// 初始化：第一步</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            a[i] = <span class="keyword">new</span> <span class="title class_">I</span>(i);<span class="comment">// 初始化：第二步</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(I x: a) &#123;</span><br><span class="line">            System.out.print(x.i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            x.i = <span class="number">0</span>;<span class="comment">// 原数组中的值被修改了</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span>(I x: a) &#123;</span><br><span class="line">            System.out.print(x.i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 6 7 8 9 </span></span><br><span class="line"><span class="comment">0 0 0 0 0 0 0 0 0 0 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>类的对象名仅仅为指向该对象的指针，赋值时也仅仅是指针的赋值，让两者管理同一个对象：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">I</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> i;</span><br><span class="line">    I(<span class="type">int</span> i) &#123;</span><br><span class="line">        <span class="built_in">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">I</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">I</span>(<span class="number">128</span>);</span><br><span class="line">        <span class="type">I</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">I</span>(<span class="number">64</span>);</span><br><span class="line">        b = a;</span><br><span class="line">        a.i = <span class="number">32</span>;</span><br><span class="line">        System.out.println(b.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">32</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>##### 继承（`extends`）final 修饰不允许继承。所有类均默认为 Object 的子类：`toString()`、`equals(Object object)`……继承是为了方便复用代码，避免重复编写代码，不利于维护。如果父类和子类出现重名，则会生成两个变量，不加 `super.` 会默认为当前类的变量或函数。覆盖：子类与父类出现同名函数。<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br></pre></td></tr></table></figure>##### Object 类：`public String toString()`：定义在父类 `Object` 里，在类中重写来改变 `System.out` 时的输出：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>`toString()` 会自动调用，如 `"str" + object` 等同于 `"str" + object.toString()`。`public boolean equals(Object obj)`：定义在父类 `Object` 里，在类中没有重写时调用很大概率返回与预期不符的结果。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;<span class="comment">// 类型必须是 Object</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">object</span> <span class="operator">=</span> (Class)obj;</span><br><span class="line">    <span class="keyword">return</span> element.equals(object.element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>##### 多态子类（动态类型）可以被当作父类（声明类型）使用：如父类容器可以放入继承自同一父类的不同子类的元素、向上造型【向上转型】（`FatherClass object = new ChildClass();`）。特殊：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FatherClass</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChildClass</span>();</span><br><span class="line"><span class="type">ChildClass</span> <span class="variable">newObject</span> <span class="operator">=</span> (ChildClass)object;<span class="comment">// 需要造型（没有被转换）成子类</span></span><br></pre></td></tr></table></figure>造型：当作…来看待；转换：变更。**动态绑定**：“动态”是“运行时”绑定的意思。尽管声明类型不同，调用时还是会调用**动态类型**的函数。**变量与函数不同，使用的是静态类型的变量，只能封装为函数访问动态类型的变量 getXXX()**object instanceof Class：是其或其子类的对象##### 构造函数执行顺序：变量初始化 -> 父类构造函数 -> 当前类构造函数。调用父类构造函数：`super(items)`，如果不写的话在执行子类构造函数时会**默认执行父类不带参数的构造函数**（不存在则报错）。##### super 和 this- 如果调用 super() 和 this() 都必须作为第一语句，因此两者不能同时出现。- 子类中出现与父类同名变量用 super 区分。##### 抽象 (abstract)- 含有抽象函数 `abstruct func` 的一定是抽象类 `abstract class`。- 继承自抽象类就要实现其所有抽象方法。- 构造方法、static 方法、final 方法不能定义为抽象函数。注：这里的“抽象”表示的含义是不具体，面向对象中另一种“抽象“的含义是封装使看不到底层细节。final 类的方法都是 final 方法，因为不能继承自然就不能被重写。final 方法可以提高执行效率。final 变量可以先定义，随后初始化。抽象类允许有 private 成员，但其抽象函数不能同时用 abstract 和 private/final/static 修饰。##### 接口（interface）纯抽象类接口内的只有 public static final 常量，无需指明，必须初始化。只有 public abstract 方法，无需指明。接口不能实现 implements 接口，只能继承 extends 接口（可以继承多个）。可以直接使用接口的常量 Interface.constant. 常量可以用 Math.random() 初始化。##### 内部类内部类：需要先有外部类的对象。**out_object.new**，`Out.this`<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Out</span> &#123; <span class="keyword">class</span> <span class="title class_">In</span> &#123; &#125; &#125;</span><br><span class="line"><span class="type">Out</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Out</span>();</span><br><span class="line">Out.<span class="type">In</span> <span class="variable">in</span> <span class="operator">=</span> out.<span class="keyword">new</span> <span class="title class_">In</span>();</span><br></pre></td></tr></table></figure>静态类：嵌套类。局部内部类：可以访问外部。匿名内部类：`new superclass_or_interface() {}`，传递排序规则时经常用到，若继承的父类只有含参构造函数则在参数列表中指明。##### 重载（Overload）参数列表不同的同名函数，返回值等均不能用于区分。多个构造函数也叫重载##### 重写（Override）- 名称、参数、返回值必须相同。- 子类重写的访问控制只能更宽松。- 与 C++ 不同，默认类似虚函数，无论静态类型一律调用动态类型的方法。### 输入输出InputStream OutputStream：字节流Reader/Writer：字符流FileInputStream/FileOutputStreamBuffered：缓冲流PrintStream/PrintWriter：打印流DataInputStream/DataOutputStream：数据流ObjectInputStream/ObjectOutputStream：对象流### GUIAWT（Abstract Window Toolkit）重量级组件Swing 轻量级组件SWT（Standard Widget Toolkit）Container 与 Component，Component 父类，Container 容纳 Component。### 多线程1. implements Runnable public void run() {} Thread thread = new Thread(ClassName) 同一实例的多个进程2. extends Thread public void run() {} Thread thread = new ClassName() 多个实例getPriority() setPriority(int) 1-10, 5 is normalsynchronized 放在函数前sychronized(object) {}wait() notify()### 数据库Structure Query Languagecreate table namedrop table nameselect xxx from xxxinsert into xxxupdate xxxdelete from xxx### 网络编程import java.net.*;<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getLocalHost</span><br><span class="line"></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getByName</span><br><span class="line"></span><br><span class="line">address.getHostName</span><br><span class="line"></span><br><span class="line">address.getHostAddress</span><br></pre></td></tr></table></figure>ServerSocket()(int port)Socket accept()close()Socket()(String host, int port)(InetAddress address, int port)close() getInputStream getOutputStream### 异常处理异常（Exception）和错误（Error）不受检异常（Unchecked Exception）：Runtime Exception/Error……受检异常（Checked Exception）：IOException/FileNotFoundException……<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(<span class="built_in">Exception</span> e) &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>throws 让上一级处理- `getMessage()`- `printStackTrace()`- `toString()`：返回异常名与 `getMessage()` 的信息。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>) throws Exception</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    CustomException() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getMessage() + <span class="string">&quot; and &quot;</span> + <span class="string">&quot;getMessage()&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> CustomException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(e);</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="literal">null</span>, e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Final&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">init()</span></span><br><span class="line"><span class="comment">CustomException: null and getMessage()</span></span><br><span class="line"><span class="comment">Final</span></span><br><span class="line"><span class="comment">Hello world!</span></span><br><span class="line"><span class="comment">CustomException: null and getMessage()</span></span><br><span class="line"><span class="comment">    at Main.test(Main.java:16)</span></span><br><span class="line"><span class="comment">    at Main.main(Main.java:20)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>### 常用库/函数##### Math- 常数：`Math.PI`，`Math.E`.- 绝对值：`Math.abs(int/long/double var)`- 转整数：`Math.ceil(double var)`（上界），`Math.floor(double var)`（下界），`Math.rint(double var)`（最接近）。- 四舍五入：`Math.round(double var)`。- 比较：`Math.max(a, b)`，`Math.min(a, b)`。- 数学：`exp()`、`log()`、`pow()`、`sqrt()`、`sin()`、`cos()`、`tan()`、`asin()`、`acos()`、`atan()`。- 笛卡尔坐标转极坐标：`atan2()`。- 随机数：`Math.random()` 得到一个 $[0,1)$ 的随机数。##### 系统信息<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">System.getProperty(<span class="string">&quot;java.version&quot;</span>);</span><br></pre></td></tr></table></figure>##### 时间统计`System.currentTimeMillis()` 作差可得代码段的运行时间（以毫秒为单位）。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 第一种方式 */</span></span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line"><span class="type">long</span> <span class="variable">st</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">    out.write(String.format(<span class="string">&quot;%d\n&quot;</span>, (<span class="type">int</span>)(Math.random() * <span class="number">100000</span>)));</span><br><span class="line">&#125;</span><br><span class="line">out.flush();</span><br><span class="line"><span class="type">long</span> <span class="variable">et</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(et - st);<span class="comment">// 1117 ms</span></span><br><span class="line"><span class="comment">/* 第二种方式 */</span></span><br><span class="line"><span class="type">long</span> <span class="variable">st</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">    System.out.println((<span class="type">int</span>)(Math.random() * <span class="number">100000</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">et</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(et - st);<span class="comment">// 2240 ms</span></span><br></pre></td></tr></table></figure>##### Random<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">r.nextInt();</span><br><span class="line">r.nextInt(<span class="number">10</span>);</span><br><span class="line">r.nextDouble();</span><br></pre></td></tr></table></figure>##### Date- 头文件：`import java.util.Date;`- `long getTime()` 返回 1970.1.1 00:00:00 过去的秒数。- `setTime(long)` 设置 1970.1.1 00:00:00 过去的秒数。##### Calendar- 头文件：`import java.util.Calendar;`- 初始化：`Calendar cal = Calendar.getInstance();`- 设置日期（年月日）：`cal.set(year, month, day)`。- 设置日期（设置一项）：`cal.set(Calendar.YEAR, 2023)`。- 修改日期：`cal.add(Calendar.YEAR, -10)`- 获取日期：`cal.get(Calendar.YEAR)`附：- Calendar.YEAR- Calendar.MONTH- Calendar.DATE- Calendar.HOUR_OF_DAY：24小时制- Calendar.MINUTE- Calendar.SECOND- Calendar.DAY_OF_WEEK：星期GregorianCalendar 继承自 Calendar，日期计算很方便。注意：月的范围是 [0, 11]，而非 [1,12]。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.GregorianCalendar;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GregorianCalendar</span> <span class="variable">cal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GregorianCalendar</span>(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">while</span>(cal.get(GregorianCalendar.YEAR) &lt;= <span class="number">2023</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> cal.get(GregorianCalendar.YEAR);</span><br><span class="line">            <span class="keyword">if</span>(cal.isLeapYear(year)) &#123;</span><br><span class="line">                System.out.println(year);</span><br><span class="line">            &#125;</span><br><span class="line">            cal.add(GregorianCalendar.YEAR, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2000</span></span><br><span class="line"><span class="comment">2004</span></span><br><span class="line"><span class="comment">2008</span></span><br><span class="line"><span class="comment">2012</span></span><br><span class="line"><span class="comment">2016</span></span><br><span class="line"><span class="comment">2020</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.GregorianCalendar;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GregorianCalendar</span> <span class="variable">cal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GregorianCalendar</span>(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="type">GregorianCalendar</span> <span class="variable">cal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GregorianCalendar</span>(<span class="number">2000</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println((cal2.getTime().getTime() - cal1.getTime().getTime()) / (<span class="number">1000L</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">29</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>##### 更快的 StringBuilderappend(), insert(), delete(), replace(); charAt();<font color="red">重要：Java 中容器类型只能为 Wrap 类型，不能是基本数据类型。</font>引入：`import java.util.*;`。遍历：`for-each`。##### ArrayList基本用法：- 插入：`add(value)`- 修改：`set(index, value)`- 删除：`remove(index or value)`- 大小：`size()`- 取值：`get(index)`- 转数组：`toArray(newArrayName)`##### LinkedListadd/get/remove + First/Last- `add(value)`，`addFirst`- `removeFirst()`- `getFirst()`、`getLast()`- `peekFirst()`、`peekLast()`##### HashSet特点：无序集合。基本用法：- 插入：`add(value)`- 删除：`remove(value)`- 判断是否存在：`contains(value)`- 大小：`size()`- 清空：`clear()`##### TreeSet特点：有序集合。##### HashMap基本用法：- 插入：`put(key, value)`。- 取值：`get(key)`，不存在返回 `null`。- 判断是否存在：`containsKey(key)`。- 键集合：`keySet()`。- entrySet()- values()- 遍历：`for(KeyType key: hashMap.keySet()) {}`LinkedHashSet/LinkedHashMap##### CollectionssortbinarySearchreversecopyminmax##### PriorityQueue`add(_element_)``peek()``poll()`<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer a, Integer b)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> a &lt; b ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        pq.add(<span class="number">64</span>);</span><br><span class="line">        pq.add(<span class="number">32</span>);</span><br><span class="line">        pq.add(<span class="number">128</span>);</span><br><span class="line">        System.out.println(pq.peek());</span><br><span class="line">        pq.poll();</span><br><span class="line">        System.out.println(pq.peek());</span><br><span class="line">        pq.poll();</span><br><span class="line">        System.out.println(pq.peek());</span><br><span class="line">        pq.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>##### Deque<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();<span class="comment">// 不能接受基本数据类型</span></span><br><span class="line"></span><br><span class="line">System.out.println(dq.size());<span class="comment">// 大小</span></span><br><span class="line"></span><br><span class="line">dq.addLast(<span class="number">512</span>);<span class="comment">// 插入元素，失败返回异常</span></span><br><span class="line">dq.offerLast(<span class="number">1024</span>);<span class="comment">// 插入元素，失败返回 null</span></span><br><span class="line"></span><br><span class="line">System.out.println(dq.getFirst());<span class="comment">// 获取元素，失败返回异常</span></span><br><span class="line">System.out.println(dq.peekLast());<span class="comment">// 获取元素，失败返回 null</span></span><br><span class="line"></span><br><span class="line">System.out.println(dq.removeFirst());<span class="comment">// 删除元素，失败返回异常</span></span><br><span class="line">System.out.println(dq.pollLast());<span class="comment">// 删除元素，失败返回 null</span></span><br></pre></td></tr></table></figure>##### 迭代器<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator&lt;String&gt; it = s.iterator(); s.hasNext(); ) System.out.println(s.next());</span><br></pre></td></tr></table></figure>For-each 只能遍历数组和实现了Iterable接口的实例。##### hashCodepublic int hashCode() { return 123; }##### 排序- Arrays.sort() 用于数组排序，还有 `Collections.sort()`.- 可以指定后两个参数 fromIndex 和 toIndex，左闭右开。- 返回值：负数表示在前，返回零表示相等，返回整数表示在后。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 头文件 */</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/* 数组排序 */</span></span><br><span class="line">Arrays.sort(a);<span class="comment">// 可以加两个参数表示排序区间，左闭右开</span></span><br><span class="line"><span class="comment">/* 自定义排序规则 */</span></span><br><span class="line">Arrays.sort(a, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;typename&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(typename a, typename b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.x == b.x) <span class="keyword">return</span> a.y &lt; b.y ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>对类排序可以实现 Comparable 接口。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;ClassName&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Classname rhs)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;版本问题&quot;&gt;&lt;a href=&quot;#版本问题&quot; class=&quot;headerlink&quot; title=&quot;版本问题&quot;&gt;&lt;/a&gt;版本问题&lt;/h3&gt;&lt;p&gt;写这篇笔记时 Oracle 官网上的最新的 JDK 版本是 Java 19，兼容 Apple Silicon，然而目前最常用</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://whz0325.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://whz0325.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
