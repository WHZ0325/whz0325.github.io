<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WHZ0325&#39;s Space</title>
  
  <subtitle>只有翻过这座山才能让他们听到你的故事</subtitle>
  <link href="https://whz0325.github.io/atom.xml" rel="self"/>
  
  <link href="https://whz0325.github.io/"/>
  <updated>2023-05-18T15:42:38.040Z</updated>
  <id>https://whz0325.github.io/</id>
  
  <author>
    <name>WHZ0325</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>5月做题记录</title>
    <link href="https://whz0325.github.io/2023-05-18/"/>
    <id>https://whz0325.github.io/2023-05-18/</id>
    <published>2023-05-18T14:58:00.000Z</published>
    <updated>2023-05-18T15:42:38.040Z</updated>
    
    <content type="html"><![CDATA[<p>看能把进阶指南刷多少……</p><h5 id="AcWing-998-起床困难综合症"><a href="#AcWing-998-起床困难综合症" class="headerlink" title="AcWing 998 起床困难综合症"></a>AcWing 998 起床困难综合症</h5><p>注意枚举的位数不一定是 m 转二进制的位数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看能把进阶指南刷多少……&lt;/p&gt;
&lt;h5 id=&quot;AcWing-998-起床困难综合症&quot;&gt;&lt;a href=&quot;#AcWing-998-起床困难综合症&quot; class=&quot;headerlink&quot; title=&quot;AcWing 998 起床困难综合症&quot;&gt;&lt;/a&gt;AcWing 998 起</summary>
      
    
    
    
    <category term="竞赛题解" scheme="https://whz0325.github.io/categories/%E7%AB%9E%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>数位DP</title>
    <link href="https://whz0325.github.io/digital-dp/"/>
    <id>https://whz0325.github.io/digital-dp/</id>
    <published>2023-04-09T01:25:00.000Z</published>
    <updated>2023-04-09T13:52:34.384Z</updated>
    
    <content type="html"><![CDATA[<p>数位 DP 唯一需要考虑的就是如何求不限定范围，只限定位数的情况下的方案数。</p><h5 id="【Ural-1057】Amount-of-Degrees"><a href="#【Ural-1057】Amount-of-Degrees" class="headerlink" title="【Ural 1057】Amount of Degrees"></a>【Ural 1057】Amount of Degrees</h5><p>求 $[x,y]$ 范围内恰好可以拆分为 $k$ 个 $b$ 的整数次幂（不重复）的数的个数。</p><p>$1\le x,y\le 2^{31}-1$，$1\le k\le 20$，$2\le b\le 10$。</p><p>拆分成前缀和的形式，$f(x)$ 表示 $[0,x]$ 范围内的解，则答案为 $f(y)-f(x-1)$。</p><p>问题等价于将数字转化为 $b$ 进制后 $1$ 的位数为 $k$ 的方案数。</p><p>数位 DP 的思想是从高位到低位沿着 $x$ 的上界进行枚举，每次累加这一位取不到上界时的方案数，本题中，这个方案数就是组合数。</p><p>时间复杂度为 $O(log^2n)$，瓶颈在于预处理组合数。</p><p>细节有：如果 $x$ 满足条件需要在最后累加进去，且一旦有一位上的数大于 $1$ 则代表后面若干位可以任意填 $1$，这时需要跳出循环，选择了 $k$ 个 $1$ 后也应跳出循环，此时后面的若干位应全部填 $0$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line"><span class="keyword">int</span> k, b; ll c[<span class="number">35</span>][<span class="number">35</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">prelude</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    c[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">32</span>; ++i) &#123;</span><br><span class="line">        c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">            c[i][j] = c[i - <span class="number">1</span>][j - <span class="number">1</span>] + c[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> bits[<span class="number">35</span>], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        bits[cnt++] = num % b;</span><br><span class="line">        num /= b;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>; <span class="keyword">int</span> curk = k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cnt; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(bits[i - <span class="number">1</span>] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            ans += c[i][curk];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(bits[i - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            ans += c[i - <span class="number">1</span>][curk];</span><br><span class="line">            --curk; <span class="keyword">if</span>(curk &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(bits[i] &gt; <span class="number">1</span>) &#123; cnt1 = <span class="number">-1</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> cnt1 += bits[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt1 == k ? ans + <span class="number">1</span> : ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">prelude</span>();</span><br><span class="line">    <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;x, &amp;y, &amp;k, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">solve</span>(y) - <span class="built_in">solve</span>(x - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="【USACO-Nov06】Round-Numbers"><a href="#【USACO-Nov06】Round-Numbers" class="headerlink" title="【USACO Nov06】Round Numbers"></a>【USACO Nov06】Round Numbers</h5><h5 id="【ZJOI-2010】数字计数"><a href="#【ZJOI-2010】数字计数" class="headerlink" title="【ZJOI 2010】数字计数"></a>【ZJOI 2010】数字计数</h5><p>求对于 $[a,b]$ 的所有整数，$[0,9]$ 各出现多少次。</p><p>$1\le a\le b\le 10^{12}$。</p><p>问题转化为求 $[0,x]$ 的所有整数中 $[0,9]$ 的出现次数。</p><p>从高位开始枚举每一位，用数位 DP 解决的前提是可以在较短的时间内给出当前位不取上界时剩下位任取的结果，这里就是计算 $[0\dots 0,9\dots 9]$ 中 $[0,9]$ 的出现次数，它们是相同的，且可以方便地求出来。</p><p>注意下沿和上界。</p><p>当首位取 $0$ 时，可以先正常计算贡献，再枚举起始 $0$ 结束的位置除去多计算的 $0$ 的个数。</p><p>当继续沿着上界走时，对当前填入数字的贡献是后续填入不超过 $x$ 的所有低位的方案数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line">ll f[<span class="number">20</span>], p[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">prelude</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>; p[<span class="number">1</span>] = <span class="number">10</span>; f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">15</span>; ++i) &#123;</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * <span class="number">10</span>;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] * <span class="number">10</span> + p[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> bits[<span class="number">20</span>], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(ll num, ll ans[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i) ans[i] = <span class="number">0</span>;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        bits[cnt++] = num % <span class="number">10</span>;</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cnt; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> &amp;cur = bits[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="number">0</span>) &#123;</span><br><span class="line">            ll contribute = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">2</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                contribute = contribute * <span class="number">10</span> + bits[j];</span><br><span class="line">            &#125;</span><br><span class="line">            ans[<span class="number">0</span>] += contribute;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == cnt) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; ++j) ans[j] += f[i - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">2</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                    ans[<span class="number">0</span>] -= p[j];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cur - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                    ans[j] += p[i - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">9</span>; ++k) &#123;</span><br><span class="line">                        ans[k] += f[i - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ll contribute = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">2</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                    contribute = contribute * <span class="number">10</span> + bits[j];</span><br><span class="line">                &#125;</span><br><span class="line">                ans[cur] += contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= cur - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                    ans[j] += p[i - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">9</span>; ++k) &#123;</span><br><span class="line">                        ans[k] += f[i - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ll contribute = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">2</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                    contribute = contribute * <span class="number">10</span> + bits[j];</span><br><span class="line">                &#125;</span><br><span class="line">                ans[cur] += contribute;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">        ++ans[bits[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">prelude</span>();</span><br><span class="line">    ll a, b; <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    ll ansb[<span class="number">10</span>], ansaso[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">solve</span>(b, ansb); <span class="built_in">solve</span>(a - <span class="number">1</span>, ansaso);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld%c&quot;</span>, ansb[i] - ansaso[i], (i ^ <span class="number">9</span>) ? <span class="string">&#x27; &#x27;</span> : <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="【SCOI-2009】windy-数"><a href="#【SCOI-2009】windy-数" class="headerlink" title="【SCOI 2009】windy 数"></a>【SCOI 2009】windy 数</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数位 DP 唯一需要考虑的就是如何求不限定范围，只限定位数的情况下的方案数。&lt;/p&gt;
&lt;h5 id=&quot;【Ural-1057】Amount-of-Degrees&quot;&gt;&lt;a href=&quot;#【Ural-1057】Amount-of-Degrees&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://whz0325.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数位DP" scheme="https://whz0325.github.io/tags/%E6%95%B0%E4%BD%8DDP/"/>
    
  </entry>
  
  <entry>
    <title>C++ 面向对象笔记</title>
    <link href="https://whz0325.github.io/cpp-notes/"/>
    <id>https://whz0325.github.io/cpp-notes/</id>
    <published>2023-04-08T14:34:00.000Z</published>
    <updated>2023-05-28T09:14:31.021Z</updated>
    
    <content type="html"><![CDATA[<p>照学校课件打的，大概率没什么意思，有空再修改。</p><h3 id="C-程序结构"><a href="#C-程序结构" class="headerlink" title="C++ 程序结构"></a>C++ 程序结构</h3><h5 id="多文件编译"><a href="#多文件编译" class="headerlink" title="多文件编译"></a>多文件编译</h5><p>将源代码文件放一块儿就行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ a.cpp b.cpp c.cpp -o program</span><br></pre></td></tr></table></figure><h5 id="包含警戒"><a href="#包含警戒" class="headerlink" title="包含警戒"></a>包含警戒</h5><p>保证头文件不被重复定义。</p><p>解决方案一：<code>#pragma once</code></p><p>解决方案二：包含警戒。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> A</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// b.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> B</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// a.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;a.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;b.h&quot;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// b.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;b.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;a.h&quot;</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h5><ul><li>声明其它文件中的变量或函数。</li><li><code>extern &quot;C&quot;</code>：要求编译器按照 C 语言的方式编译函数（C++ 为实现函数重载会调整函数名，链接时可能出现问题）。</li></ul><h3 id="类型和变量"><a href="#类型和变量" class="headerlink" title="类型和变量"></a>类型和变量</h3><h5 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h5><p><code>wchar_t</code>：wide char type</p><h5 id="推导类型"><a href="#推导类型" class="headerlink" title="推导类型"></a>推导类型</h5><ul><li><code>auto</code>：定义时自动推导类型。</li><li><code>decltype(expression)</code>：给出表达式的返回类型。</li></ul><h5 id="typedef-函数"><a href="#typedef-函数" class="headerlink" title="typedef 函数"></a>typedef 函数</h5><p>用法：<code>typedef return_type (*new_name)(type...)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*func)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    func f1 = add;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">f1</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    f1 = sub;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">f1</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="enum-枚举类型"><a href="#enum-枚举类型" class="headerlink" title="enum 枚举类型"></a>enum 枚举类型</h5><p>默认从零开始，名称作用域为全局，不能前置声明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Week</span> &#123;</span> Mon = <span class="number">1</span>, Tue, Wed, Thur, Fri, Sat, Sun &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Week first = Mon;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, first);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="enum-class-类型"><a href="#enum-class-类型" class="headerlink" title="enum class 类型"></a>enum class 类型</h5><ul><li><p>作用域不再是全局，需要 <code>::</code> 才能访问。</p></li><li><p>不能进行隐式类型转换。</p></li><li><p>可以前置声明，如果类型不是默认的 <code>int</code> 需要手动修改 <code>enum class Name: std::uint32_t;</code></p><p>  .</p></li></ul><p><code>enum class</code> 不能与 <code>int</code> 相互转化。注意命名空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Number</span>:</span> <span class="keyword">char</span> &#123;</span><br><span class="line">    one = <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    two = <span class="string">&#x27;2&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Number num = Number::one;</span><br><span class="line">    <span class="built_in">putchar</span>((<span class="keyword">char</span>)num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="union-共用体"><a href="#union-共用体" class="headerlink" title="union 共用体"></a>union 共用体</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">u0</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> all: <span class="number">8</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> low: <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> high: <span class="number">4</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    u0 a; a.all = <span class="number">0xffff</span>;<span class="comment">// 16位，其实越界了</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, a.low, a.high, a.all);<span class="comment">// 15 15 255</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（这样取一些位会很方便，然而 <code>sizeof</code> 是不变的……）</p><h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><p>左值引用：貌似不能修改引用对象的指向。</p><p>右值引用：不算清晰，大概就是可以对临时对象进行操作？</p><h5 id="初始化（C-11）"><a href="#初始化（C-11）" class="headerlink" title="初始化（C++11）"></a>初始化（C++11）</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Type</span> &#123;</span> <span class="keyword">int</span> a, b; &#125;;</span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">10</span>&#125;; Type x&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><h5 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h5><ul><li>函数内表示静态变量。</li><li>函数外表示仅本文件有效。（不同文件重名会被认为是不同变量，由编译器处理）</li></ul><h3 id="指针、数组、引用、常量"><a href="#指针、数组、引用、常量" class="headerlink" title="指针、数组、引用、常量"></a>指针、数组、引用、常量</h3><h5 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h5><ul><li><code>NULL</code>：C++ 中就是整数 0（C 中是 <code>(void *)0</code>）。</li><li><code>nullptr</code>：C++11 中用来避免函数调用时产生二义性。</li></ul><p>见：<a href="https://blog.csdn.net/u010983763/article/details/53667468%E3%80%82">https://blog.csdn.net/u010983763/article/details/53667468。</a></p><p>deference（解引用/逆向引用）：起这么厉害的名字，其实就是访问指针中的元素 <code>*p</code>。</p><ul><li>指针数组：<code>int *arr[5];</code>，一个数组，存放指针。</li><li>数组指针：<code>int (*p)[5] = &amp;array;</code>，一个指针，指向一个数组，通过 <code>(*p)[i]</code> 取值。</li></ul><h5 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h5><ul><li><code>#x</code> 将 <code>x</code> 表示为字符串。</li><li><code>##x</code> 将 <code>x</code> 与前面拼接。</li><li><code>#@x</code> 将 <code>x</code> 表示为字符。</li><li><code>__LINE__</code> 表示当前行号。</li><li><code>__FILE__</code> 表示当前文件的绝对路径。</li><li><code>__FUNCTION__</code> 表示当前所在的函数名。（调试时应该会很有用）</li></ul><h5 id="常量折叠"><a href="#常量折叠" class="headerlink" title="常量折叠"></a>常量折叠</h5><p><code>const</code> 定义的常量不会被重复定义（编译时被展开）。</p><h5 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h5><ul><li><code>const int *p = &amp;arr;</code>：指向的内容不能修改。</li><li><code>int* const p = &amp;arr;</code>：存放的指针不能修改。</li><li><code>const int* const p = &amp;arr;</code>：俩都不能改。</li></ul><p>未解之谜：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;arr;</span><br><span class="line"><span class="keyword">int</span> *pt = p;<span class="comment">// 可能是这样赋值后可以通过 *pt 修改内容所以就禁止了</span></span><br></pre></td></tr></table></figure><h5 id="const-引用"><a href="#const-引用" class="headerlink" title="const 引用"></a>const 引用</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;a = <span class="number">1</span>;<span class="comment">//正确</span></span><br></pre></td></tr></table></figure><p>函数参数类型是 <code>const int &amp;x</code> 表明可以传入变量或常量（常数也可），在函数体内不能修改而已。</p><h5 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h5><p>这两者是不同的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *s = <span class="string">&quot;string&quot;</span>;<span class="comment">// 是指针，因此可以修改指向</span></span><br><span class="line"><span class="keyword">char</span> s[] = <span class="string">&quot;string&quot;</span>;<span class="comment">// 字符数组，可以修改内容，不能修改指向</span></span><br></pre></td></tr></table></figure><hr><p>md，C++ 好难……</p><hr><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h5 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h5><ul><li><code>__cdecl</code>：C 模式，参数从右到左压栈，主调用的函数控制，参数可变，可不指定参数名。</li><li><code>__stdcall</code>：参数从右到左压栈，被调用的函数控制，参数不可变。</li></ul><p>关于不指定参数名：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __cdecl <span class="title">print</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有函数体中用不到该形式参数时可以省略，这种情况下 C 和 C++ 有一些不同：</p><ul><li>C 语言在声明中可以省略，定义中不可以省略。</li><li>C++ 在声明中可以省略，定义中也可以省略。</li></ul><h5 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h5><p>缺省函数（调用时使用默认参数）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a = <span class="number">100</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">func</span>();<span class="comment">// 100</span></span><br></pre></td></tr></table></figure><ul><li>缺省函数不能用来区分同名函数。（缺省函数还可能存在其它歧义行为，均被禁止）</li><li>返回值类型不能用来区分同名函数。</li><li>引用/指针类型（值类型不行）的 <code>const</code> 可用于区分同名函数：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *p)</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;void func(int *p);&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *p)</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;void func(const int *p);&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="keyword">int</span> *p = &amp;cnt; <span class="built_in">func</span>(p); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：void func(int *p);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *p)</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;void func(int *p);&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *p)</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;void func(const int *p);&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="built_in">func</span>(&amp;cnt); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：void func(const int *p);</span></span><br></pre></td></tr></table></figure><p>关于缺省函数：第一个带缺省值的参数后的每一个参数都要带缺省值（不然会有歧义）。</p><p>【上面第三条】关于 <code>const</code> 形参（参数必须是引用/指针类型）：</p><ul><li>实际参数无 <code>const</code>，形式参数有无 <code>const</code> 都可调用，优先调用无 <code>const</code> 的函数。</li><li>实际参数有 <code>const</code>，只能调用形式参数有 <code>const</code> 的函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp;a)</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;B&quot;</span>); &#125;<span class="comment">// 优先调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a)</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;A&quot;</span>); &#125;<span class="comment">// 注释掉上一行才会调用它</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>; <span class="built_in">func</span>(a); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="汇编逻辑"><a href="#汇编逻辑" class="headerlink" title="汇编逻辑"></a>汇编逻辑</h5><p>函数调用时数据存放在栈中，自顶向下从高位到低位，EBP 寄存器用于指向该函数的栈底，ESP 指针则指向栈顶，上一层函数 EBP 寄存器的值往往存放在当前函数的栈底。</p><h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><ul><li>值类型：都是 <code>const</code>，等价于 <code>const int f();</code></li><li>指针类型：指针 <code>const</code>，指针内容可变，等价于 <code>int* const f();</code>（不是 <code>const int* f();</code>）。</li><li>引用返回：<code>int &amp;f();</code>，如果要返回的是一个很大的类那就十分有用了。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">func</span><span class="params">()</span> </span>&#123; <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1024</span>; <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a); <span class="keyword">return</span> a; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;p = <span class="built_in">func</span>(); ++p; <span class="built_in">func</span>(); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：1024\n1025\n</span></span><br></pre></td></tr></table></figure><p>写成这样也是可以的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">func</span><span class="params">()</span> </span>&#123; <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1024</span>; <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a); <span class="keyword">return</span> a; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ++<span class="built_in">func</span>(); <span class="built_in">func</span>(); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：1024\n1025\n</span></span><br></pre></td></tr></table></figure><p>而改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> &amp;<span class="title">func</span><span class="params">()</span> </span>&#123; <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1024</span>; <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a); <span class="keyword">return</span> a; &#125;</span><br></pre></td></tr></table></figure><p>就会报错。</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h5 id="前置声明"><a href="#前置声明" class="headerlink" title="前置声明"></a>前置声明</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Type</span>;</span></span><br></pre></td></tr></table></figure><p>避免循环定义。</p><h5 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h5><p>类的静态变量只能在类外初始化，类中只能初始化 <code>static const int</code> 类型，去掉 <code>const</code> 或者不使用 <code>int</code> 类型均会报错。</p><ul><li><code>static const int</code>：允许类内初始化。</li><li><code>static constexpr</code>：必须类内初始化，不能只声明。</li><li><code>static</code> 关键字的其它类型：不允许类内初始化，仅可以在类内声明。</li></ul><p>据说是为了避免每个对象中都包含该静态成员变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Type</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">float</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> Type::a = <span class="number">1.0</span>;<span class="comment">// 怪诶，这种写法</span></span><br></pre></td></tr></table></figure><p>注：<code>constexpr</code> 将尽量在编译阶段运算。</p><h5 id="虚函数（virtual）"><a href="#虚函数（virtual）" class="headerlink" title="虚函数（virtual）"></a>虚函数（virtual）</h5><p>调用成员函数时，虚函数由<strong>指针指向的实际类型</strong>决定，普通函数由<strong>指针类型</strong>决定。</p><p>简单来说就是普通成员函数都放在代码区，取的时候按照指针类型去取；而虚函数在对象中保存虚函数表指针 vptr，通过 vptr 找到虚函数表 vtbl，再通过 vtbl 找到对应的虚函数，因此由对象的实际类型决定。（包含虚函数的类占用的空间会更大）</p><p>构造函数不能是虚函数，而析构函数最好设置为虚函数（析构所有的新成员）。</p><h5 id="（纯虚函数-virtual-void-func-0-用于抽象类，即抽象函数）"><a href="#（纯虚函数-virtual-void-func-0-用于抽象类，即抽象函数）" class="headerlink" title="（纯虚函数 virtual void func()=0; 用于抽象类，即抽象函数）"></a>（纯虚函数 <code>virtual void func()=0;</code> 用于抽象类，即抽象函数）</h5><h5 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h5><p><code>inline</code> 关键字，类内实现的函数都默认内联，类外实现的函数须加关键字实现内联且不能放在代码文件中（需要放在头文件中）。</p><p>【内联函数的一些问题】待填坑。</p><h5 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h5><p>没有指定访问权限的成员变量默认私有。</p><ul><li><code>public</code>：公开</li><li><code>protected</code>：子类可访问</li><li><code>private</code>：仅自己或友元可访问</li></ul><h5 id="常成员函数"><a href="#常成员函数" class="headerlink" title="常成员函数"></a>常成员函数</h5><p>写法：<code>void func() const &#123;&#125;</code></p><ul><li>普通函数的 <code>this</code> 相当于 <code>T* const this</code>：指针不可变，指向内容可变。</li><li>常成员函数的 <code>this</code> 相当于 <code>const T* const this</code>：指针不可变，指向内容不可变。</li></ul><p>如果对象是 <code>const</code> 类型的话，不修改对象的成员函数若不指定为 <code>const</code> 函数则无法调用。</p><h5 id="类函数-类变量"><a href="#类函数-类变量" class="headerlink" title="类函数/类变量"></a>类函数/类变量</h5><p>与 Java 中类似，加 <code>static</code> 关键字，最好使用 <code>ClassName::FuncName()</code> 而不是 <code>ObjectName.FuncName()</code> 调用。</p><ul><li>没有 <code>this</code> 指针。</li><li>没有 <code>const</code> 修饰。（没有对象谈何对对象不做改动）</li></ul><h3 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h3><h5 id="explicit-关键字"><a href="#explicit-关键字" class="headerlink" title="explicit 关键字"></a>explicit 关键字</h5><p>不允许奇怪的隐式类型转换，像 <code>Point p = 1</code> 这种。</p><h5 id="一些无聊的尝试"><a href="#一些无聊的尝试" class="headerlink" title="一些无聊的尝试"></a>一些无聊的尝试</h5><p>定义 <code>static</code> 类函数，使用引用 <code>&amp;</code> 或指针返回创建的对象（一种是 <code>new</code> 到堆里，一种是 <code>static</code> 到静态数据区【这种方法只能创建一次】）。</p><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>当类有带参数的构造函数时，不能不初始化（<code>ClassName object;</code>）。</p><p>构造函数其实是在对象创建之后才调用的。</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>类变量只有整型常量可以初始化，这个是前面提到过的 <code>static const int</code>。</p><p>在参数列表里初始化引用对象和常量，这样是没问题的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Type</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> &amp;a; <span class="keyword">const</span> <span class="keyword">int</span> b;</span><br><span class="line">    <span class="built_in">Type</span>(): <span class="built_in">a</span>(val), <span class="built_in">b</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>初始化列表将严格按照定义的顺序初始化。</p><p>初始化列表先于构造函数的代码块执行。</p><h5 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h5><p>没有参数：<code>~ClassName() &#123;&#125;</code></p><p>析构函数则是在对象销毁之前调用的。</p><h3 id="拷贝和赋值"><a href="#拷贝和赋值" class="headerlink" title="拷贝和赋值"></a>拷贝和赋值</h3><p>返回值存放在栈中，使用时再拷贝出来。（返回的不是单个整数时编译为何种汇编语言？实验没有成功进行因为被编译器所优化）</p><h5 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h5><p>默认存在。</p><p>调用：</p><ul><li><code>Type b(a);</code></li><li><code>Type b = a;</code>（好像不太推荐）</li></ul><p>自定义（需要引用符号，引用传递）：</p><ul><li>不修改被拷贝的对象：<code>Type(const Type &amp;rhs) &#123;&#125;</code></li><li>要转移被拷贝的对象：<code>Type(Type &amp;rhs) &#123;&#125;</code></li></ul><p>参数列表调用：</p><ul><li>这样调用的是拷贝构造函数（无论加不加引用符号）：<code>Type(Type &amp;a):a(a) &#123;&#125;</code>。</li><li>这样调用的是普通构造函数：<code>Type(int a):a(a) &#123;&#125;</code>。</li></ul><p>【为什么拷贝构造函数不能值传递？】值传递时会在函数执行时创建局部变量，该局部变量初始化时需要使用拷贝构造函数将实际参数的值赋给它，这样再次调用拷贝构造函数就会产生死循环。</p><h5 id="浅拷贝-深拷贝"><a href="#浅拷贝-深拷贝" class="headerlink" title="浅拷贝/深拷贝"></a>浅拷贝/深拷贝</h5><p>浅拷贝：成员变量是一个对象时调用其对应的拷贝构造函数，其余（基本数据类型，指针类型，引用类型）直接按二进制拷贝。</p><p>深拷贝：自己实现，拷贝的不再是指针，而是指针内的值。</p><table><thead><tr><th></th><th>有构造函数</th><th>无构造函数</th></tr></thead><tbody><tr><td>有拷贝构造函数</td><td>无默认构造函数和拷贝构造函数</td><td>无默认构造函数和拷贝构造函数</td></tr><tr><td>无拷贝构造函数</td><td>有拷贝构造函数</td><td>有默认构造函数和拷贝构造函数</td></tr></tbody></table><p>即没有什么提供什么，但<strong>自定义的拷贝构造函数就可以代替构造函数</strong>。</p><h5 id="禁止拷贝"><a href="#禁止拷贝" class="headerlink" title="禁止拷贝"></a>禁止拷贝</h5><ul><li>自定义一个没有实现 <code>&#123;&#125;</code> 的 <code>private</code> 的拷贝构造函数。</li><li>C++1z：<code>T(const T&amp; t)=delete</code>。</li></ul><h5 id="拷贝与赋值"><a href="#拷贝与赋值" class="headerlink" title="拷贝与赋值"></a>拷贝与赋值</h5><ul><li>拷贝：<code>Type a = b;</code></li><li>赋值：<code>Type a; a = b;</code></li></ul><p>【有<strong>引用类型</strong>的成员不能赋值，可以拷贝】拷贝是初始化的过程，而赋值时引用类型的成员已经有引用的变量，因其不能更改所以不能赋值。（成员变量为引用类型：须自定义构造函数和拷贝构造函数，不能赋值。）</p><p>自定义赋值函数：重载 <code>=</code> 运算符 <code>Type &amp;operator = (const Type &amp;rhs) &#123; return *this; &#125;</code>（参考内置类型的使用习惯）。</p><p>课件中一个有趣的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Type</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="built_in">Type</span>() &#123; p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1024</span>); &#125;</span><br><span class="line">    Type &amp;<span class="keyword">operator</span> = (<span class="keyword">const</span> Type &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*rhs.p);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Type a; a = a;</span><br><span class="line">    Type &amp;b = a; a = b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时编译正常，但逻辑错误，应当<strong>判断 <code>(&amp;rhs != this)</code> 后</strong>再进行删除和赋值。</p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>只能重载一元运算符和二元运算符：<code>,</code>、<code>&amp;</code>（与运算）、<code>-&gt;</code>、<code>new</code>、<code>new[]</code> 等。</p><p>两种形式：自由函数 AND 成员函数。</p><p>访问权限等参考内置函数，如：</p><ul><li><code>T &amp;operator *= (const &amp;T rhs) &#123;&#125;</code></li><li><code>T operator * (const &amp;T rhs) &#123;&#125;</code></li><li><code>bool operator ! () &#123;&#125;</code></li><li><code>T &amp;operator ++ () &#123;&#125;</code>：对应 <code>++t</code>，返回的是自加后的值，因此要加 <code>&amp;</code> 符号。</li><li><code>T operator ++ (int) &#123;&#125;</code>：对应 <code>t++</code>，返回的是自加前的值，因此无需 <code>&amp;</code> 符号。</li><li><code>int opeartor [] (int index) const &#123; return arr[index]; &#125;</code></li><li><code>int &amp;operator [] (int index) &#123; return arr[index]; &#125;</code></li><li><code>int operator () () const &#123; return 1024; &#125;</code>：仿函数，可用 lambda 表达式代替。</li><li>重载 <code>-&gt;</code> 运算符须保证：返回指针类型或返回的自定义类型重载了 <code>-&gt;</code>。</li><li><code>ostream &amp;operator &lt;&lt; (ostream &amp;out, const T &amp;t) &#123; out &lt;&lt; t.a; return out; &#125;</code></li><li><code>istream &amp;operator &lt;&lt; (istream &amp;in, const T &amp;t) &#123; in &gt;&gt; t.a; return in; &#125;</code></li></ul><p>注：<code>lhs</code>、<code>rhs</code> 分别是 Left Hand Side 和 Right Hand Side 的缩写。</p><p>左操作数是自定义类型的尽量使用成员函数的形式重载，不要重载运算符 <code>&amp;&amp;</code>、<code>||</code>、<code>,</code>。</p><h3 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h3><p>动态内存管理：存放在全局堆区（<code>new</code> 申请的内存）</p><h5 id="new-delete"><a href="#new-delete" class="headerlink" title="new/delete"></a>new/delete</h5><p>分配数组类型：<code>int *p = new int(5)</code></p><p>分配指针类型：<code>const T **p = new P*();</code></p><p>释放数组类型：<code>delete[] arr;</code></p><p><code>new</code> 失败后会跳转 <code>new_error_handle()</code> 函数（可通过 <code>set_new_handler()</code> 修改），成功会执行构造函数并返回对应类型的指针（重载 <code>new</code> 运算符返回的 <code>void *</code> 类型指针会强制转化为 <code>T *</code> 类型指针）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;erorooor&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*func)</span><span class="params">()</span></span>;</span><br><span class="line">    func before = std::<span class="built_in">set_new_handler</span>(func1);</span><br><span class="line">    std::<span class="built_in">set_new_handler</span>(before);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="重载-new-delete"><a href="#重载-new-delete" class="headerlink" title="重载 new/delete"></a>重载 new/delete</h5><p><code>void* operator new(std::size_t);</code> 对应 <code>new T(1024);</code></p><p><code>void* operator new(std::size_t, const string &amp;s);</code> 对应 <code>new(&quot;string&quot;) T(1024);</code></p><p><code>void operator delete(void *, std::set_t);</code> 对应 <code>delete p;</code></p><h5 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">// n 可以为变量</span></span><br><span class="line"><span class="keyword">delete</span>[] arr;</span><br></pre></td></tr></table></figure><p>普通类型对象数组 <code>Type arr[1024];</code> 要求必须有无参构造函数。</p><p>指针类型对象数组 <code>Type* arr[1024];</code> 不要求必须有无参构造函数。</p><h5 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h5><p>将指针封装在类中，以便析构时自动释放。</p><h5 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h5><p>共享指针，记录指针被引用的次数。</p><ul><li><code>&lt;memory&gt;</code></li><li><code>std::shared_ptr&lt;Type&gt;</code></li><li><code>std::make_shared&lt;Type&gt;()</code></li><li><code>p.get()</code></li><li><code>*p</code> 等价于 <code>*p.get()</code></li><li><code>p.use_count()</code></li><li><code>p.reset()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="keyword">int</span>&gt; p = std::make_shared&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    *p = <span class="number">1024</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[p]\tptr: %p val: %d use_count: %ld\n&quot;</span>, p.<span class="built_in">get</span>(), *p, p.<span class="built_in">use_count</span>());</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p0</span><span class="params">(p)</span></span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[p]\tptr: %p val: %d use_count: %ld\n&quot;</span>, p.<span class="built_in">get</span>(), *p, p.<span class="built_in">use_count</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[p0]\tptr: %p val: %d use_count: %ld\n&quot;</span>, p0.<span class="built_in">get</span>(), *p0, p0.<span class="built_in">use_count</span>());</span><br><span class="line">    p.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[p0]\tptr: %p val: %d use_count: %ld\n&quot;</span>, p0.<span class="built_in">get</span>(), *p0, p0.<span class="built_in">use_count</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[p]ptr: 0x6000025c4058 val: 1024 use_count: 1</span></span><br><span class="line"><span class="comment">[p]ptr: 0x6000025c4058 val: 1024 use_count: 2</span></span><br><span class="line"><span class="comment">[p0]ptr: 0x6000025c4058 val: 1024 use_count: 2</span></span><br><span class="line"><span class="comment">[p0]ptr: 0x6000025c4058 val: 1024 use_count: 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>（<code>printf</code> 中输出地址用 <code>%p</code>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y): <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Point&gt; p = std::make_shared&lt;Point&gt;(<span class="number">12</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[p]\tptr: %p val: (%d, %d) use_count: %ld\n&quot;</span>, p.<span class="built_in">get</span>(), p-&gt;x, p-&gt;y, p.<span class="built_in">use_count</span>());</span><br><span class="line">    std::shared_ptr&lt;Point&gt; p0 = p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[p]\tptr: %p val: (%d, %d) use_count: %ld\n&quot;</span>, p.<span class="built_in">get</span>(), p-&gt;x, p-&gt;y, p.<span class="built_in">use_count</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[p0]\tptr: %p val: (%d, %d) use_count: %ld\n&quot;</span>, p0.<span class="built_in">get</span>(), p0-&gt;x, p0-&gt;y, p0.<span class="built_in">use_count</span>());</span><br><span class="line">    p-&gt;x = <span class="number">3</span>; p-&gt;y = <span class="number">9</span>; p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[p0]\tptr: %p val: (%d, %d) use_count: %ld\n&quot;</span>, p0.<span class="built_in">get</span>(), p0-&gt;x, p0-&gt;y, p0.<span class="built_in">use_count</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[p]ptr: 0x600003bad1d8 val: (12, 4) use_count: 1</span></span><br><span class="line"><span class="comment">[p]ptr: 0x600003bad1d8 val: (12, 4) use_count: 2</span></span><br><span class="line"><span class="comment">[p0]ptr: 0x600003bad1d8 val: (12, 4) use_count: 2</span></span><br><span class="line"><span class="comment">[p0]ptr: 0x600003bad1d8 val: (3, 9) use_count: 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以像普通指针一样用赋值号，也会被累计其中哦！</p><p>函数体结束就释放了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y): <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Point *addr;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Point&gt; p = std::make_shared&lt;Point&gt;(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p %d %d\n&quot;</span>, p.<span class="built_in">get</span>(), p-&gt;x, p-&gt;y);</span><br><span class="line">    addr = p.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">create</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, addr-&gt;x, addr-&gt;y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0x600001365118 3 5</span></span><br><span class="line"><span class="comment">0 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>除非作为返回值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y): <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Point *addr;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Point&gt; <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Point&gt; p = std::make_shared&lt;Point&gt;(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p %d %d\n&quot;</span>, p.<span class="built_in">get</span>(), p-&gt;x, p-&gt;y); addr = p.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Point&gt; &amp;&amp; pp = <span class="built_in">create</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p used_count: %ld\n&quot;</span>, pp.<span class="built_in">get</span>(), pp.<span class="built_in">use_count</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, addr-&gt;x, addr-&gt;y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0x6000025f51d8 3 5</span></span><br><span class="line"><span class="comment">0x6000025f51d8 used_count: 1</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这个东西可以利用前面学到的拷贝构造函数和重载赋值自己实现。</p><h5 id="乱七八糟概念"><a href="#乱七八糟概念" class="headerlink" title="乱七八糟概念"></a>乱七八糟概念</h5><p>悬浮指针：释放后访问指针。</p><p>内存泄漏：申请了没释放。</p><p>写时复制：指向多个同一资源，需要修改的时候才复制一份分开，用来节省空间（有点像可持久化）。</p><p>定位分配：分配到已有空间，就是下面这个东西（需要 <code>&lt;new&gt;</code>，在后面指定分配到的地址）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">char</span>* s = <span class="built_in"><span class="keyword">new</span></span>(buf) <span class="built_in"><span class="keyword">char</span></span>(<span class="number">32</span>);</span><br><span class="line">    <span class="keyword">char</span>* ss = <span class="built_in"><span class="keyword">new</span></span>(buf + <span class="number">32</span>) <span class="built_in"><span class="keyword">char</span></span>(<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p %p %p\n&quot;</span>, buf, s, ss);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0x16d762cf8 0x16d762cf8 0x16d762d18</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="转换函数、命名空间、友元、嵌套类、流"><a href="#转换函数、命名空间、友元、嵌套类、流" class="headerlink" title="转换函数、命名空间、友元、嵌套类、流"></a>转换函数、命名空间、友元、嵌套类、流</h3><h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><p>基本数据类型2自定义类型：构造函数（可通过 <code>explicit</code> 禁止）</p><p>自定义类型2基本数据类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y): <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">p</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>, <span class="built_in"><span class="keyword">double</span></span>(p));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5.000000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">去掉 explicit 可以有这样的写法：</span></span><br><span class="line"><span class="comment">double q = p;</span></span><br><span class="line"><span class="comment">而非：</span></span><br><span class="line"><span class="comment">double q = (double)p;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>（C 风格强制类型转换 <code>(Type)Value</code> 和 C++ 风格强制类型转换 <code>Type(Value)</code> 应该没什么大的区别）</p><h5 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h5><p>耳熟能详的东西：<code>namespace NAME &#123;&#125;</code>。</p><p>没见过的东西：<code>::</code> 单独出现表示全局命名空间，否则表示当前命名空间。</p><p>可以嵌套：<code>namespace A &#123; namespace B &#123;&#125; &#125;</code>。</p><p>可以起别名：<code>namespace A = B;</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">    <span class="keyword">namespace</span> B &#123;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">32</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> C = A;</span><br><span class="line"><span class="keyword">int</span> value = <span class="number">1024</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">64</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, value, ::value, C::B::value);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">64 1024 32</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>static</code> 访问域：仅能在当前文件中被访问。</p><p>奇怪的东西：匿名空间 <code>namespace &#123;&#125;</code>，看看它怎么回事。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> &#123; <span class="keyword">int</span> value = <span class="number">32</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">64</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, value, ::value);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">64 32</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如果有了全局变量，优先用全局变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">namespace</span> &#123; <span class="keyword">int</span> value = <span class="number">32</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">64</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, value, ::value);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">64 1024</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>对于匿名空间，编译器会给它一个名字并且自动 <code>using namespace XXX;</code>，它和 <code>static</code> 具有相同的 <strong>internal</strong> 链接属性，只对本文件可见，C++ 更提倡使用匿名空间而不是 <code>static</code>。</p><p><code>using</code> 关键字用于<strong>汇入</strong>当前命名空间。</p><h5 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h5><p>嵌套类亦有所谓的访问权限（<code>public</code> 或 <code>private</code>）。</p><p>注：没有指定访问权限的成员变量默认私有。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, a.a, a.pub_a, a.pri_a);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> pub_b;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> pri_b;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// error: &#x27;b&#x27; is a private member of &#x27;A::B&#x27;</span></span><br><span class="line">        <span class="comment">// printf(&quot;%d %d %d\n&quot;, b.b, b.pub_b, b.pri_b);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b.pub_b);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> pub_a;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> pri_a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">内部类可以访问外部类的私有成员变量。</span></span><br><span class="line"><span class="comment">外不能不能访问内部类的私有成员变量。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="友元-friend"><a href="#友元-friend" class="headerlink" title="友元 friend"></a>友元 friend</h5><p>友元函数/友元类：允许访问类的私有成员，写在类的开始，不指明访问权限。</p><h5 id="流"><a href="#流" class="headerlink" title="流"></a>流</h5><p>字节流/字符流/文件流，<code>istream</code> 和 <code>ostream</code>。</p><h3 id="类间关系"><a href="#类间关系" class="headerlink" title="类间关系"></a>类间关系</h3><p>强关联/硬关联/弱关联/软关联：？？？</p><p>联系强弱：（另一类作为）成员变量 &gt; 函数参数和返回值 &gt; 函数实现（局部变量）</p><h5 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h5><p>一般关联/自关联/关联类（设定一个类）/聚集关联</p><p>关联关系：聚合关系（不负责创建和销毁）/组合关系（负责创建和销毁）</p><p>依赖关系</p><h5 id="补充：UML图"><a href="#补充：UML图" class="headerlink" title="补充：UML图"></a>补充：UML图</h5><ul><li>+（public）、-（private）、#（protected）</li><li>抽象类和抽象方法用斜体</li><li>接口 &lt;&lt;interface&gt;&gt; 下面是接口名。</li><li>类实现接口：箭头（空心三角和虚线）</li><li>类继承父类：（子类向父类）箭头（空心三角和实线）</li><li>关联关系（成员变量是一个类）：（指向成员变量的类）箭头（角和实线）</li><li>依赖关系（成员函数的参数/返回值是一个类）：（指向用到的类）箭头（角和虚线）</li><li>聚合关系 <code>has-a</code>：关联关系的特例，箭头（空心菱形和实线角）</li><li>组合关系 <code>contain-a</code>：关联关系的特例，箭头（实心菱形和实线角）</li></ul><h3 id="类的设计"><a href="#类的设计" class="headerlink" title="类的设计"></a>类的设计</h3><p>继承/封装/多态</p><p>依赖（参数或返回类型）/关联（成员变量）</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>可以多继承，不继承父类的构造函数、析构函数、拷贝构造函数、赋值函数、类型转换函数，但在构造函数执行前会先执行父类的构造函数。</p><h5 id="继承方式：public、protected、private（默认），继承后的访问权限根据继承方式进行相应的削弱（如-protected-继承方式将父类中-public-成员削弱为-protected）。"><a href="#继承方式：public、protected、private（默认），继承后的访问权限根据继承方式进行相应的削弱（如-protected-继承方式将父类中-public-成员削弱为-protected）。" class="headerlink" title="继承方式：public、protected、private（默认），继承后的访问权限根据继承方式进行相应的削弱（如 protected 继承方式将父类中 public 成员削弱为 protected）。"></a>继承方式：public、protected、private（默认），继承后的访问权限根据继承方式进行相应的削弱（如 protected 继承方式将父类中 public 成员削弱为 protected）。</h5><p>【private 继承为什么还要存在？】待填坑。</p><p>如何调用父类的构造函数？在初始化列表中调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">P</span>(<span class="keyword">int</span> x = <span class="number">3</span>, <span class="keyword">int</span> y = <span class="number">4</span>): <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">V</span>:</span> <span class="keyword">public</span> P &#123;</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">V</span>(<span class="keyword">int</span> z): <span class="built_in">P</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="built_in">z</span>(z) &#123;&#125;<span class="comment">// Here</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>, x, y, z); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">v0</span><span class="params">(<span class="number">3</span>)</span></span>; v0.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么 C++ 中没有 super？因为 C++ 支持多继承啊，super 指的是哪个呢？</p><p>再给个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">P</span>(<span class="keyword">int</span> x = <span class="number">3</span>, <span class="keyword">int</span> y = <span class="number">4</span>): <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123; <span class="built_in">puts</span>(<span class="string">&quot;P(int x = 3, int y = 4): x(x), y(y)&quot;</span>); &#125;</span><br><span class="line">    <span class="built_in">P</span>(<span class="keyword">const</span> P &amp;rhs) &#123; <span class="built_in">puts</span>(<span class="string">&quot;P(const P &amp;rhs)&quot;</span>); x = rhs.x + <span class="number">1</span>; y = rhs.y + <span class="number">1</span>; &#125;</span><br><span class="line">    P &amp;<span class="keyword">operator</span> = (<span class="keyword">const</span> P &amp;rhs) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;P &amp;operator = (const P &amp;rhs)&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(&amp;rhs != <span class="keyword">this</span>) &#123;</span><br><span class="line">            x = <span class="number">0</span>; y = <span class="number">0</span>;</span><br><span class="line">            x = rhs.x - <span class="number">1</span>; y = rhs.y - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>(x * x + y * y);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">V</span>:</span> <span class="keyword">public</span> P &#123;</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">V</span>(<span class="keyword">int</span> z): <span class="built_in">P</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="built_in">z</span>(z) &#123; <span class="built_in">puts</span>(<span class="string">&quot;V(int z): P(1, 2), z(z)&quot;</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, x, y, z); &#125;</span><br><span class="line">    <span class="built_in">V</span>(<span class="keyword">const</span> V &amp;rhs): <span class="built_in">P</span>(rhs) &#123; <span class="built_in">puts</span>(<span class="string">&quot;V(const V &amp;rhs)&quot;</span>); z = rhs.z + <span class="number">1</span>; &#125;</span><br><span class="line">    V &amp;<span class="keyword">operator</span> = (<span class="keyword">const</span> V &amp;rhs) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;V &amp;operator = (const V &amp;rhs)&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(&amp;rhs != <span class="keyword">this</span>) &#123;</span><br><span class="line">            P::<span class="keyword">operator</span>=(rhs);</span><br><span class="line">            z = <span class="number">0</span>; z = rhs.z - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">v0</span><span class="params">(<span class="number">3</span>)</span></span>; v0.<span class="built_in">get</span>();</span><br><span class="line">    V v1 = v0; v1.<span class="built_in">get</span>();</span><br><span class="line">    v1 = v0; v1.<span class="built_in">get</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>, <span class="built_in"><span class="keyword">double</span></span>(v1));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">P(int x = 3, int y = 4): x(x), y(y)</span></span><br><span class="line"><span class="comment">V(int z): P(1, 2), z(z)</span></span><br><span class="line"><span class="comment">1 2 3</span></span><br><span class="line"><span class="comment">P(const P &amp;rhs)</span></span><br><span class="line"><span class="comment">V(const V &amp;rhs)</span></span><br><span class="line"><span class="comment">2 3 4</span></span><br><span class="line"><span class="comment">V &amp;operator = (const V &amp;rhs)</span></span><br><span class="line"><span class="comment">P &amp;operator = (const P &amp;rhs)</span></span><br><span class="line"><span class="comment">0 1 2</span></span><br><span class="line"><span class="comment">1.000000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>注意代码中 <code>V</code> 类型的 <code>rhs</code> 可以调用 <code>P(rhs)</code> 以及 <code>P::operator=(rhs)</code>。</p><p>注意这里类型转换函数直接调用了父类的。</p><h5 id="子类的一系列操作"><a href="#子类的一系列操作" class="headerlink" title="子类的一系列操作"></a>子类的一系列操作</h5><ul><li>newdefine：子类中定义，父类中没有。</li><li>redefine：子类中定义，父类中也有。</li><li>overload：子类中定义多个，重载。</li><li>overwrite：子类中定义，<strong>父类中有同名的，被隐藏</strong>。</li><li>override（和我之前以为的 override 不太一样）：子类中定义，父类中为同名虚函数。</li></ul><h3 id="继承和类型转换"><a href="#继承和类型转换" class="headerlink" title="继承和类型转换"></a>继承和类型转换</h3><p>protected/private 向上（子类转父类）转换：先取地址再转对应类型的指针，不推荐。</p><p>public 向上转换：安全的，会创建一个新的对象，所以尽可能使用指针或引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">P</span>(<span class="keyword">int</span> x = <span class="number">3</span>, <span class="keyword">int</span> y = <span class="number">4</span>): <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">V</span>:</span> <span class="keyword">public</span> P &#123;</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">V</span>(<span class="keyword">int</span> z): <span class="built_in">P</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="built_in">z</span>(z) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    V* v0 = <span class="keyword">new</span> <span class="built_in">V</span>(<span class="number">3</span>);</span><br><span class="line">    P* p0 = v0;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p %p\n&quot;</span>, v0, p0);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0x600001de4040 0x600001de4040</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>public 向下转换：可能出错。</p><h5 id="乱七八糟的类型转换操作符"><a href="#乱七八糟的类型转换操作符" class="headerlink" title="乱七八糟的类型转换操作符"></a>乱七八糟的类型转换操作符</h5><p><code>static_cast&lt;T&gt;(exp)</code></p><p><code>const_cast&lt;T&gt;(exp)</code>：修改 <code>const</code> 或 <code>volatile</code> 约束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">P</span>(<span class="keyword">int</span> x = <span class="number">3</span>, <span class="keyword">int</span> y = <span class="number">4</span>): <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, x, y);</span><br><span class="line">        P* p = <span class="keyword">const_cast</span>&lt;P*&gt;(<span class="keyword">this</span>);</span><br><span class="line">        p-&gt;x = <span class="number">1</span>; p-&gt;y = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    P p0; p0.<span class="built_in">query</span>(); <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, p0.x, p0.y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>然后尽管这个函数是 <code>const</code>，这个对象的值还是被改了。</p><p><code>reinterpret_cast&lt;T&gt;(exp)</code>：重新解释，用于函数。</p><p><code>dynamic_cast&lt;T&gt;(exp)</code>：用于多继承时父类转子类。</p><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="%%%多重继承"></a>%%%多重继承</h3><p>顺序：构造顺序相同，析构顺序相反。</p><p>菱形结构多重继承产生重复：<strong>虚继承</strong>（继承类加 <code>virtual</code> 关键字修饰），被继承的类称为虚基类。</p><h5 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h5><p>放置静态函数和静态变量。</p><h5 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h5><p>C++ 没有 interface，通过纯虚函数（抽象函数）实现，指定 <code>virtual</code> 之外还要制定函数 <code>=0</code>。</p><h3 id="虚机制"><a href="#虚机制" class="headerlink" title="虚机制"></a>虚机制</h3><h5 id="静态编联与动态编联"><a href="#静态编联与动态编联" class="headerlink" title="静态编联与动态编联"></a>静态编联与动态编联</h5><p>静态编联：编译期间决定调用关系。</p><p>动态编联：执行期间决定调用关系，虚机制是实现方式之一。</p><h5 id="虚指针"><a href="#虚指针" class="headerlink" title="虚指针"></a>虚指针</h5><p>我以为是个新东西，其实就是 vptr。</p><h5 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h5><p>声明时需要加 <code>virtual</code>，定义时可加可不加。</p><ul><li>静态函数显然不能是虚函数。</li><li>如果有虚函数，析构函数应当是虚函数。</li><li>构造函数和拷贝构造函数不能是虚函数，赋值函数通常不定义为虚函数。</li></ul><p>【为什么构造函数不能是虚函数？】调用构造函数需要 vptr，此时对象还没有实例化，找不到 vptr。</p><p>【为什么赋值函数不要定义为虚函数？】因为子类不继承父类的赋值函数（参数类型不同）。</p><h5 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h5><ul><li>public 继承，且会继承父类的虚函数。</li><li>重写函数（函数名相同，多数要求参数相同，返回类型相同或<strong>相容</strong>）默认 <code>virtual</code> 可省略（包括析构函数）。</li></ul><h5 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h5><ul><li>一个类只有一个（实例化首个对象时创建），所有对象共享。</li><li>父子类的虚拟表中相同函数的位置相同。</li></ul><h5 id="静态类型与动态类型"><a href="#静态类型与动态类型" class="headerlink" title="静态类型与动态类型"></a>静态类型与动态类型</h5><p>静态类型：编译期间确定的类型（对应指针的类型）。</p><p>动态类型：执行期间确定的类型（对应指针指向的实际类型）。</p><h5 id="【重要】如何执行？"><a href="#【重要】如何执行？" class="headerlink" title="【重要】如何执行？"></a>【重要】如何执行？</h5><ul><li>在静态类型（定义的指针类型）中寻找对应函数，找不到编译错误。</li><li>若找到的函数不是 <code>virtual</code> 函数则 <code>p-&gt;P::func()</code>，若为 <code>virtual</code> 函数则根据 vptr 执行 <code>(*p-&gt;vptr)[index]((void *)p, ...)</code>。</li></ul><p>在构造函数中调用虚函数当然调用的对应类自己的那个函数，由于 B 类继承自 A 类，构造 B 类时也会构造 A 类（注意这个 A 类仅用于创建的 B 类对象，每再创建一个 B 类会就会再执行一次 A 类的构造函数。</p><p>B 类对象构造的过程：</p><ul><li>构造 A 类</li><li>构造 B 类</li></ul><p>B 类对象析构的过程：</p><ul><li>析构 B 类</li><li>析构 A 类</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A 的析构函数不加 virtual 会在运行时出错哦，因为 object 调用的是 A 的析构函数，导致释放了两次。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> variable;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> variable): <span class="built_in">variable</span>(variable) &#123; <span class="built_in">get</span>(); &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>() &#123; <span class="built_in">get</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[A] get();\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> variable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(): <span class="built_in">A</span>(<span class="number">1024</span>) &#123; <span class="built_in">get</span>(); &#125;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123; <span class="built_in">get</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[B] get();\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> variable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* object = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    A* object2 = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    <span class="keyword">delete</span> object;</span><br><span class="line">    <span class="keyword">delete</span> object2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[A] get();</span></span><br><span class="line"><span class="comment">[B] get();</span></span><br><span class="line"><span class="comment">[A] get();</span></span><br><span class="line"><span class="comment">[B] get();</span></span><br><span class="line"><span class="comment">[B] get();</span></span><br><span class="line"><span class="comment">[A] get();</span></span><br><span class="line"><span class="comment">[B] get();</span></span><br><span class="line"><span class="comment">[A] get();</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="私有的虚函数访问"><a href="#私有的虚函数访问" class="headerlink" title="私有的虚函数访问"></a>私有的虚函数访问</h5><p>指针是父类类型时，在父类中调用一个子类中重写过的虚函数（父类中当然定义了），实际上调用的是子类中的那个版本，即便它是 <code>private</code> 的，依然能够执行。（跨类访问私有函数）</p><h5 id="具体类和抽象类"><a href="#具体类和抽象类" class="headerlink" title="具体类和抽象类"></a>具体类和抽象类</h5><p>抽象类：有纯虚函数（<code>virtual</code> 函数 <code>=0</code>），也叫抽象函数。</p><p>具体类和抽象类的子类既可以是具体类也可以是抽象类。</p><p>纯抽象类：除了静态、构造、析构函数均为纯虚函数。</p><p>接口类：<strong>纯抽象类</strong>，成员均为 <code>public static</code>。</p><p>【!】纯虚函数可以在类外给出定义（当然可以不定义），例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> variable;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> variable): <span class="built_in">variable</span>(variable) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">abstractFunction</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::abstractFunction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，抽象类不能被实例化，所以个人感觉没什么意义。</p><p>继承自抽象类后没有实现对应的抽象函数子类就还是抽象类。</p><h5 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h5><p><code>typeid(exp_or_type)</code>：类型比较。</p><p><code>dynamic_cast&lt;T&gt;(exp)</code>：父类转子类，T 为指针类型失败返回 nullptr，T 为引用类型失败产生异常。</p><h5 id="关于虚函数一些例子"><a href="#关于虚函数一些例子" class="headerlink" title="关于虚函数一些例子"></a>关于虚函数一些例子</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 父类定义为虚函数后，子类重写时 virtual 关键字可省略 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> variable;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> variable): <span class="built_in">variable</span>(variable) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[A] get();\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> variable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(): <span class="built_in">A</span>(<span class="number">1024</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[B] get();\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> variable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* object = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    object-&gt;<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[B] get();</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 仅仅定义子类重写的函数是虚函数无效 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> variable;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> variable): <span class="built_in">variable</span>(variable) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[A] get();\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> variable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(): <span class="built_in">A</span>(<span class="number">1024</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[B] get();\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> variable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* object = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    object-&gt;<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[A] get();</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 父类类型的指针不能用于访问子类中特有的函数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> variable;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> variable): <span class="built_in">variable</span>(variable) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[A] get();\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> variable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(): <span class="built_in">A</span>(<span class="number">1024</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[B] get();\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> variable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* object = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    object-&gt;<span class="built_in">getB</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">error: no member named &#x27;getB&#x27; in &#x27;A&#x27;; did you mean &#x27;get&#x27;?</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h5><p>越想越觉得虚函数和抽象函数并不是完全没有联系，<code>virtual</code> 关键字就好像告诉我们尽可能地不使用当前类的代码而去使用子类的实现，不同之处在于抽象函数不允许子类没实现而虚函数给了一个子类没实现时的保底。</p><h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><p>定义：相同的消息请求，执行不同的代码体，产生不同的结果。</p><p>静态多态：根据<strong>静态类型</strong>确定执行的代码，如<strong>模版</strong>和<strong>函数重载</strong>。</p><p>动态多态：根据目标对象<strong>动态类型</strong>和参数表<strong>静态类型</strong>确定执行的代码，如<strong>虚机制</strong>。</p><h5 id="使用虚机制"><a href="#使用虚机制" class="headerlink" title="使用虚机制"></a>使用虚机制</h5><p>面向对象编程，使用父类指针执行子类代码。</p><h5 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h5><p>拷贝构造函数不能是虚函数，静态类型和动态类型不同，如何复制呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定义虚函数 clone()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> a = <span class="number">32</span>): <span class="built_in">a</span>(a) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> A* <span class="title">clone</span><span class="params">()</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;clone A&quot;</span>); <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">A</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="built_in">B</span>(<span class="keyword">int</span> b = <span class="number">64</span>): <span class="built_in">b</span>(b) &#123;&#125;</span><br><span class="line">    <span class="function">B* <span class="title">clone</span><span class="params">()</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;clone B&quot;</span>); <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">B</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* t = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    A* t0 = t-&gt;<span class="built_in">clone</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">clone B</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>如果有多个函数，每个函数有若干种实现，则子类个数为它们相乘。</p><p>【解决方案】在类中定义三个变量指向三个新类，每个新类定义一个虚函数，通过继承该类实现这个函数，调用函数时调用对应成员变量的成员函数即可，这样子类个数为各个函数实现方案数的和。</p><h5 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h5><p>懒得看，鸵鸟法可知这一章没什么东西（doge</p><h3 id="一些好玩的"><a href="#一些好玩的" class="headerlink" title="一些好玩的"></a>一些好玩的</h3><p>【开玩笑的】隐藏运算符：趋向于（雾）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> t; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--&gt;<span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> = <span class="number">2</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = *((<span class="keyword">char</span>*)(&amp;a) - <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">func</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数省略形式参数名：<a href="https://blog.csdn.net/C0631xjn_/article/details/127280342">https://blog.csdn.net/C0631xjn_/article/details/127280342</a></p><p>类中静态变量初始化：<a href="https://blog.csdn.net/qq_50868258/article/details/123139071">https://blog.csdn.net/qq_50868258/article/details/123139071</a></p><p>类中静态变量初始化：<a href="https://blog.csdn.net/sevenjoin/article/details/81772792">https://blog.csdn.net/sevenjoin/article/details/81772792</a></p><p>虚函数：<a href="https://zhuanlan.zhihu.com/p/28530472">https://zhuanlan.zhihu.com/p/28530472</a></p><p>explicit 关键字与离谱的 C++：<a href="https://zhuanlan.zhihu.com/p/52152355">https://zhuanlan.zhihu.com/p/52152355</a></p><p>shared_ptr：<a href="https://zhuanlan.zhihu.com/p/547647844">https://zhuanlan.zhihu.com/p/547647844</a></p><p>UML：<a href="https://zhuanlan.zhihu.com/p/109655171">https://zhuanlan.zhihu.com/p/109655171</a></p><p>虚继承内存空间安排：<a href="https://blog.csdn.net/SuLiJuan66/article/details/48897867">https://blog.csdn.net/SuLiJuan66/article/details/48897867</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;照学校课件打的，大概率没什么意思，有空再修改。&lt;/p&gt;
&lt;h3 id=&quot;C-程序结构&quot;&gt;&lt;a href=&quot;#C-程序结构&quot; class=&quot;headerlink&quot; title=&quot;C++ 程序结构&quot;&gt;&lt;/a&gt;C++ 程序结构&lt;/h3&gt;&lt;h5 id=&quot;多文件编译&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://whz0325.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://whz0325.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>6.S081 实验笔记</title>
    <link href="https://whz0325.github.io/6.s081-lab/"/>
    <id>https://whz0325.github.io/6.s081-lab/</id>
    <published>2023-04-06T14:41:00.000Z</published>
    <updated>2023-04-08T14:35:18.329Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-实验环境"><a href="#0x00-实验环境" class="headerlink" title="0x00 实验环境"></a>0x00 实验环境</h3><p>设备：MacBook Pro (Apple Silicon), macOS Ventura 13.3.</p><p>执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew install qemu</span><br><span class="line">brew tap riscv/riscv</span><br><span class="line">brew install riscv-tools</span><br></pre></td></tr></table></figure><p>需要等待一会儿，大概半个小时不到，期间 CPU 会跑满，温度也会飙升（虽然基本体感不到），好在顺利安装完成。</p><p>进入 <code>xv6-riscv</code> 所在的目录，执行 <code>make qemu</code> 即可运行，按 <code>ctrl+a</code> 后再按 <code>x</code> 退出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;0x00-实验环境&quot;&gt;&lt;a href=&quot;#0x00-实验环境&quot; class=&quot;headerlink&quot; title=&quot;0x00 实验环境&quot;&gt;&lt;/a&gt;0x00 实验环境&lt;/h3&gt;&lt;p&gt;设备：MacBook Pro (Apple Silicon), macOS Vent</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://whz0325.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="RISC-V" scheme="https://whz0325.github.io/tags/RISC-V/"/>
    
    <category term="操作系统" scheme="https://whz0325.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="macOS" scheme="https://whz0325.github.io/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>Linux 笔记</title>
    <link href="https://whz0325.github.io/linux-notes/"/>
    <id>https://whz0325.github.io/linux-notes/</id>
    <published>2023-04-04T13:04:00.000Z</published>
    <updated>2023-04-04T14:41:54.895Z</updated>
    
    <content type="html"><![CDATA[<p>选修了一门 Linux，虽然很忙，但是很有收获，学的东西很零散，所以整理一下。</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><h5 id="echo-命令"><a href="#echo-命令" class="headerlink" title="echo 命令"></a>echo 命令</h5><ul><li><code>-e</code></li></ul><h5 id="cat-concatenate-命令"><a href="#cat-concatenate-命令" class="headerlink" title="cat(concatenate) 命令"></a>cat(concatenate) 命令</h5><h5 id="wc-word-count-命令"><a href="#wc-word-count-命令" class="headerlink" title="wc(word count) 命令"></a>wc(word count) 命令</h5><ul><li><code>-l</code></li></ul><h3 id="脚本编程"><a href="#脚本编程" class="headerlink" title="脚本编程"></a>脚本编程</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;选修了一门 Linux，虽然很忙，但是很有收获，学的东西很零散，所以整理一下。&lt;/p&gt;
&lt;h3 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;目录结构&lt;/h3&gt;&lt;h3 id=&quot;基本命令&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://whz0325.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://whz0325.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【蓝桥杯 2022】最优清零方案</title>
    <link href="https://whz0325.github.io/lanqiao-2022-i/"/>
    <id>https://whz0325.github.io/lanqiao-2022-i/</id>
    <published>2023-04-02T06:27:00.000Z</published>
    <updated>2023-04-02T06:37:06.201Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个长度为 $n$ 的序列 ${a_i}$ 和一个整数 $k$，一次操作可以将连续 $k$ 个整数减一或者将一个整数减一，求将所有整数变为 $0$ 的最少操作次数。</p><p>$1\le k\le n\le 10^6$，$0\le a_i\le 10^6$。</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>啊，这题，我咋不会啊……</p><p>贪心策略是从左到右尽可能减连续 $k$ 个整数，操作次数和剩下零散的数加起来。</p><p>为啥是对的？如果我们要减连续 $k$ 个整数当然是越靠前越好，这样后面说不定可以再减一次，因为无论在哪里减对总和的影响都是相同的，如果在前面减区间的 $min$ 值更小，也不会妨碍后面有重叠的区间将少减的这几次补上。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">    <span class="keyword">static</span> BufferedWriter out = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] a, tg, min; <span class="keyword">static</span> <span class="keyword">long</span>[] sum;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l == r) &#123; tg[o] = <span class="number">0</span>; sum[o] = min[o] = a[mid]; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            build(o &lt;&lt; <span class="number">1</span>, l, mid); build(o &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">            min[o] = Math.min(min[o &lt;&lt; <span class="number">1</span>], min[o &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">            sum[o] = sum[o &lt;&lt; <span class="number">1</span>] + sum[o &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> ql, qr;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> min[o];</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(tg[o] != <span class="number">0</span>) &#123;</span><br><span class="line">            tg[o &lt;&lt; <span class="number">1</span>] += tg[o];</span><br><span class="line">            tg[o &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += tg[o];</span><br><span class="line">            min[o &lt;&lt; <span class="number">1</span>] += tg[o];</span><br><span class="line">            min[o &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += tg[o];</span><br><span class="line">            sum[o &lt;&lt; <span class="number">1</span>] += (<span class="keyword">long</span>)tg[o] * (mid - l + <span class="number">1</span>);</span><br><span class="line">            sum[o &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += (<span class="keyword">long</span>)tg[o] * (r - mid);</span><br><span class="line">            tg[o] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= mid) ans = Math.min(ans, getMin(o &lt;&lt; <span class="number">1</span>, l, mid));</span><br><span class="line">        <span class="keyword">if</span>(mid + <span class="number">1</span> &lt;= qr) ans = Math.min(ans, getMin(o &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr) &#123;</span><br><span class="line">            tg[o] += x;</span><br><span class="line">            min[o] += x;</span><br><span class="line">            sum[o] += (<span class="keyword">long</span>)x * (r - l + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(tg[o] != <span class="number">0</span>) &#123;</span><br><span class="line">                tg[o &lt;&lt; <span class="number">1</span>] += tg[o];</span><br><span class="line">                tg[o &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += tg[o];</span><br><span class="line">                min[o &lt;&lt; <span class="number">1</span>] += tg[o];</span><br><span class="line">                min[o &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += tg[o];</span><br><span class="line">                sum[o &lt;&lt; <span class="number">1</span>] += (<span class="keyword">long</span>)tg[o] * (mid - l + <span class="number">1</span>);</span><br><span class="line">                sum[o &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += (<span class="keyword">long</span>)tg[o] * (r - mid);</span><br><span class="line">                tg[o] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ql &lt;= mid) modify(o &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">            <span class="keyword">if</span>(mid + <span class="number">1</span> &lt;= qr) modify(o &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">            min[o] = Math.min(min[o &lt;&lt; <span class="number">1</span>], min[o &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">            sum[o] = sum[o &lt;&lt; <span class="number">1</span>] + sum[o &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String s = in.readLine(); String[] ss = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(ss[<span class="number">0</span>]), k = Integer.parseInt(ss[<span class="number">1</span>]);</span><br><span class="line">        s = in.readLine(); ss = s.split(<span class="string">&quot; &quot;</span>); a = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = Integer.parseInt(ss[i - <span class="number">1</span>]);</span><br><span class="line">        tg = <span class="keyword">new</span> <span class="keyword">int</span>[n &lt;&lt; <span class="number">2</span>]; min = <span class="keyword">new</span> <span class="keyword">int</span>[n &lt;&lt; <span class="number">2</span>]; sum = <span class="keyword">new</span> <span class="keyword">long</span>[n &lt;&lt; <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">0</span>; build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i + k - <span class="number">1</span> &lt;= n; ++i) &#123;</span><br><span class="line">            ql = i; qr = i + k - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> res = getMin(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">            <span class="keyword">if</span>(res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans += res; x = -res;</span><br><span class="line">                modify(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += sum[<span class="number">1</span>];</span><br><span class="line">        out.write(String.format(<span class="string">&quot;%d\n&quot;</span>, ans));</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一个长度为 $n$ 的序列 ${a_i}$ 和一个整数 $k$，一次操作可以将连续 $k$ 个整数减一或者将一个整数减一</summary>
      
    
    
    
    <category term="竞赛题解" scheme="https://whz0325.github.io/categories/%E7%AB%9E%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="线段树" scheme="https://whz0325.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="贪心法" scheme="https://whz0325.github.io/tags/%E8%B4%AA%E5%BF%83%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【蓝桥杯 2022】推导部分和</title>
    <link href="https://whz0325.github.io/lanqiao-2022-j/"/>
    <id>https://whz0325.github.io/lanqiao-2022-j/</id>
    <published>2023-04-02T06:17:00.000Z</published>
    <updated>2023-04-02T06:25:55.319Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个长度为 $n$ 的未知序列 ${a_i}$，已知 $m$ 个条件 $l_i, r_i,S_i$，表示 $a_{l_i}+a_{l_i + 1}+\dots +a_{r_i}$ 的和为 $S_i$，要实现 $q$ 次询问，每次询问 $a_l+a_{l+1}+\dots +a_r$ 的值，若无解则输出 UNKNOWN。</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>将区间和拆成前缀和，每一个条件相当于告诉我们，一旦知道 $l_i-1$ 和 $r_i$ 中任何一个下标的前缀和，另一个下标的前缀和也能够得到，这个二元关系可以使用带权并查集来维护，每个点记录它到父节点的区间和，若 $l-1$ 与 $r$ 不连通则说明无解。</p><p>某辣鸡网站有锅，交两次相同代码一次 TLE 一次 AC。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">    <span class="keyword">static</span> BufferedWriter out = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] fa; <span class="keyword">static</span> <span class="keyword">long</span>[] val;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rt = x; ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(fa[rt] != rt) &#123; arr.add(rt); rt = fa[rt]; &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            x = arr.get(i);</span><br><span class="line">            val[x] += val[fa[x]];</span><br><span class="line">            fa[x] = rt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String s = in.readLine(); String[] ss = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(ss[<span class="number">0</span>]), m = Integer.parseInt(ss[<span class="number">1</span>]), q = Integer.parseInt(ss[<span class="number">2</span>]);</span><br><span class="line">        fa = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>]; val = <span class="keyword">new</span> <span class="keyword">long</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123; fa[i] = i; val[i] = <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="keyword">while</span>((m--) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = in.readLine(); ss = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> l = Integer.parseInt(ss[<span class="number">0</span>]), r = Integer.parseInt(ss[<span class="number">1</span>]); <span class="keyword">long</span> S = Long.parseLong(ss[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">int</span> x = find(l - <span class="number">1</span>), y = find(r);</span><br><span class="line">            <span class="keyword">if</span>(x != y) &#123;</span><br><span class="line">                val[y] = val[l - <span class="number">1</span>] + S - val[r];</span><br><span class="line">                fa[y] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>((q--) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = in.readLine(); ss = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> l = Integer.parseInt(ss[<span class="number">0</span>]), r = Integer.parseInt(ss[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">int</span> x = find(l - <span class="number">1</span>), y = find(r);</span><br><span class="line">            <span class="keyword">if</span>(x != y) out.write(<span class="string">&quot;UNKNOWN\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> out.write(String.format(<span class="string">&quot;%d\n&quot;</span>, val[r] - val[l - <span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一个长度为 $n$ 的未知序列 ${a_i}$，已知 $m$ 个条件 $l_i, r_i,S_i$，表示 $a_{l_i</summary>
      
    
    
    
    <category term="竞赛题解" scheme="https://whz0325.github.io/categories/%E7%AB%9E%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="并查集" scheme="https://whz0325.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="图论" scheme="https://whz0325.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【CF 1798F】Gifts from Grandfather Ahmed</title>
    <link href="https://whz0325.github.io/cf-1798f/"/>
    <id>https://whz0325.github.io/cf-1798f/</id>
    <published>2023-03-29T02:31:00.000Z</published>
    <updated>2023-03-29T03:02:08.541Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>有 $n+1$ 个数 ${a_i}$，分成 $k$ 组，其中第 $i$ 组分得的数之和必须为 $s_i$ 的倍数，保证 $\sum s_i=n+1$，第 $n+1$ 个数丢失，要给出任一满足条件的 $a_{n+1}$ 的值和分组方案。</p><p>$1\le n,k\le 200$，$1\le a_i\le 10^6$。</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>有一个称为 Erdős–Ginzburg–Ziv theorem 的结论，它说任意 $2n-1$ 个数一定能选出 $n$ 个数是 $n$ 的倍数。</p><p>我们将 $s_i$ 排序，那么有 $s_1\le s_2\le\dots\le s_k$，假设选到第 $i$ 个数，一定有 $\sum_{k=i}^ns_k\gt2s_i-1$，这表明前 $k-1$ 组的方案一定存在，对于第 $k$ 组我们保留了 $a_{n+1}$ 用于弥补余数使它整除 $s_k$，因此不存在无解的情况。</p><p>考虑用 DP 的方法先将前 $k-1$ 组的方案分别求出，就可以构造出第 $k$ 组的方案了。</p><p>问题转化为当前有 $a_0$ 个整数 $a_1,a_2,\dots,a_{a_0}$，从中选出 $s_i$ 个数，使这些数的和整除 $s_i$ 的任一方案。</p><p>设 $f[x][y][z]$ 表示前 $x$ 个整数中能否选出 $y$ 个数使得这些数模 $s_i$ 的余数为 $z$，转移考虑第 $i$ 个数填或者不填两种情况。</p><p>如何得到方案数呢？首先，正序依次贪心取很可能最后得不到解。逆序的话，$f[x][y][z]$ 存在解并不代表 $x$ 应当被选，因为它可能是从 $f[x-1][y][z]$ 转移而来的（即前面的数被选，对应状态中表示的前 $x$ 个整数，但倘若不这样设计状态转移的复杂度就不能够做到 $O(1)$）。这里我们判断如果 $f[x-1][y][z]$ 为 <code>false</code>，$f[x][y][z]$ 为 <code>true</code> 时才选择 $x$。</p><p>也可以判断它不能够从 $x$ 被选的上一个状态转移而来，即将代码实现中第 $35$ 行的 <code>f[x - 1][y][z]</code> 改为 <code>!f[x - 1][y - 1][(z + si - (a[x] % si)) % si]</code>，分别对应可任取的两种方案。</p><p>时间复杂度大约是 $O(n^4)$。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 205</span></span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">int</span> a[N], tmp[N]; P s[N]; <span class="keyword">bool</span> f[N][N][N];</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; ans[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k; <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    a[<span class="number">0</span>] = n; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i].first);</span><br><span class="line">        s[i].second = i;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(s + <span class="number">1</span>, s + <span class="number">1</span> + k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> si = s[i].first, idx = s[i].second;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f)); f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= a[<span class="number">0</span>]; ++x) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt;= si; ++y) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> z = <span class="number">0</span>; z &lt; si; ++z) &#123;</span><br><span class="line">                    f[x][y][z] = f[x - <span class="number">1</span>][y][z];</span><br><span class="line">                    <span class="keyword">if</span>(y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        f[x][y][z] |= f[x - <span class="number">1</span>][y - <span class="number">1</span>][(z + si - (a[x] % si)) % si];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tmp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = a[<span class="number">0</span>], y = si, z = <span class="number">0</span>; x &gt;= <span class="number">1</span>; --x) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!y || !f[x][y][z] || f[x - <span class="number">1</span>][y][z]) &#123;</span><br><span class="line">                tmp[++tmp[<span class="number">0</span>]] = a[x];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --y; z = (z + si - a[x] % si) % si;</span><br><span class="line">            ans[idx].<span class="built_in">push_back</span>(a[x]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, end = tmp[<span class="number">0</span>]; i &lt;= end; ++i) a[i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> si = s[k].first, idx = s[k].second, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= a[<span class="number">0</span>]; ++x) &#123;</span><br><span class="line">        sum = (sum + a[x]) % si;</span><br><span class="line">        ans[idx].<span class="built_in">push_back</span>(a[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    ans[idx].<span class="built_in">push_back</span>(si - sum);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, si - sum);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>, end = ans[i].<span class="built_in">size</span>(); j &lt; end; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, ans[i][j], (j ^ (end - <span class="number">1</span>)) ? <span class="string">&#x27; &#x27;</span> : <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;有 $n+1$ 个数 ${a_i}$，分成 $k$ 组，其中第 $i$ 组分得的数之和必须为 $s_i$ 的倍数，保证 $\</summary>
      
    
    
    
    <category term="竞赛题解" scheme="https://whz0325.github.io/categories/%E7%AB%9E%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="动态规划" scheme="https://whz0325.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>【CF 1798E】Multitest Generator</title>
    <link href="https://whz0325.github.io/cf-1798e/"/>
    <id>https://whz0325.github.io/cf-1798e/</id>
    <published>2023-03-28T14:16:00.000Z</published>
    <updated>2023-03-28T14:52:15.139Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>定义一个序列为 test 仅当序列的第一个元素为这个序列剩下元素的长度。</p><p>定义一个序列为 multitest 仅当该序列的第一个数为能够将剩下元素组成的序列拆成的 test 的个数。</p><p>定义一次修改操作可以将序列中任意元素修改为任意一个非负整数。</p><p>定义函数 $f(A)$ 为将序列修改为 multitest 的最少操作次数。</p><p>给定一个长度为 $n$ 的序列 ${a_n}$，输出 $f([a_i, a_{i+1},\dots ,a_n])$ 当 $i\in [1,n-1]$ 的值。</p><p>$2\le n\le 300000$，$1\le a_i\le 300000$。</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>一开始想错了，还以为是特别水那种 DP。</p><p>构造一种方案：将第一个元素修改为 $1$，第二个元素修改为 $n-2$，因此对于任意序列，最少操作次数不会超过 $2$。</p><p>分类讨论：</p><p>什么情况下 $f(A)$ 的值为 $0$：定义 $f[i][0]$ 为以下标 $i$ 起始的后缀不进行任何修改操作将序列分成的块数，若不能拆分为若干个 test 则值为 $0$，转移很好设计。$f[i+1][0]=a_i$ 时 $f([a_i,a_{i+1},\dots , a_n])$ 的值为 $0$。什么情况下 $f(A)$ 的值为 $1$：唯一一次修改会发生在两种位置。</p><p>第一种是在 multitest 的开始，即 $f[i+1][0]\neq a_i$ 时 $f([a_i,a_{i+1},\dots , a_n])$ 的值为 $1$。</p><p>第二种是在 multitest 中某个 test 的开头，这时定义 $f[i][1]$ 为以下标 $i$ 起始的后缀进行一次修改操作将序列分成的「最大」块数。为什么取最大呢？考虑转移时，要么修改过从 $f[i+a_i+1][1]$ 转移，要么没有修改过从 $f[j][0]$ 转移，这里的 $j$ 可以是 $[i+1,n]$ 中的任何值（对应将该数修改为 $[0,n-i-1]$，其实也可以修改为 $n-i$，这种情况用分成的 $1$ 块来更新 $f[i][1]$）。如果可以将序列分成 $b$ 块，则它一定能够分成 $a(a\le b)$ 块，因为我们可以考虑改变这一次修改的位置和值，从而将序列尾部的多个块合并。所以，在 $f[i+1][1]\ge a_i$ 时 $f([a_i,a_{i+1},\dots , a_n])$ 的值为 $1$。</p><p>（可能会感到疑惑，按照上面这种转移会不会包含把 $a_i$ 修改为 $a_i$ 的情况。确实会这样，不过不影响结果，因为这样符合题目要求而且我们要取的是最大值。）</p><p>其它情况下 $f(A)$ 的值为 $2$。</p><p>时间复杂度为 $O(n)$。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300005</span></span><br><span class="line"><span class="keyword">int</span> a[N], f[N][<span class="number">2</span>], ans[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">        <span class="keyword">if</span>(a[n] == <span class="number">0</span>) &#123; f[n][<span class="number">0</span>] = <span class="number">1</span>; f[n][<span class="number">1</span>] = <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; f[n][<span class="number">0</span>] = <span class="number">0</span>; f[n][<span class="number">1</span>] = <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="keyword">int</span> mxf0 = f[n][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i + a[i] + <span class="number">1</span> == n + <span class="number">1</span>) &#123;</span><br><span class="line">                f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i + a[i] + <span class="number">1</span> &lt;= n &amp;&amp; f[i + a[i] + <span class="number">1</span>][<span class="number">0</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                f[i][<span class="number">0</span>] = f[i + a[i] + <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> f[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            f[i][<span class="number">1</span>] = mxf0 + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i + a[i] + <span class="number">1</span> &gt; n + <span class="number">1</span>) f[i][<span class="number">1</span>] = std::<span class="built_in">max</span>(f[i][<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i + a[i] + <span class="number">1</span> &lt;= n &amp;&amp; f[i + a[i] + <span class="number">1</span>][<span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                f[i][<span class="number">1</span>] = std::<span class="built_in">max</span>(f[i][<span class="number">1</span>], f[i + a[i] + <span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(f[i + <span class="number">1</span>][<span class="number">0</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(f[i + <span class="number">1</span>][<span class="number">0</span>] == a[i]) ans[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> ans[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(f[i + <span class="number">1</span>][<span class="number">1</span>] &gt;= a[i]) ans[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> ans[i] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            mxf0 = std::<span class="built_in">max</span>(mxf0, f[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, ans[i], (i ^ (n - <span class="number">1</span>)) ? <span class="string">&#x27; &#x27;</span> : <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;定义一个序列为 test 仅当序列的第一个元素为这个序列剩下元素的长度。&lt;/p&gt;
&lt;p&gt;定义一个序列为 multitest </summary>
      
    
    
    
    <category term="竞赛题解" scheme="https://whz0325.github.io/categories/%E7%AB%9E%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="动态规划" scheme="https://whz0325.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>【蓝桥杯 2022】青蛙过河</title>
    <link href="https://whz0325.github.io/lanqiao-2022-g/"/>
    <id>https://whz0325.github.io/lanqiao-2022-g/</id>
    <published>2023-03-25T07:07:00.000Z</published>
    <updated>2023-03-25T08:33:37.059Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在 $[1,n-1]$ 之中的每个位置有一个权值 $H_i$，当经过时权值减一，权值为 $0$ 时不能经过，求最小的跳跃距离（每次移动的距离均不超过跳跃距离），使得能够在位置 $0$ 和位置 $n$ 之间往返 $2x$ 次。</p><p>$1\le n\le 10^5$，$1\le x\le 10^9$，$1\le H_i\le 10^4$。</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>一眼二分答案，重点在于如何判断对于给定的跳跃距离 $y$ 是否能够往返 $2x$ 次。</p><p>第一种思路是判断每一个长度为 $y$ 的区间中的权值和是否都不低于 $2x$，如果低于则不能够往返，感性证明：</p><p>分别证充分性和必要性。对于任意长度为 $y$ 的区间，$2x$ 次往返中的每一次必经过一次该区间内的点，反证若不经过则最小跳跃距离应当超过 $y$，所以区间内的权值和至少应当是 $2x$。对于每个位置，能够跳到的位置必然是它后面长度为 $y$ 的区间中的位置，如果区间中的权值和不低于 $2x$ 则一定能让至少 $2x$ 次跑出去（位置 $n$ 也能够接收到前面 $2x$ 次）。</p><p>并不是非常好想，第二种思路则更为自然。</p><p>类似网络流的思想，把每个点推给它后面能到达的这 $y$ 个点，推到最后统计能够到达位置 $n$ 的次数是否达到 $2x$ 次（其实就相当于所有次数一齐跳）。推的过程肯定不能一个一个递，用并查集优化，一旦有权值 $H_i$ 满了，不能够再经过了则将它跳过，时间复杂度为 $O(nlog_2n)$。</p><p>注意 Java 在并查集 <code>find</code> 函数递归层数过多时会爆栈，因此采用非递归实现。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>算法一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n, x, h[];</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = y; i &lt; n; ++i) <span class="keyword">if</span>(h[i] - h[i - y] &lt; x) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n = in.nextInt(); x = in.nextInt() &lt;&lt; <span class="number">1</span>; h = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        h[<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) h[i] = h[i - <span class="number">1</span>] + in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(mid)) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n, x, h[], contain[], fa[];</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rt = x;</span><br><span class="line">        <span class="keyword">while</span>(rt != fa[rt]) rt = fa[rt];</span><br><span class="line">        <span class="keyword">while</span>(x != fa[x]) &#123;</span><br><span class="line">            fa[x] = rt;</span><br><span class="line">            x = fa[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        contain = <span class="keyword">new</span> <span class="keyword">int</span>[n]; contain[<span class="number">0</span>] = x;</span><br><span class="line">        fa = <span class="keyword">new</span> <span class="keyword">int</span>[n]; fa[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) fa[i] = (h[i] &gt; <span class="number">0</span> ? i : find(i - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span>(contain[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> loc = find(Math.min(i + y, n - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">while</span>(loc &gt; i &amp;&amp; contain[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> flow = Math.min(contain[i], h[loc] - contain[loc]);</span><br><span class="line">                contain[loc] += flow; contain[i] -= flow;</span><br><span class="line">                <span class="keyword">if</span>(h[loc] - contain[loc] == <span class="number">0</span>) fa[loc] = find(loc - <span class="number">1</span>);</span><br><span class="line">                loc = find(loc - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - y; i &lt; n; ++i) sum += contain[i];</span><br><span class="line">        <span class="keyword">return</span> sum &gt;= x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n = in.nextInt(); x = in.nextInt() &lt;&lt; <span class="number">1</span>; h = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) h[i] = in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(mid)) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;在 $[1,n-1]$ 之中的每个位置有一个权值 $H_i$，当经过时权值减一，权值为 $0$ 时不能经过，求最小的跳跃距离</summary>
      
    
    
    
    <category term="竞赛题解" scheme="https://whz0325.github.io/categories/%E7%AB%9E%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="二分法" scheme="https://whz0325.github.io/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
    <category term="贪心法" scheme="https://whz0325.github.io/tags/%E8%B4%AA%E5%BF%83%E6%B3%95/"/>
    
    <category term="并查集" scheme="https://whz0325.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>【蓝桥杯 2022】GCD</title>
    <link href="https://whz0325.github.io/lanqiao-2022-d/"/>
    <id>https://whz0325.github.io/lanqiao-2022-d/</id>
    <published>2023-03-25T02:51:00.000Z</published>
    <updated>2023-03-25T02:59:39.957Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>求最小的 $k$，使得 $gcd(a+k,b+k)$ 的值最大。</p><p>$1\le a\lt b\le 10^{18}$。</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>数论忘光了，思博选手不会写数学题。。。</p><p>首先有 $gcd(a,b)=gcd(b,a-b)$，很好理解：$a=gc$，$b=gd$ 的话 $a-b=g(c-d)$ 依然是两者最大公约数的倍数，这就是辗转相除法的基础。</p><p>那么，有 $gcd(a+k,b+k)=gcd(a-b,a+k)$ 且 $gcd(a+k,b+k)=gcd(a-b,b+k)$，一定能构造出 $g=a-b$ 的解，取 $a-b|a+k$ 和 $a-b|b+k$ 中最小的 $k$ 即可。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">long</span> a = in.nextLong(), b = in.nextLong(), d = Math.abs(a - b);</span><br><span class="line">        System.out.println(Math.min(d - a % d, d - b % d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;求最小的 $k$，使得 $gcd(a+k,b+k)$ 的值最大。&lt;/p&gt;
&lt;p&gt;$1\le a\lt b\le 10^{18</summary>
      
    
    
    
    <category term="竞赛题解" scheme="https://whz0325.github.io/categories/%E7%AB%9E%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="数论" scheme="https://whz0325.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>3月做题记录</title>
    <link href="https://whz0325.github.io/2023-03-22/"/>
    <id>https://whz0325.github.io/2023-03-22/</id>
    <published>2023-03-22T05:45:00.000Z</published>
    <updated>2023-04-02T06:26:39.132Z</updated>
    
    <content type="html"><![CDATA[<h5 id="【HAOI-2009】逆序对数列"><a href="#【HAOI-2009】逆序对数列" class="headerlink" title="【HAOI 2009】逆序对数列"></a>【HAOI 2009】逆序对数列</h5><p>看到 DP 的标签还挺好想的，用前缀和优化一下转移就可以 $O(n^2)$ 了，老年选手一开始把 $i$ 插入后最多产生的逆序对数错算成 $i$ 了（应该是 $i-1$ 嘛），WA 了一发……TAT</p><h5 id="【HEOI-2015】兔子与樱花"><a href="#【HEOI-2015】兔子与樱花" class="headerlink" title="【HEOI 2015】兔子与樱花"></a>【HEOI 2015】兔子与樱花</h5><p>退化了，看了以前的题解，每个点被删除的代价是它的樱花值与其没有没删除的子节点个数之和，当然删除一个子节点后父节点的代价除了要加上子节点的代价外还要减去这个子节点贡献给子节点个数的代价 $1$，每个节点被删去的奖励相同，那么就选所有子节点中代价最小的节点优先删去就好了。</p><h5 id="【UVa-120】Stacks-of-Flapjacks"><a href="#【UVa-120】Stacks-of-Flapjacks" class="headerlink" title="【UVa 120】Stacks of Flapjacks"></a>【UVa 120】Stacks of Flapjacks</h5><p>《入门经典》上的题，本来想练 Java 的结果不小心写了 C++，又用 Java 交了一发。</p><p><code>sscanf</code> 中用 <code>%n</code> 获取偏移量，需要累加，<code>fgets</code> 用来读取整行。</p><h5 id="【UVa-1605】Building-for-UN"><a href="#【UVa-1605】Building-for-UN" class="headerlink" title="【UVa 1605】Building for UN"></a>【UVa 1605】Building for UN</h5><p>用来练 Java，居然是多组数据……</p><h5 id="【UVa-1152】Values-whose-Sum-is-0"><a href="#【UVa-1152】Values-whose-Sum-is-0" class="headerlink" title="【UVa 1152】Values whose Sum is 0"></a>【UVa 1152】Values whose Sum is 0</h5><p>Java 写的，练 HashMap，注意最后一组数据结尾没有空行。</p><h5 id="蓝桥杯-2022-省赛-A组"><a href="#蓝桥杯-2022-省赛-A组" class="headerlink" title="蓝桥杯 2022 省赛 A组"></a>蓝桥杯 2022 省赛 A组</h5><p>感觉自己确实老了，有点训练价值的两题写了题解，求逆元可以用 $x^{p-2}$ 快速幂求（模数为质数，欧拉定理），Java 递归层数多了会爆栈，并查集要用非递归写。</p><h5 id="【HAOI-2008】-糖果传递"><a href="#【HAOI-2008】-糖果传递" class="headerlink" title="【HAOI 2008】 糖果传递"></a>【HAOI 2008】 糖果传递</h5><p>感觉可能在哪儿做过，$x_i$ 表示 $i$ 向左传递的糖果数，列出方程组，可以把问题转化为使数轴上若干点到 $x_1$ 距离和最小，即 $\sum |x_1+C_i|$ 的形式，这时 $x_1$ 应当取中位数。</p><h5 id="【LG-P1484】种树"><a href="#【LG-P1484】种树" class="headerlink" title="【LG P1484】种树"></a>【LG P1484】种树</h5><p>可能是没见过的思路……用双向链表实现贪心的反悔操作，因为选择两边的点后距离为两边之外的相邻点不能选，与把包含两边点的整体作为一个点影响相同。</p><p>（还有长链剖分的做法，贪心的证明，需要补一份题解。）</p><h5 id="【UVa-11134】Fabled-Rocks"><a href="#【UVa-11134】Fabled-Rocks" class="headerlink" title="【UVa 11134】Fabled Rocks"></a>【UVa 11134】Fabled Rocks</h5><p>一开始想错了，按右端点排序后左端点顺序可能不定，所以应当从左往右一个一个尽可能地填，无法一一对应，话说是不是也可以用并查集优化……</p><h5 id="【UVa-11054】Wine-trading-in-Gergovia"><a href="#【UVa-11054】Wine-trading-in-Gergovia" class="headerlink" title="【UVa 11054】Wine trading in Gergovia"></a>【UVa 11054】Wine trading in Gergovia</h5><p>水题，【HAOI 2008】糖果传递 弱化版。</p><h5 id="Codeforces-Round-860-Div-2"><a href="#Codeforces-Round-860-Div-2" class="headerlink" title="Codeforces Round 860 (Div. 2)"></a>Codeforces Round 860 (Div. 2)</h5><p>最后一分钟交过了第四题，真刺激，虽然打得并不好……明天补题吧……</p><h5 id="【CF-1798E】Multitest-Generator"><a href="#【CF-1798E】Multitest-Generator" class="headerlink" title="【CF 1798E】Multitest Generator"></a>【CF 1798E】Multitest Generator</h5><p>补题，写了题解。</p><h5 id="【CF-1798F】Gifts-from-Grandfather-Ahmed"><a href="#【CF-1798F】Gifts-from-Grandfather-Ahmed" class="headerlink" title="【CF 1798F】Gifts from Grandfather Ahmed"></a>【CF 1798F】Gifts from Grandfather Ahmed</h5><p>没有见过的动态规划，写了题解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;【HAOI-2009】逆序对数列&quot;&gt;&lt;a href=&quot;#【HAOI-2009】逆序对数列&quot; class=&quot;headerlink&quot; title=&quot;【HAOI 2009】逆序对数列&quot;&gt;&lt;/a&gt;【HAOI 2009】逆序对数列&lt;/h5&gt;&lt;p&gt;看到 DP 的标签还挺好想的</summary>
      
    
    
    
    <category term="日志" scheme="https://whz0325.github.io/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>【CSP 2022】聚集方差</title>
    <link href="https://whz0325.github.io/csp-202212-4/"/>
    <id>https://whz0325.github.io/csp-202212-4/</id>
    <published>2023-03-12T11:14:00.000Z</published>
    <updated>2023-03-12T11:49:40.201Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一棵 $n$ 个节点的树，记以节点 $x$ 为根的子树组成集合为 $T(x)$，求 $\sum_{y\in T(x)}\min_{z\in T(x),z\neq y}(a_z-a_y)^2$。</p><p>$2\le n\le 3\times 10^5$，$0\le a_i\le 10^9$。</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>思维难度其实不大，对每个节点开一个集合，树上启发式合并就可以了。</p><p>怎么合并呢？不难发现插入新元素时会影响到的只有与它距离最近的两个节点的贡献，动态维护即可。</p><p>时间复杂度大概是 $O(nlog_2^2n)$。</p><p>题目的坑点在于卡常。</p><p>第一次是用 <code>multiset</code> 实现的，直接卡成 40 分的暴力，后来改成 <code>map</code> 变成 55 分（$a_i$ 值相同的点合并为一个），又优化了一下，把所有二分操作合并为一个才 A 掉。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300005</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">16</span>], *fs = buf, *ft = buf;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fs == ft) ft = (fs = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, <span class="number">1</span>&lt;&lt;<span class="number">16</span>, stdin);</span><br><span class="line">    <span class="keyword">return</span> *fs++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;num)</span> </span>&#123;</span><br><span class="line">    num = <span class="number">0</span>; c = <span class="built_in">gc</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c = <span class="built_in">gc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, a[N], id[N]; ll res[N], ans[N];</span><br><span class="line">std::map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; s[N];</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; son[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getDist</span><span class="params">(<span class="keyword">int</span> o, std::map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[o].<span class="built_in">size</span>() == <span class="number">1</span> || it-&gt;second &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX, x = it-&gt;first;</span><br><span class="line">    <span class="keyword">if</span>(it != s[o].<span class="built_in">begin</span>()) &#123;</span><br><span class="line">        --it;</span><br><span class="line">        ans = std::<span class="built_in">min</span>(ans, <span class="built_in">abs</span>(x - it-&gt;first));</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((++it) != s[o].<span class="built_in">end</span>()) ans = std::<span class="built_in">min</span>(ans, <span class="built_in">abs</span>(x - it-&gt;first));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[y].<span class="built_in">size</span>() &gt; s[x].<span class="built_in">size</span>()) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">    std::map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span>(it = s[y].<span class="built_in">begin</span>(); it != s[y].<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it0 = s[x].<span class="built_in">lower_bound</span>(it-&gt;first);</span><br><span class="line">        <span class="keyword">if</span>(it0 != s[x].<span class="built_in">end</span>() &amp;&amp; it0-&gt;first == it-&gt;first) &#123;</span><br><span class="line">            <span class="keyword">int</span> oldDist = <span class="built_in">getDist</span>(x, it0);</span><br><span class="line">            res[x] -= (ll)oldDist * oldDist;</span><br><span class="line">            s[x][it-&gt;first] += it-&gt;second;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nearest = it-&gt;second &gt; <span class="number">1</span> ? <span class="number">0</span> : INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(it0 != s[x].<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> newDist = <span class="built_in">abs</span>(it-&gt;first - it0-&gt;first);</span><br><span class="line">            <span class="keyword">if</span>(s[x][it0-&gt;first] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> oldDist = <span class="built_in">getDist</span>(x, it0);</span><br><span class="line">                <span class="keyword">if</span>(s[x].<span class="built_in">size</span>() == <span class="number">1</span> || oldDist &gt; newDist) &#123;</span><br><span class="line">                    res[x] -= (ll)oldDist * oldDist;</span><br><span class="line">                    res[x] += (ll)newDist * newDist;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nearest = std::<span class="built_in">min</span>(nearest, newDist);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(it0 != s[x].<span class="built_in">begin</span>()) &#123;</span><br><span class="line">            --it0;</span><br><span class="line">            <span class="keyword">int</span> newDist = <span class="built_in">abs</span>(it-&gt;first - it0-&gt;first);</span><br><span class="line">            <span class="keyword">if</span>(s[x][it0-&gt;first] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> oldDist = <span class="built_in">getDist</span>(x, it0);</span><br><span class="line">                <span class="keyword">if</span>(s[x].<span class="built_in">size</span>() == <span class="number">1</span> || oldDist &gt; newDist) &#123;</span><br><span class="line">                    res[x] -= (ll)oldDist * oldDist;</span><br><span class="line">                    res[x] += (ll)newDist * newDist;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nearest = std::<span class="built_in">min</span>(nearest, newDist);</span><br><span class="line">        &#125;</span><br><span class="line">        res[x] += (ll)nearest * nearest;</span><br><span class="line">        s[x][it-&gt;first] += it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ans[x] = <span class="number">0</span>; ++s[x][a[x]]; id[x] = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, end = son[x].<span class="built_in">size</span>(); i &lt; end; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = son[x][i];</span><br><span class="line">        <span class="built_in">calc</span>(v);</span><br><span class="line">        id[x] = <span class="built_in">merge</span>(id[x], id[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    ans[x] = res[id[x]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> p; <span class="built_in">read</span>(p);</span><br><span class="line">        son[p].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">calc</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给你一棵 $n$ 个节点的树，记以节点 $x$ 为根的子树组成集合为 $T(x)$，求 $\sum_{y\in T(x)}\</summary>
      
    
    
    
    <category term="竞赛题解" scheme="https://whz0325.github.io/categories/%E7%AB%9E%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="启发式合并" scheme="https://whz0325.github.io/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>【POJ 1064】Cable master</title>
    <link href="https://whz0325.github.io/poj-1064/"/>
    <id>https://whz0325.github.io/poj-1064/</id>
    <published>2023-03-08T02:20:00.000Z</published>
    <updated>2023-03-08T05:35:35.730Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定 $n$ 条长度分别为 $a_i$ 的绳子，求切出 $k$ 条完整绳子的最大长度。</p><p>$1\le n\le 10^4$，$1\le k\le 10^4$，$a_i$ 有两位小数。</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>二分答案，在长度为 $d$ 时能切出 $k$ 条完整的绳子显然在长度小于 $d$ 时也能做到，答案具有单调性。</p><p>重点是实现时考虑浮点运算精度问题，刚开始注意到 <code>printf</code> 在保留位数是会自动四舍五入，为了得到舍掉两位小数后的全部低位，在结果最后额外减去了 $0.005$，然而依然有浮点误差。</p><p>索性用整数实现，很快就解决了hhh，详细见代码。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>C++ 实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10005</span></span><br><span class="line"><span class="keyword">int</span> n,k,a[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) cnt+=a[i]/d;</span><br><span class="line">    <span class="keyword">return</span> cnt&gt;=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) &#123;<span class="keyword">double</span> d;<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;d);r=std::<span class="built_in">max</span>(r,a[i]=d*<span class="number">100</span>);&#125;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l=mid;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d.%02d\n&quot;</span>,l/<span class="number">100</span>,l%<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] a;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cnt += a[i] / d;</span><br><span class="line">        <span class="keyword">return</span> cnt &gt;= k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n = in.nextInt();</span><br><span class="line">        k = in.nextInt();</span><br><span class="line">        a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">double</span> d = in.nextDouble();</span><br><span class="line">            a[i] = (<span class="keyword">int</span>)(<span class="number">100.0</span> * d);</span><br><span class="line">            r = Math.max(r, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(mid)) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%d.%02d\n&quot;</span>,l / <span class="number">100</span>, l % <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定 $n$ 条长度分别为 $a_i$ 的绳子，求切出 $k$ 条完整绳子的最大长度。&lt;/p&gt;
&lt;p&gt;$1\le n\le </summary>
      
    
    
    
    <category term="竞赛题解" scheme="https://whz0325.github.io/categories/%E7%AB%9E%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="二分法" scheme="https://whz0325.github.io/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>如何在 macOS 下配置 Sublime Text 的可交互 Java 环境</title>
    <link href="https://whz0325.github.io/sublime-text-runs-java-on-macos/"/>
    <id>https://whz0325.github.io/sublime-text-runs-java-on-macos/</id>
    <published>2023-01-24T16:59:00.000Z</published>
    <updated>2023-04-07T09:41:43.073Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>因为报名了某个用到 Java 语言的程序设计竞赛，就想配置一个像之前用 C++ 时那样的 Sublime Text 快速编程环境，网上没有找到详细又简单的解决方案，于是花了些时间自己尝试了一个有些简陋的实现。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p><img src="../images/upload/sublime-text-runs-java-on-macos/1.png"></p><p>在 Sublime Text 3 中新建 Build System，命名为 <code>Java Terminal.sublime-build</code>，写入如下配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;cmd&quot;</span>: [<span class="string">&quot;zsh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;javac &#x27;$&#123;file_name&#125;&#x27;&quot;</span>],</span><br><span class="line">    <span class="attr">&quot;file_regex&quot;</span>: <span class="string">&quot;^(...*?):([0-9]*):?([0-9]*)&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;selector&quot;</span>: <span class="string">&quot;source.java&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;variants&quot;</span>:</span><br><span class="line">    [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Run&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;shell&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">&quot;cmd&quot;</span>: [<span class="string">&quot;echo \&quot;clear &amp;&amp; cd &#x27;$&#123;file_path&#125;&#x27; &amp;&amp; javac &#x27;$&#123;file_name&#125;&#x27; &amp;&amp; java &#x27;$&#123;file_base_name&#125;&#x27; &amp;&amp; rm run.sh\&quot; &gt; run.sh &amp;&amp; chmod ugo+x run.sh &amp;&amp; open -a Terminal.app ./run.sh&quot;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../images/upload/sublime-text-runs-java-on-macos/2.png"></p><p>保存后即可用 <code>Command+B</code> 选取 <code>Java Terminal - Run</code> 运行测试。</p><p><img src="../images/upload/sublime-text-runs-java-on-macos/3.png"></p><p>对 macOS 下的一些参数不是很了解，所以这里的实现思路为：</p><ul><li>将要执行的命令写入 <code>run.sh</code>。</li><li>调用 Terminal 运行 <code>run.sh</code>。</li><li>在 <code>run.sh</code> 中执行 <code>javac</code> 和 <code>java</code> 命令，在程序执行完毕后删除 <code>run.sh</code>。</li></ul><p>撒花！🎉</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>又熬夜了。。。</p><p>另：修改了调用文件路径和文件名的格式防止出现存放在某些包含空格的路径就会出错的问题。</p><p>另：在 <code>run.sh</code> 中增加了一行清屏来屏蔽输入前产生的杂乱信息。</p><p>或许使用 FastOlympaidCoding 会更方便一些……【2023.4.7 17:39:00】</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;因为报名了某个用到 Java 语言的程序设计竞赛，就想配置一个像之前用 C++ 时那样的 Sublime Text 快速编程环境，网上没有找</summary>
      
    
    
    
    <category term="日志" scheme="https://whz0325.github.io/categories/%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="macOS" scheme="https://whz0325.github.io/tags/macOS/"/>
    
    <category term="Java" scheme="https://whz0325.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>在 macOS 系统中移除 Nix</title>
    <link href="https://whz0325.github.io/remove-nix-from-macos/"/>
    <id>https://whz0325.github.io/remove-nix-from-macos/</id>
    <published>2023-01-20T11:54:00.000Z</published>
    <updated>2023-01-20T12:49:53.977Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这两天想安装 Nix 用于处理一个转 midi 的程序，结果由于网络问题没完全安装成，卸载的过程比较艰难所以记录一下。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>在 <a href="https://github.com/NixOS/nix/issues/458">GitHub</a> 上找到了一个相关问题，链接到了一个<a href="https://iohk.zendesk.com/hc/en-us/articles/4415830650265-Uninstall-nix-on-MacOS">一年前的教程</a>，虽然有点复杂，但是打算参照这个教程试试看。</p><p>第一步，前往 <code>/etc/</code> 这个目录，可以看到存在教程中提到的 <code>zshrc.backup-before-nix</code> 和 <code>bashrc.backup-before-nix</code> 两个文件，直接用它们覆盖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mv /etc/zshrc.backup-before-nix /etc/zshrc</span><br><span class="line">sudo mv /etc/bashrc.backup-before-nix /etc/bashrc</span><br></pre></td></tr></table></figure><p>第二步，在终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vifs</span><br></pre></td></tr></table></figure><p>可以看到注释下面有一行与 Nix 相关，直接在 Vim 删去（$6$ 是行号）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:6d</span><br></pre></td></tr></table></figure><p>第三步，打开 <code>/etc/synthetic.conf</code>，里面只有一行，与 Nix 相关，按照教程直接删去：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /etc/synthetic.conf</span><br></pre></td></tr></table></figure><p>第四步，与教程略有不同，可能是我没安装完全的缘故，前往 <code>/Library/LaunchDaemons</code> 目录（注意比教程中多了个 <code>s</code>），看到有一个 <code>org.nixos</code> 开头的列表项，删除它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo launchctl unload /Library/LaunchDaemons/org.nixos.xxx.plist</span><br><span class="line">sudo rm /Library/LaunchDaemons/org.nixos.xxx.plist</span><br></pre></td></tr></table></figure><p>第五步，复制命令，移除所有相关文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /etc/nix /var/root/.nix-profile /var/root/.nix-defexpr /var/root/.nix-channels ~/.nix-profile ~/.nix-defexpr ~/.nix-channels</span><br></pre></td></tr></table></figure><p>第六步，继续在终端中复制命令执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo dscl . delete /Groups/nixbld</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 1 32); <span class="keyword">do</span> sudo dscl . -delete /Users/_nixbld<span class="variable">$i</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>最后一步，与教程中有所不同，参考 GitHub 上的方案，先重新启动，再执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo diskutil apfs deleteVolume /Volumes/Nix\ Store</span><br><span class="line">sudo rm -rf /nix/</span><br></pre></td></tr></table></figure><p>重新启动，撒花！🎉</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>必应 yyds！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这两天想安装 Nix 用于处理一个转 midi 的程序，结果由于网络问题没完全安装成，卸载的过程比较艰难所以记录一下。&lt;/p&gt;
&lt;h3 id</summary>
      
    
    
    
    <category term="日志" scheme="https://whz0325.github.io/categories/%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="macOS" scheme="https://whz0325.github.io/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>Java 语法笔记</title>
    <link href="https://whz0325.github.io/java-notes/"/>
    <id>https://whz0325.github.io/java-notes/</id>
    <published>2023-01-11T06:32:06.000Z</published>
    <updated>2023-05-22T11:23:42.425Z</updated>
    
    <content type="html"><![CDATA[<h3 id="版本问题"><a href="#版本问题" class="headerlink" title="版本问题"></a>版本问题</h3><p>写这篇笔记时 Oracle 官网上的最新的 JDK 版本是 Java 19，兼容 Apple Silicon，然而目前最常用的 Java 8 和 Java 11 还没有适配，可以使用 Zulu JDK，关于如何配置 Sublime Text 3 快速编写简单的 Java 程序可以参考 <a href="../sublime-text-runs-java-on-macos">如何在 macOS 下配置 Sublime Text 的可交互 Java 环境</a>，集成开发环境推荐 IntelliJ IDEA。</p><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><h5 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;<span class="comment">//注意分号</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(in.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>in.next()</code>：读入一个字符串。</p><p><code>in.nextLine()</code>：读入一行，返回一个字符串。</p><p>可以使用 <code>hasNextInt()</code> 等方法来预判（以通过 <code>while</code> 循环读取任意数量的数据）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">if</span>(in.hasNextInt()) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = in.nextInt();</span><br><span class="line">            System.out.printf(<span class="string">&quot;The next integer is %d.\n&quot;</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> System.out.println(<span class="string">&quot;The next integer does not exist.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">3.14</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">The next integer does not exist.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">The next integer is 3.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="快读"><a href="#快读" class="headerlink" title="快读"></a>快读</h5><p>关于字节流和字符流相关：待填坑。（StreamTokenizer）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        BufferedWriter out = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">        Integer n = Integer.parseInt(in.readLine());<span class="comment">// read() 方法读取字符</span></span><br><span class="line">        out.write(n.toString());<span class="comment">// 可以使用 String.format(&quot;&quot;) 方法</span></span><br><span class="line">        out.newLine();</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>导入 <code>java.io.*</code>，主函数 <code>throws IOException</code>。</li><li><code>BufferedReader</code> 和 <code>BufferedWriter</code> 使用 <code>InputStreamReader</code> 和 <code>OutputStreamWriter</code> 初始化。</li><li>输出后刷新缓冲区 <code>flush()</code>。</li></ul><p>【Kattio】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kattio</span> <span class="keyword">extends</span> <span class="title">PrintWriter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader bf;</span><br><span class="line">    <span class="keyword">private</span> StringTokenizer st;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Kattio</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(System.out);</span><br><span class="line">        bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(st == <span class="keyword">null</span> || !st.hasMoreTokens()) &#123;</span><br><span class="line">                st = <span class="keyword">new</span> StringTokenizer(bf.readLine());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> st.nextToken();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Integer.parseInt(next()); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意程序结束时需要执行 <code>io.close()</code>。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>基本数据类型（如 <code>int</code>、<code>double</code>）及强制类型转换，语法与 C++ 类似，但布尔类型的关键字为 <code>boolean</code>。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h5 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h5><p>定义数组：<code>int[] a = new int[100];</code>，数组的元素个数可以为变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            System.out.print(a[i] + ((i == n - <span class="number">1</span>)?<span class="string">&quot;\n&quot;</span>:<span class="string">&quot; &quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入：10</span></span><br><span class="line"><span class="comment">输出：0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以使用 <code>a.length</code> 访问数组大小，数组中元素默认为 $0$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) a[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; ++i) &#123;</span><br><span class="line">            System.out.print(a[i] + ((i == n - <span class="number">1</span>)?<span class="string">&quot;\n&quot;</span>:<span class="string">&quot; &quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入：10</span></span><br><span class="line"><span class="comment">输出：0 1 2 3 4 0 0 0 0 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>初始化：<code>int[] a = &#123;0, 1, 2, 3, 4, 5&#125;;</code>。</p><h5 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = in.nextInt(), m = in.nextInt();</span><br><span class="line"><span class="comment">/* 使用变量定义二维数组 */</span></span><br><span class="line"><span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, cnt = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">        a[i][j] = cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 使用 for-each 访问二维数组 */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>[] b: a) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> c: b) &#123;</span><br><span class="line">        System.out.print(c + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化 */</span></span><br><span class="line"><span class="keyword">int</span>[][] a = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 使用 length 访问二维数组 */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i].length; ++j) &#123;</span><br><span class="line">        a[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h5><ol><li>引入：<code>import java.util.Arrays;</code></li><li>基本用法：<code>Arrays.sort(a);</code> 对数组 <code>a</code> 进行递增排序。</li><li>时间复杂度：$O(nlog_2n)$。</li><li>指定排序范围：<code>Arrays.sort(a, 0, 5);</code> 对数组 <code>a</code> 的前 6 个元素进行排序。</li><li>自定义排序规则：</li></ol><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>用法与 C++ 类似。</p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p><code>if</code> 语句和 <code>switch</code> 语句与 C++ 类似。</p><p>就近原则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>()</span><br><span class="line">    <span class="keyword">if</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，第一部分代码中的 <code>else</code> 无视缩进，与第二个 <code>if</code> 形成一组。</p><p><code>switch</code> 语句中的 <code>default</code> 不是必要的。</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p><code>while</code> 语句和 <code>do-while</code> 语句与 C++ 类似。</p><p><code>for</code> 语句与 C++ 类似，可使用 <code>break</code> 语句和 <code>continue</code> 语句，也可以使用 <code>goto</code>。</p><p>类似 <code>for-in</code> 的 <code>for-each</code> 遍历数组元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x: a) &#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，上述代码中改变 <code>x</code> 的值并不会改变原数组中对应项的值（类数组除外），例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            a[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x: a) &#123;</span><br><span class="line">            x = <span class="number">0</span>;<span class="comment">// 原数组中的值没有被修改</span></span><br><span class="line">            System.out.print(x + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x: a) &#123;</span><br><span class="line">            System.out.print(x + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">0 0 0 0 0 0 0 0 0 0 </span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 6 7 8 9 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h5 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h5><p>Java 使用 Unicode 编码，用单引号表示字符，可与 <code>int</code> 相互赋值。</p><p>转义字符：<code>\t</code>、<code>\b</code>、<code>\n</code>、<code>\r</code>、<code>\\</code>、<code>\&#39;</code>、<code>\&quot;</code>……</p><h5 id="Wrap-类型"><a href="#Wrap-类型" class="headerlink" title="Wrap 类型"></a>Wrap 类型</h5><p>将基本类型转化为对象，</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首字母大写</span></span><br><span class="line"><span class="keyword">int</span> -&gt; Integer</span><br><span class="line"><span class="keyword">short</span> -&gt; <span class="keyword">Short</span></span><br><span class="line"><span class="keyword">long</span> -&gt; <span class="keyword">Long</span></span><br><span class="line"><span class="keyword">float</span> - &gt; <span class="keyword">Float</span></span><br><span class="line"><span class="keyword">double</span> -&gt; <span class="keyword">Double</span></span><br><span class="line"><span class="keyword">boolean</span> -&gt; <span class="keyword">Boolean</span></span><br><span class="line"><span class="keyword">char</span> -&gt; Charater</span><br><span class="line"><span class="keyword">byte</span> -&gt; <span class="keyword">Byte</span></span><br></pre></td></tr></table></figure><p><code>Integer.parseInt(String s, int radix)</code> 方法可以将字符串转化为整数，<code>radix</code> 参数用于指定基数，默认为 10。</p><p>类似的还有 <code>Long.parseLong(String s)</code>、<code>Double.parseDouble(String s)</code> 等等。</p><h5 id="Integer-类型"><a href="#Integer-类型" class="headerlink" title="Integer 类型"></a>Integer 类型</h5><p>可自由赋值给 int 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Integer I = Integer(<span class="number">1024</span>);<span class="comment">// Java 8</span></span><br><span class="line">Integer I = Integer.valueOf(<span class="number">1024</span>);<span class="comment">// Java 19</span></span><br><span class="line">System.out.println(I);</span><br><span class="line"><span class="keyword">int</span> i = I;</span><br><span class="line">System.out.println(i);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">1024</span></span><br><span class="line"><span class="comment">1024</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">System.out.println(Integer.MIN_VALUE + <span class="string">&quot; &quot;</span> + Integer.MAX_VALUE);</span><br><span class="line"><span class="comment">// 输出：-2147483648 2147483647</span></span><br></pre></td></tr></table></figure><p>成员函数 <code>toString()</code> 和 <code>Integer.toString(int i)</code> 方法可返回整数对应的字符串。</p><h5 id="Character-类型"><a href="#Character-类型" class="headerlink" title="Character 类型"></a>Character 类型</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">System.out.println(Character.isDigit(c));</span><br><span class="line">System.out.println(Character.isLetter(c));</span><br><span class="line">System.out.println(Character.isLetterOrDigit(c));</span><br><span class="line">System.out.println(Character.isLowerCase(c));</span><br><span class="line">System.out.println(Character.isUpperCase(c));</span><br><span class="line">System.out.println(Character.isWhitespace(c));</span><br><span class="line">System.out.println(Character.toLowerCase(c));<span class="comment">// 返回改变后的字符，不改变 c 的值</span></span><br><span class="line">System.out.println(Character.toUpperCase(c));<span class="comment">// 返回改变后的字符，不改变 c 的值</span></span><br></pre></td></tr></table></figure><h5 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h5><p>字符串的连接是从左向右的，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">1</span> + <span class="number">2</span> + <span class="string">&quot;3&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">33</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">System.out.println(<span class="string">&quot;1&quot;</span> + <span class="number">2</span> + <span class="number">3</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">123</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>判断相等时应当使用 <code>s1.equals(s2)</code>，在 Java 中，类的名称类似于指针，使用运算符 <code>==</code> 相当于判断两者是否指向同一对象。</p><p>两种声明方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">String s = <span class="string">&quot;Hello World!&quot;</span>;</span><br></pre></td></tr></table></figure><p>这两种初始化的方式是有所不同的，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可见，使用 <code>new</code> 初始化相同内容的字符串时创建了新的对象，这里用到了 Java 中“常量池”的概念。</p><p>注意：在 Java 中采用值传递而非引用传递。</p><p>一些函数的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* compareTo() 在小于时返回 -1，等于时返回 0，大于时返回 1. */</span></span><br><span class="line"><span class="comment">/* compareToIgnoreCase() 无视大小写 */</span></span><br><span class="line">String s1 = <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;BCD&quot;</span>;</span><br><span class="line">System.out.println(s1.compareTo(s2));<span class="comment">// -1</span></span><br><span class="line"><span class="comment">/* charAt() */</span></span><br><span class="line">System.out.println(s1.charAt(<span class="number">0</span>));<span class="comment">// A</span></span><br><span class="line"><span class="comment">/* substring() */</span></span><br><span class="line">System.out.println(s1.substring(<span class="number">1</span>));<span class="comment">// BC</span></span><br><span class="line"><span class="comment">/* 区间左闭右开 */</span></span><br><span class="line">System.out.println(s1.substring(<span class="number">0</span>, <span class="number">2</span>));<span class="comment">// AB</span></span><br><span class="line"><span class="comment">/* indexOf() 不存在返回 -1 */</span></span><br><span class="line">System.out.println(s1.indexOf(<span class="string">&#x27;B&#x27;</span>));<span class="comment">// 1</span></span><br><span class="line">System.out.println(s1.indexOf(<span class="string">&#x27;Z&#x27;</span>));<span class="comment">// -1</span></span><br><span class="line"><span class="comment">/* 第二个参数表示查找的开始位置 */</span></span><br><span class="line">System.out.println(s1.indexOf(<span class="string">&#x27;A&#x27;</span>, <span class="number">1</span>));<span class="comment">// -1</span></span><br><span class="line"><span class="comment">/* lastIndexOf 用法相同，从字符串末尾开始搜索 */</span></span><br><span class="line"><span class="comment">/* 其它函数 */</span></span><br><span class="line">System.out.println(s1.startsWith(<span class="string">&quot;AB&quot;</span>));<span class="comment">// true</span></span><br><span class="line">System.out.println(s1.endsWith(<span class="string">&quot;BA&quot;</span>));<span class="comment">// true</span></span><br><span class="line"><span class="comment">/* trim() 删去头尾空白符 */</span></span><br><span class="line">s1 = <span class="string">&quot; ABABA &quot;</span>;</span><br><span class="line">System.out.println(s1.trim());<span class="comment">// &quot;ABABA&quot;</span></span><br><span class="line">System.out.println(s1.replace(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>));<span class="comment">// CBCBC</span></span><br><span class="line">System.out.println(s1.toLowerCase());<span class="comment">// ababa</span></span><br><span class="line"><span class="comment">/* 执行 toLowerCase() 和 toUpperCase() 不改变原字符串的内容 */</span></span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s = in.next();</span><br><span class="line"><span class="keyword">switch</span>(s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Happy&quot;</span>: System.out.println(<span class="string">&quot;You are happy.&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Sad&quot;</span>: System.out.println(<span class="string">&quot;You are sad.&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另：可使用 <code>indexOf</code> 进行字符串查找，内部实现为嵌套循环的朴素算法，时间复杂度为 $O(nm)$，但只能返回一个位置，却可以指定查找的起始位置来实现连续查找。</p><p>未初始化的 String 不能调用 <code>length()</code> 方法，而初始化为 <code>&quot;&quot;</code> 的 String 调用 <code>length()</code> 会返回数字 0。</p><p><code>split</code> 方法可以对字符串进行拆分，得到拆分后的字符串数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = in.nextLine();</span><br><span class="line">        String s[] = str.split(<span class="string">&quot; &quot;</span>);<span class="comment">// 也可以使用 &quot;,&quot; 作为分隔符</span></span><br><span class="line">        <span class="keyword">for</span>(String ss: s) &#123;</span><br><span class="line">            System.out.println(ss);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">Hello World Java Programming File</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">Hello</span></span><br><span class="line"><span class="comment">World</span></span><br><span class="line"><span class="comment">Java</span></span><br><span class="line"><span class="comment">Programming</span></span><br><span class="line"><span class="comment">File</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>format</code> 方法可以获得格式化的字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">double</span> d = in.nextDouble();</span><br><span class="line">        String s = String.format(<span class="string">&quot;Double Value is %.7f\n&quot;</span>,d);</span><br><span class="line">        System.out.print(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">3.1415926</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">Double Value is 3.1415926</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>（Java 中 <code>float</code> 类型和 <code>double</code> 类型变量都使用 <code>%f</code> 表示，<code>byte</code> 类型、<code>short</code> 类型、<code>int</code> 类型、<code>long</code> 类型都使用 <code>%d</code> 表示）</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>只能按值传递。</p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>耦合性（依赖关系）与可扩展性：硬编码 -&gt; 框架+数据。</p><p>注意：类的赋值语句并不是对象赋值，而是改变变量管理的对象。</p><h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><p>调用成员函数时可以直接使用成员变量名或成员函数名，可不使用 <code>this</code> 指定（若与成员函数某个参数重名则须要指定），<code>this</code> 像指针一样管理着调用成员函数的对象（就像一个快捷方式 ）。  </p><p>成员变量会被给予初始值 $0$，与本地变量（函数中的变量）不同，本地变量不被赋值就使用则编译失败。</p><p>创建对象的时候会对所有变量依次初始化，然后调用构造函数（如果存在的话），若有多个构造函数则调用与 <code>new</code> 时参数对应的构造函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;<span class="comment">// 0</span></span><br><span class="line">    test() &#123;&#125;<span class="comment">// 构造函数，使用类名，没有返回类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(x);<span class="comment">// 1</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>.x);<span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test t = <span class="keyword">new</span> test();t.f(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在构造函数中使用 <code>this</code> 调用其它构造函数，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    int x;</span><br><span class="line">    <span class="function"><span class="title">test</span>(<span class="params"></span>)</span> &#123;System.out.println(<span class="string">&quot;test&quot;</span>);&#125;</span><br><span class="line">    <span class="function"><span class="title">test</span>(<span class="params">int x</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">        test t = <span class="keyword">new</span> test(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是 <code>this()</code> 只能作为该构造函数的第一个语句，否则就会报错：</p><p><img src="../images/upload/java-notes/error0.png"></p><h5 id="private-属性"><a href="#private-属性" class="headerlink" title="private 属性"></a>private 属性</h5><p><code>private</code> 关键字只适用于成员变量和成员函数，仅类中可使用，在类外实例化的对象不可访问（但对于同一个类的私有成员变量，只要代码写在类中，两个不同的对象之间可以相互访问）。</p><h5 id="public-属性"><a href="#public-属性" class="headerlink" title="public 属性"></a>public 属性</h5><p><code>public</code> 关键字修饰的类必须在它自己的 <code>java</code> 文件中，即文件名与类名相同。</p><h5 id="包"><a href="#包" class="headerlink" title="包"></a>包</h5><p>若成员变量、成员函数和类前没有 <code>private</code> 或 <code>public</code> 关键字，则意味着它仅可以在包内访问。</p><p>在 <code>java</code> 文件的开头添加 <code>package package_name;</code> 表明文件属于这个包。</p><p>导入其它包内声明的类：<code>import package_name.class_name;</code>，不选择导入则需要使用 <code>package_name.class_name</code> 作为全名调用包外的类。</p><p><code>import package_name.*;</code> 表明导入包内的所有内容。</p><p>包可以嵌套子目录：<code>package parent.child</code>。</p><h5 id="static-属性"><a href="#static-属性" class="headerlink" title="static 属性"></a>static 属性</h5><p>同一个类的静态变量为所有对象共有，可以使用 <code>object_name.var_name</code> 也可以使用 <code>class_name.var_name</code> 访问，可以称为类变量。</p><p>静态函数（用 <code>static</code> 修饰的属性的函数）与静态变量类似，静态函数不能访问成员变量（因为静态函数属于这个类，而成员变量属于一个特定的对象）。</p><h5 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h5><p>如 <code>ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;();</code>，声明 String 类型的容器。</p><p><font color="red">注意：Java 中泛型只能是引用类型（如 <code>Integer</code>），不能是基本类型（如 <code>int</code>）。</font></p><h5 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h5><ol><li>基本数据类型的数组中存放数据，类数组中存放管理数据用的“指针”（初始为 <code>null</code>）。</li><li>对于类数组，修改 <code>for-each</code> 语句中 <code>x</code> 的值将会影响原数组中的值，例如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">I</span> </span>&#123;<span class="comment">// 须要写在外面</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line">    I(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        I[] a = <span class="keyword">new</span> I[<span class="number">10</span>];<span class="comment">// 初始化：第一步</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            a[i] = <span class="keyword">new</span> I(i);<span class="comment">// 初始化：第二步</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(I x: a) &#123;</span><br><span class="line">            System.out.print(x.i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            x.i = <span class="number">0</span>;<span class="comment">// 原数组中的值被修改了</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span>(I x: a) &#123;</span><br><span class="line">            System.out.print(x.i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 6 7 8 9 </span></span><br><span class="line"><span class="comment">0 0 0 0 0 0 0 0 0 0 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>类的对象名仅仅为指向该对象的指针，赋值时也仅仅是指针的赋值，让两者管理同一个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">I</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line">    I(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        I a = <span class="keyword">new</span> I(<span class="number">128</span>);</span><br><span class="line">        I b = <span class="keyword">new</span> I(<span class="number">64</span>);</span><br><span class="line">        b = a;</span><br><span class="line">        a.i = <span class="number">32</span>;</span><br><span class="line">        System.out.println(b.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">32</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="继承（extends）"><a href="#继承（extends）" class="headerlink" title="继承（extends）"></a>继承（<code>extends</code>）</h5><p>所有类均默认为 Object 的子类：<code>toString()</code>、<code>equals(Object object)</code>……</p><p>继承是为了方便复用代码，避免重复编写代码，不利于维护。</p><p>如果父类和子类出现重名，则会生成两个变量，不加 <code>super.</code> 会默认为当前类的变量或函数。</p><p>覆盖：子类与父类出现同名函数。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br></pre></td></tr></table></figure><h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h5><p>定义在父类 <code>Object</code> 里，在类中重写来改变 <code>System.out</code> 时的输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>toString()</code> 会自动调用，如 <code>&quot;str&quot; + object</code> 等同于 <code>&quot;str&quot; + object.toString()</code>。</p><h5 id="equals-Typename-object"><a href="#equals-Typename-object" class="headerlink" title="equals(Typename object)"></a>equals(Typename object)</h5><p>定义在父类 <code>Object</code> 里，在类中没有重写时调用很大概率返回与预期不符的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;<span class="comment">// 类型必须是 Object</span></span><br><span class="line">    Class object = (Class)obj;</span><br><span class="line">    <span class="keyword">return</span> element.equals(object.element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><p>子类（动态类型）可以被当作父类（声明类型）使用：如父类容器可以放入继承自同一父类的不同子类的元素、向上造型（<code>FatherClass object = new ChildClass();</code>）。</p><p>特殊：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FatherClass object = <span class="keyword">new</span> ChildClass();</span><br><span class="line">ChildClass newObject = (ChildClass)object;<span class="comment">// 需要造型（没有被转换）成子类</span></span><br></pre></td></tr></table></figure><p>造型：当作…来看待；转换：变更。</p><p>动态绑定：尽管声明类型不同，调用时还是会调用动态类型的函数。</p><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>执行顺序：变量初始化 -&gt; 父类构造函数 -&gt; 当前类构造函数。</p><p>调用父类构造函数：<code>super(items)</code>，如果不写在执行子类构造函数时会默认执行父类不带参数的构造函数（不存在则报错）。</p><h5 id="protected-属性"><a href="#protected-属性" class="headerlink" title="protected 属性"></a>protected 属性</h5><p><code>protected</code> 关键字保证包内的类和子类可以访问。</p><h5 id="抽象-abstract"><a href="#抽象-abstract" class="headerlink" title="抽象 (abstract)"></a>抽象 (abstract)</h5><ul><li>含有抽象函数 <code>abstruct func</code> 的一定是抽象类 <code>abstract class</code>。</li><li>继承自抽象类就要实现其所有抽象方法。</li></ul><p>注：这里的“抽象”表示的含义是不具体，面向对象中另一种“抽象“的含义是封装使看不到底层细节。</p><h3 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h3><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(<span class="built_in">Exception</span> e) &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>getMessage()</code></li><li><code>printStackTrace()</code></li><li><code>toString()</code>：返回异常名与 <code>getMessage()</code> 的信息。</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">static</span> <span class="keyword">void</span> main(<span class="keyword">string</span>[] args) throws <span class="built_in">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    CustomException() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getMessage() + <span class="string">&quot; and &quot;</span> + <span class="string">&quot;getMessage()&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> CustomException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CustomException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(e);</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="keyword">null</span>, e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Final&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">init()</span></span><br><span class="line"><span class="comment">CustomException: null and getMessage()</span></span><br><span class="line"><span class="comment">Final</span></span><br><span class="line"><span class="comment">Hello world!</span></span><br><span class="line"><span class="comment">CustomException: null and getMessage()</span></span><br><span class="line"><span class="comment">at Main.test(Main.java:16)</span></span><br><span class="line"><span class="comment">at Main.main(Main.java:20)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="常用库-函数"><a href="#常用库-函数" class="headerlink" title="常用库/函数"></a>常用库/函数</h3><p><font color="red">重要：Java 中容器类型只能为 Wrap 类型，不能是基本数据类型。</font></p><p>引入：<code>import java.util.*;</code>。</p><p>遍历：<code>for-each</code>。</p><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><p>基本用法：</p><ul><li>插入：<code>add(value)</code></li><li>修改：<code>set(index, value)</code></li><li>删除：<code>remove(index or value)</code></li><li>大小：<code>size()</code></li><li>取值：<code>get(index)</code></li><li>转数组：<code>toArray(newArrayName)</code></li></ul><h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><ul><li><code>add(value)</code>，<code>addFirst</code></li><li><code>removeFirst()</code></li><li><code>getFirst()</code>、<code>getLast()</code></li><li><code>peekFirst()</code>、<code>peekLast()</code></li></ul><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><p>特点：无序集合。</p><p>基本用法：</p><ul><li>插入：<code>add(value)</code></li><li>删除：<code>remove(value)</code></li><li>判断是否存在：<code>contains(value)</code></li><li>大小：<code>size()</code></li><li>清空：<code>clear()</code></li></ul><h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><p>特点：有序集合。</p><h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><p>基本用法：</p><ul><li>插入：<code>put(key, value)</code>。</li><li>取值：<code>get(key)</code>，不存在返回 <code>null</code>。</li><li>判断是否存在：<code>containsKey(key)</code>。</li><li>键集合：<code>keySet()</code>。</li><li>遍历：<code>for(KeyType key: hashMap.keySet()) &#123;&#125;</code></li></ul><h5 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h5><h5 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h5><p><code>add(_element_)</code></p><p><code>peek()</code></p><p><code>poll()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a, Integer b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a &lt; b ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        pq.add(<span class="number">64</span>);</span><br><span class="line">        pq.add(<span class="number">32</span>);</span><br><span class="line">        pq.add(<span class="number">128</span>);</span><br><span class="line">        System.out.println(pq.peek());</span><br><span class="line">        pq.poll();</span><br><span class="line">        System.out.println(pq.peek());</span><br><span class="line">        pq.poll();</span><br><span class="line">        System.out.println(pq.peek());</span><br><span class="line">        pq.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">Deque&lt;Integer&gt; dq = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();<span class="comment">// 不能接受基本数据类型</span></span><br><span class="line"></span><br><span class="line">System.out.println(dq.size());<span class="comment">// 大小</span></span><br><span class="line"></span><br><span class="line">dq.addLast(<span class="number">512</span>);<span class="comment">// 插入元素，失败返回异常</span></span><br><span class="line">dq.offerLast(<span class="number">1024</span>);<span class="comment">// 插入元素，失败返回 null</span></span><br><span class="line"></span><br><span class="line">System.out.println(dq.getFirst());<span class="comment">// 获取元素，失败返回异常</span></span><br><span class="line">System.out.println(dq.peekLast());<span class="comment">// 获取元素，失败返回 null</span></span><br><span class="line"></span><br><span class="line">System.out.println(dq.removeFirst());<span class="comment">// 删除元素，失败返回异常</span></span><br><span class="line">System.out.println(dq.pollLast());<span class="comment">// 删除元素，失败返回 null</span></span><br></pre></td></tr></table></figure><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>返回负数表示在前，返回零表示相等，返回整数表示在后。</p><p><code>Collections.sort()</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 头文件 */</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/* 数组排序 */</span></span><br><span class="line">Arrays.sort(a);<span class="comment">// 可以加两个参数表示排序区间，左闭右开</span></span><br><span class="line"><span class="comment">/* 自定义排序规则 */</span></span><br><span class="line">Arrays.sort(a, <span class="keyword">new</span> Comparator&lt;typename&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(typename a, typename b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.x == b.x) <span class="keyword">return</span> a.y &lt; b.y ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Classname rhs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h5><p><code>Math.random()</code> 得到一个 $[0,1)$ 的随机数。</p><h5 id="时间统计"><a href="#时间统计" class="headerlink" title="时间统计"></a>时间统计</h5><p><code>System.currentTimeMillis()</code> 作差可得代码段的运行时间（以毫秒为单位）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 第一种方式 */</span></span><br><span class="line">BufferedWriter out = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line"><span class="keyword">long</span> st = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">    out.write(String.format(<span class="string">&quot;%d\n&quot;</span>, (<span class="keyword">int</span>)(Math.random() * <span class="number">100000</span>)));</span><br><span class="line">&#125;</span><br><span class="line">out.flush();</span><br><span class="line"><span class="keyword">long</span> et = System.currentTimeMillis();</span><br><span class="line">System.out.println(et - st);<span class="comment">// 1117 ms</span></span><br><span class="line"><span class="comment">/* 第二种方式 */</span></span><br><span class="line"><span class="keyword">long</span> st = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">    System.out.println((<span class="keyword">int</span>)(Math.random() * <span class="number">100000</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> et = System.currentTimeMillis();</span><br><span class="line">System.out.println(et - st);<span class="comment">// 2240 ms</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;版本问题&quot;&gt;&lt;a href=&quot;#版本问题&quot; class=&quot;headerlink&quot; title=&quot;版本问题&quot;&gt;&lt;/a&gt;版本问题&lt;/h3&gt;&lt;p&gt;写这篇笔记时 Oracle 官网上的最新的 JDK 版本是 Java 19，兼容 Apple Silicon，然而目前最常用</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://whz0325.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://whz0325.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>抽象代数笔记</title>
    <link href="https://whz0325.github.io/abstract-algebra/"/>
    <id>https://whz0325.github.io/abstract-algebra/</id>
    <published>2022-11-09T14:13:22.000Z</published>
    <updated>2023-03-06T15:07:39.228Z</updated>
    
    <content type="html"><![CDATA[<p>按我们老师讲的内容来，可能不太全……</p><h3 id="一、代数系统"><a href="#一、代数系统" class="headerlink" title="一、代数系统"></a>一、代数系统</h3><ol><li>代数运算：封闭性。</li><li>代数运算的性质：<ol><li>交换律</li><li>结合律</li><li>幂等律：集合中每个元素都是幂等元（满足 $a*a=a$ 的 $a$）。【拓展】满足 $a^n=a$。</li><li>分配律：若 $a·(b+c)=a·b+a·c$ 表明“乘法”<strong>对</strong>“加法”满足分配率（左分配）。</li><li>吸收律：若 $a·(a+b)=a+(a·b)=a$ 表明二元运算 · 与 + 满足吸收率，$P\land (P\lor Q)=P\lor (P\land Q)=P$，$min(a,max(a,b))=max(a,min(a,b))=a$。</li><li>消去律：若 $a·c=b·c$ 则 $a=b$ 表明二元运算 * 满足消去律（区分：左消去/右消去）。</li></ol></li><li>代数系统：$(S,f_1,f_2,\dots)$，其中 $S$ 为非空集合，$f_1,f_2,\dots$ 为代数运算。</li></ol><h3 id="二、群的定义"><a href="#二、群的定义" class="headerlink" title="二、群的定义"></a>二、群的定义</h3><ol><li>半群 $(G,·)$：<ol><li>集合非空</li><li>代数运算（封闭）</li><li>满足结合律，如 $(G,·)$。</li></ol></li><li>群 $(G,·)$：<ol><li>半群</li><li>有<strong>单位元</strong></li><li>任意元素有<strong>逆元素</strong></li></ol></li><li>理解群的定义：<ol><li>单位元是群中唯一幂等元。</li><li>群中不可能有零元（半群可以）。【证明】反证法：群中只有一个元素时该元素被视为单位元，否则矛盾。</li><li>群一定满足<strong>消去律</strong>。【证明】两边同时乘被消去元素的逆元（左消去左乘，右消去右乘）。</li></ol></li><li>群的性质：<ol><li>群中单位元唯一，每个元素的逆元素唯一。</li><li>群的运算可以任意加括号。</li><li>$a^n$：规定 $a^0=1$，$a^{-n}=(a^n)^{-1}$。满足第一指数律（$a^m·a^n=a^{m+n}$）和第二指数律（$(a^m)^n=a^{mn}$），不一定满足第三指数律（$(a·b)^n=a^n·b^n$），因为不一定满足交换律。</li></ol></li><li>群的证明：<ol><li>群的证明可以简化为：有左壹，有左逆的半群（也可以简化为：有右壹，有右逆）（不可以简化为：一个左，一个右）。</li><li>群的证明可以等价为满足<strong>可除条件</strong>的半群：对任意 $a,b$，存在 $x,y$ 满足 $x·a=b$ 且 $a·y=b$。</li><li>群的证明可以简化为：满足<strong>消去律</strong>的<strong>有限</strong>半群。【证明】左边同时乘 $a$，由消去律反证得到的元素各不相同，因而满足可除条件。</li></ol></li><li>Abel 群：满足<strong>交换律</strong>的群，也称为交换群，充要条件为 $(a·b)^2=a^2·b^2$。【证明】展开后左边乘 $a^{-1}$，右边乘 $b^{-1}$，得 $b·a=a·b$。<ol><li>交换群的运算可以任意改变次序。</li><li>交换群满足<strong>第三指数律</strong>。</li><li>另：我们永远假定<strong>加法群是交换群</strong>。</li></ol></li></ol><h3 id="三、置换群"><a href="#三、置换群" class="headerlink" title="三、置换群"></a>三、置换群</h3><ol><li>置换：n 元置换，n 元恒等置换，置换共有 $n!$ 个（乘法原理）。</li><li>置换的乘法：先右后左<ol><li>满足结合律</li><li>有单位元：n 元恒等置换。</li><li>有逆元素。</li></ol></li><li>n 次<strong>对称群</strong>：所有 n 元置换及其上乘法。<ol><li>子群称为 n 次置换群。</li><li>所有的偶置换组成的群称为 n 次<strong>交代群</strong>。</li><li>所有的奇置换无法组成群。（奇置换的乘积为偶置换，不满足封闭性）</li></ol></li><li>轮换：一种简便写法，$(a_1 a_2\dots a_r)^{-1}=(a_r\dots a_2 a_1)$。</li><li>不相杂（不相交）：置换可以唯一地写成若干不相杂轮换的乘积。</li><li>对换：长度为 $2$ 的轮换，$(a_1 a_2\dots a_r)=(a_1 a_r)(a_1 a_{r-1})\dots (a_1 a_2)$。</li><li>奇偶性：等同于 $\sum_{j=1}^k (r_j-1)=n-k$ 的奇偶性。（$r_j$ 为每个轮换的长度，$k$ 为轮换个数，$n-k$ 为对换个数）。<ol><li>置换乘法积的奇偶性：与加法规律类似，相同得偶，相异得奇。</li><li>个数：奇偶置换个数相同，各 $\frac{n!}{2}$ 个。【证明】在每个偶置换前乘一个对换，必然得到一个奇置换，因为置换存在逆元，由消去率反证得得到的奇置换个数不少于偶置换，同理可以得到偶置换的个数不少于奇置换，及两者个数相等。</li></ol></li></ol><h3 id="子群及其陪集"><a href="#子群及其陪集" class="headerlink" title="子群及其陪集"></a>子群及其陪集</h3><ol><li>子群：集合为原集合的子集，运算与原集合相同。<ol><li>平凡子群：自身和单位元组成的子群。</li><li>充要条件：非空，封闭，有逆元。【证明】封闭有逆元可以得到有单位元。</li><li>子群与大群的关系：单位元相同，逆元相同。</li><li>充要条件2：非空，$a\in H,b\in H, ab^{-1}\in H$。【证明】$aa^{-1}=1\in H$，$1·a^{-1}\in H$。</li><li>充要条件3：非空，<strong>封闭</strong>，<strong>有限</strong>。（有限群只需验证封闭性）【证明】封闭性可以得到一个循环子集，则必定有相同元素，否则将会无限循环下去，据此得到逆元，随后得到单位元。</li></ol></li><li>循环群：由 $a$ 生成的循环子群记为 $(a)$。<ol><li>周期：$a^n=1$，最小的 $n$ 为 $a$ 的周期，规定单位元的周期为 $1$。</li><li>任意元素与其<strong>逆元</strong>具有<strong>相同的周期</strong>。</li><li>乘法循环群性质：$0,a,2a,\dots ,(n-1)a$ 各不相同，$ma=1$ 等价于 $n|m$，$sa=ta$ 等价于 $n|(s-t)$。</li><li>乘法循环群性质：$1,a,a^2,\dots ,a^{n-1}$ 各不相同，$a^m=1$ 等价于 $n|m$，$a^s=a^t$ 等价于 $n|(s-t)$。</li><li>无限循环群：生成元素只有 $a$ 和 $a^{-1}$ 两个。</li><li>n 元循环群：生成元素有 $\phi(n)$ 个。</li></ol></li><li>陪集</li></ol><p>另：【欧拉定理】$a$ 与 $n$ 互质，则 $a^{\phi(n)}=1(mod\ n)$。欧拉函数 $\phi(n)$ 为积性函数，当 $n$ 为质数时，$\phi(n)=n-1$。</p><p>完全剩余系与简化剩余系。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;按我们老师讲的内容来，可能不太全……&lt;/p&gt;
&lt;h3 id=&quot;一、代数系统&quot;&gt;&lt;a href=&quot;#一、代数系统&quot; class=&quot;headerlink&quot; title=&quot;一、代数系统&quot;&gt;&lt;/a&gt;一、代数系统&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;代数运算：封闭性。&lt;/li&gt;
&lt;li&gt;代数运</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://whz0325.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="抽象代数" scheme="https://whz0325.github.io/tags/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python 语法笔记</title>
    <link href="https://whz0325.github.io/python-notes/"/>
    <id>https://whz0325.github.io/python-notes/</id>
    <published>2022-10-15T13:34:05.000Z</published>
    <updated>2023-02-06T08:27:48.267Z</updated>
    
    <content type="html"><![CDATA[<p>内容全部摘自一个讲 Python 语法的网站，算是个速查吧。</p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul><li>注释：单行注释 <code>#</code>，多行注释用 <code>&#39;&#39;&#39;</code> 或 <code>&quot;&quot;&quot;</code> 包裹。</li><li>缩进须严格一致，<code>\</code> 用于换行继续写。</li><li>字符串不区分单双引号，三引号可表示多行字符串。</li><li>使用 <code>r&quot;string\n&quot;</code> 可以让 <code>\</code> 不转译。</li><li>字符串取子串用 <code>[首下标:尾下标:步长]</code>，负数代表倒着数。</li><li>字符串加法代表连接，乘法代表重复。</li><li><code>print()</code> 默认换行，可指定 <code>print(element, end=&quot;&quot;)</code> 设置不换行。</li><li>导入：<code>import</code>、<code>from module import function</code>、<code>from module import *</code>。</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>类型名首字母大写，支持复数 <code>1+2j</code> 或 <code>complex(1, 2)</code>。</li><li><code>type()</code> 查询变量的类型，<code>isinstance(a, Int)</code> 会判断变量是否为指定类型（子类也算哦）。</li><li>删除对象 <code>del ver_1, ver_2</code></li><li><code>/</code> 得到浮点数，<code>//</code> 得到整数，<code>**</code> 是乘方。</li><li>列表类型 <code>List[&quot;&quot;, &quot;&quot;, &quot;&quot;]</code> 里啥都能塞。</li><li>技巧 <code>list = list[-1::-1]</code> 反转一个列表（步长 $-1$）。</li><li>元组类型 <code>Tuple(&quot;&quot;, &quot;&quot;, &quot;&quot;)</code> 内元素不能修改。</li><li>集合类型 <code>Set&#123;&quot;&quot;, &quot;&quot;, &quot;&quot;&#125;</code> 或 <code>set(&quot;&quot;)</code>，可以用 <code>-</code> 求差集，用 <code>&amp;</code> 求交集，用 <code>｜</code> 求并集，用 <code>^</code> 求不同元素。</li><li>字典类型 <code>Dictionary[&quot;location&quot;] = 1</code>，可用 <code>dictionary.keys()</code> 和 <code>dictionary.values()</code>，构造函数 <code>dict([(&quot;one&quot;, 1), (&quot;two&quot;, 2)])</code> 或 <code>dict(one = 1, two = 2)</code>。（感觉就是个 <code>map</code>【逃）</li><li>一些好用的函数：<code>hex(x)</code> 将整数转为十六进制字符串，<code>oct(x)</code> 将整数转为八进制字符串，<code>ord(x)</code> 将字符转为整数， <code>chr(x)</code> 将整数转为字符，<code>eval(str)</code> 计算字符串中的表达式……</li></ul><h3 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h3><p>一个有趣的东西。</p><ul><li>列表的例子：<code>[name.upper() for name in names if len(name) &gt; 3]</code></li><li>列表的例子：<code>[i for i in range(30) if i % 3 == 0]</code></li><li>字典的例子：<code>&#123;key: len(key) for key in strings&#125;</code></li><li>集合的例子：<code>&#123;i**2 for i in (1, 2, 3)&#125;</code></li><li>集合的例子：<code>&#123;x for x in &quot;abcdef&quot; if x not in &quot;abc&quot;&#125;</code></li><li>元组的例子：<code>(x for x in range(1, 10))</code></li></ul><hr><p>Python3 太强了，感觉再也不想用 C 了也说不定？明天接着写。</p><hr><p>然后就拖到后天了（</p><ul><li><code>f&quot;&#123;&#125;&quot;</code> 字符串前加 <code>f</code> 表示允许出现 <code>&#123;&#125;</code> 包裹的 Python 表达式。（顺便字符串前加的 <code>r</code> 是 raw 的缩写）</li><li>海象运算符 <code>:=</code>，目前觉得是在表达式中赋值，不太清楚到底怎么个用法。</li><li>Python 可以直接用关键字 <code>and</code>、<code>or</code>、<code>not</code>，如 <code>a and b</code>。</li><li>还有：<code>in</code> 和 <code>not in</code> 以及 <code>is</code> 和 <code>is not</code>（引用变量是否为同一个）。</li><li><code>id()</code> 函数用于获取对象内存地址。</li></ul><h3 id="数学相关"><a href="#数学相关" class="headerlink" title="数学相关"></a>数学相关</h3><p>（使用需要如 <code>math.modf(x)</code>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br></pre></td></tr></table></figure><p>基本函数 <code>abs(x)</code>、<code>ceil(x)</code>、<code>floor(x)</code>、<code>exp(x)</code>、<code>fabs(x)</code>、<code>log(x)</code>、<code>log10(x)</code>、<code>max(x1, x2, ... , xn)</code>、<code>min(x1, x2, ... , xn)</code>、<code>pow(x, y)</code>、<code>round(x[, n])</code>、<code>sqrt(x)</code>。</p><p><code>modf(x)</code> 用于返回整数部分和小数部分。</p><p><code>hypot(x, y)</code> 用于返回 $\sqrt{x^2+y^2}$。</p><p><code>degrees(x)</code> 弧度转角度，<code>radians(x)</code> 角度转弧度。</p><p>数学常量 <code>pi</code> 和 <code>e</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br></pre></td></tr></table></figure><p><code>choice(seq)</code> 在序列中随机挑选，<code>randrange([start, ]stop[, step])</code>，<code>random()</code> 生成 $[0,1)$ 范围内的随机数，<code>seed([x])</code>，<code>suffle(seq)</code> 将序列打乱，<code>uniform(x, y)</code> 随机生成 $[x, y]$ 范围内的实数。</p><hr><p>“字符串”到“集合”这几节先鸽着。</p><hr><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式:</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"><span class="keyword">elif</span> 表达式:</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"><span class="keyword">else</span>:</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 表达式:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">pass</span> <span class="comment"># 没用语句</span></span><br><span class="line"><span class="keyword">else</span>:</span><br></pre></td></tr></table></figure><p>压行：<code>while (not yahangdamie): print(&quot;压行啦！！！&quot;)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Python&quot;</span>]:</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="comment"># 0 -&gt; 4</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>, <span class="number">9</span>):</span><br><span class="line">    <span class="comment"># 5 -&gt; 8</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>):</span><br><span class="line">    <span class="comment"># 0 3 6 9</span></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>)) <span class="comment"># [0, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function0</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;function0&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><ul><li>传参时形式参数和实际参数指向同一个 $id$，内容改变后指向不同 $id$（用 <code>id(x)</code> 查看）。</li><li>函数内可变对象（如列表）改变会影响函数外。</li><li>可以设置参数默认值 <code>function0(author = &quot;whz0325&quot;)</code>，可以在调用时指定参数 <code>function0(name = &quot;whz&quot;, id = 325)</code>。</li></ul><p>不定长参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">*tmp</span>):</span> <span class="comment"># * 传入元组</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> tmp:</span><br><span class="line">        <span class="built_in">print</span>(x)</span><br><span class="line">test(<span class="number">1.0</span>, <span class="number">2</span>, <span class="string">&quot;string&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span>(<span class="params">**dic</span>):</span> <span class="comment"># ** 传入字典</span></span><br><span class="line">    <span class="keyword">for</span> (a, b) <span class="keyword">in</span> dic.items():</span><br><span class="line">        <span class="built_in">print</span>(a, b)</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> dic.keys():</span><br><span class="line">        <span class="built_in">print</span>(key + <span class="string">&#x27;: &#x27;</span> + <span class="built_in">str</span>(dic[key]))</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> dic.values():</span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">test2(a=<span class="number">1</span>, b=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>也可以 <code>def test2(a, b, *, c)</code>。</p><p>匿名函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line"><span class="built_in">print</span>(func(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li><code>[left, right]</code>  取子串，下标 $0$ 开始，左开右闭，可省略某项，负数从 $-1$ 开始倒数。</li><li>C 语言中的转义字符也可以用：<code>\175</code> 表示八进制数，<code>\x6a</code> 表示十六进制数。</li><li>获取字符串的长度：<code>len(s)</code>。</li></ul><p>格式化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;whz0325&quot;</span></span><br><span class="line">age = <span class="number">18</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%s de age is forever %d&quot;</span> % (name, age))</span><br></pre></td></tr></table></figure><p><code>%e</code> 为科学计数法形式的浮点数，<code>%o</code> 为八进制，<code>%x</code> 为十六进制（<code>%X</code> 为大写）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pi = <span class="number">3.1415926</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%010.3f&quot;</span> % pi) <span class="comment"># &quot;000003.142&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%10.3f&quot;</span> % pi) <span class="comment"># &quot;     3.142&quot;</span></span><br></pre></td></tr></table></figure><p>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;whz0325&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.capitalize()) <span class="comment"># Whz0325</span></span><br><span class="line"><span class="built_in">print</span>(s.center(<span class="number">12</span>, <span class="string">&quot;_&quot;</span>)) <span class="comment"># __whz0325___</span></span><br><span class="line"><span class="built_in">print</span>(s.count(<span class="string">&#x27;0&#x27;</span>)) <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(s.count(<span class="string">&#x27;0&#x27;</span>, <span class="number">4</span>, <span class="built_in">len</span>(s))) <span class="comment"># 0</span></span><br><span class="line"><span class="built_in">print</span>(s.endswith(<span class="string">&#x27;32&#x27;</span>, <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span>)) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s.find(<span class="string">&#x27;250&#x27;</span>, <span class="number">0</span>, <span class="built_in">len</span>(s))) <span class="comment"># -1</span></span><br><span class="line"><span class="built_in">print</span>(s.isalnum()) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s.isalpha()) <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(s.isdigit()) <span class="comment"># False</span></span><br><span class="line"><span class="comment"># isupper() islower()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join([<span class="string">&quot;whz0325&quot;</span>, <span class="string">&quot;and&quot;</span>, <span class="string">&quot;his&quot;</span>, <span class="string">&quot;friends&quot;</span>])) <span class="comment"># whz0325 and his friends</span></span><br><span class="line"><span class="comment"># max(s) min(s)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ababab&quot;</span>.replace(<span class="string">&quot;ab&quot;</span>, <span class="string">&quot;cd&quot;</span>, <span class="number">2</span>)) <span class="comment"># cdcdab</span></span><br></pre></td></tr></table></figure><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul><li>像数组一样的东西，可以搞二维列表</li><li><code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].append(&#39;d&#39;)</code>。</li><li><code>del list[-2]</code> 删除倒数第二个元素（可以删除中间元素）。</li><li><code>max(list)</code> 和 <code>min(list)</code> 返回列表最值。</li></ul><p>排序和其它函数明天更。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>坑着。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;内容全部摘自一个讲 Python 语法的网站，算是个速查吧。&lt;/p&gt;
&lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;注释：单行注释 &lt;code&gt;#&lt;/code&gt;，多行注</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://whz0325.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Python" scheme="https://whz0325.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【洛谷 P1175】表达式求值</title>
    <link href="https://whz0325.github.io/lg-p1175/"/>
    <id>https://whz0325.github.io/lg-p1175/</id>
    <published>2022-09-19T14:38:34.000Z</published>
    <updated>2023-03-08T05:35:56.783Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个中缀表达式，输出它的后缀表达式及对后缀表达式求值时每一步的结果。</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>基础题，转后缀的过程中用栈保存运算符，每当当前运算符与栈顶运算符相同（按从左到右顺序计算）或栈顶运算符优先级更高时，要将这些运算符优先计算。</p><p>注意特判阶乘。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 105</span></span><br><span class="line"><span class="keyword">char</span> s[N];<span class="keyword">int</span> len;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tp,data;</span><br><span class="line">&#125; arr[N],tmp[N];<span class="keyword">int</span> sz=<span class="number">0</span>,tpsz=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">code</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(c) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="string">&#x27;^&#x27;</span>&amp;&amp;b==<span class="string">&#x27;^&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">code</span>(a)&gt;=<span class="built_in">code</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>) ans*=n;</span><br><span class="line">        n=n*n;k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i].tp) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,(<span class="keyword">char</span>)arr[i].data);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,arr[i].data);</span><br><span class="line">        <span class="built_in">putchar</span>(i+<span class="number">1</span>&lt;sz?<span class="string">&#x27; &#x27;</span>:<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    std::stack&lt;<span class="keyword">char</span>&gt; op;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&#x27;0&#x27;</span>&lt;=s[i]&amp;&amp;s[i]&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            arr[sz++]=(type)&#123;<span class="number">0</span>,s[i]-<span class="string">&#x27;0&#x27;</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            op.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(op.<span class="built_in">top</span>()!=<span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                arr[sz++]=(type)&#123;<span class="number">1</span>,op.<span class="built_in">top</span>()&#125;;op.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            op.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(!op.<span class="built_in">empty</span>()&amp;&amp;<span class="built_in">cmp</span>(op.<span class="built_in">top</span>(),s[i])) &#123;</span><br><span class="line">                arr[sz++]=(type)&#123;<span class="number">1</span>,op.<span class="built_in">top</span>()&#125;;</span><br><span class="line">                op.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            op.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!op.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur=op.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span>(cur!=<span class="string">&#x27;(&#x27;</span>) arr[sz++]=(type)&#123;<span class="number">1</span>,cur&#125;;op.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">while</span>(sz&gt;<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">bool</span> find=<span class="literal">false</span>;tpsz=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!find&amp;&amp;arr[i].tp) &#123;</span><br><span class="line">                find=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">int</span> y=tmp[--tpsz].data;</span><br><span class="line">                <span class="keyword">int</span> x=tmp[--tpsz].data;</span><br><span class="line">                <span class="built_in"><span class="keyword">switch</span></span>(arr[i].data) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                        tmp[tpsz++]=(type)&#123;<span class="number">0</span>,x+y&#125;;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: </span><br><span class="line">                        tmp[tpsz++]=(type)&#123;<span class="number">0</span>,x-y&#125;;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: </span><br><span class="line">                        tmp[tpsz++]=(type)&#123;<span class="number">0</span>,x*y&#125;;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: </span><br><span class="line">                        tmp[tpsz++]=(type)&#123;<span class="number">0</span>,x/y&#125;;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>: </span><br><span class="line">                        tmp[tpsz++]=(type)&#123;<span class="number">0</span>,<span class="built_in">qpow</span>(x,y)&#125;;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> tmp[tpsz++]=arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tpsz;++i) arr[i]=tmp[i];sz=tpsz;</span><br><span class="line">        <span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一个中缀表达式，输出它的后缀表达式及对后缀表达式求值时每一步的结果。&lt;/p&gt;
&lt;h3 id=&quot;算法分析&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="竞赛题解" scheme="https://whz0325.github.io/categories/%E7%AB%9E%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="栈" scheme="https://whz0325.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
</feed>
